// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u64>,
    length: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetBlockLocationsRequestProto {}

impl GetBlockLocationsRequestProto {
    pub fn new() -> GetBlockLocationsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetBlockLocationsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsRequestProto,
        };
        unsafe {
            instance.get(GetBlockLocationsRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint64 offset = 2;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint64 length = 3;

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }

    fn get_length_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.length
    }

    fn mut_length_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.length
    }
}

impl ::protobuf::Message for GetBlockLocationsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetBlockLocationsRequestProto {
    fn new() -> GetBlockLocationsRequestProto {
        GetBlockLocationsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetBlockLocationsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetBlockLocationsRequestProto::get_src_for_reflect,
                    GetBlockLocationsRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    GetBlockLocationsRequestProto::get_offset_for_reflect,
                    GetBlockLocationsRequestProto::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    GetBlockLocationsRequestProto::get_length_for_reflect,
                    GetBlockLocationsRequestProto::mut_length_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsRequestProto>(
                    "GetBlockLocationsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_offset();
        self.clear_length();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsResponseProto {
    // message fields
    locations: ::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetBlockLocationsResponseProto {}

impl GetBlockLocationsResponseProto {
    pub fn new() -> GetBlockLocationsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetBlockLocationsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsResponseProto,
        };
        unsafe {
            instance.get(GetBlockLocationsResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 1;

    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: super::hdfs::LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations(&mut self) -> &mut super::hdfs::LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        }
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> super::hdfs::LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::new())
    }

    pub fn get_locations(&self) -> &super::hdfs::LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::default_instance())
    }

    fn get_locations_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto> {
        &self.locations
    }

    fn mut_locations_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto> {
        &mut self.locations
    }
}

impl ::protobuf::Message for GetBlockLocationsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.locations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.locations.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetBlockLocationsResponseProto {
    fn new() -> GetBlockLocationsResponseProto {
        GetBlockLocationsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetBlockLocationsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlocksProto>>(
                    "locations",
                    GetBlockLocationsResponseProto::get_locations_for_reflect,
                    GetBlockLocationsResponseProto::mut_locations_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsResponseProto>(
                    "GetBlockLocationsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsResponseProto {
    fn clear(&mut self) {
        self.clear_locations();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetServerDefaultsRequestProto {}

impl GetServerDefaultsRequestProto {
    pub fn new() -> GetServerDefaultsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetServerDefaultsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsRequestProto,
        };
        unsafe {
            instance.get(GetServerDefaultsRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetServerDefaultsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetServerDefaultsRequestProto {
    fn new() -> GetServerDefaultsRequestProto {
        GetServerDefaultsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetServerDefaultsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsRequestProto>(
                    "GetServerDefaultsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsResponseProto {
    // message fields
    serverDefaults: ::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetServerDefaultsResponseProto {}

impl GetServerDefaultsResponseProto {
    pub fn new() -> GetServerDefaultsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetServerDefaultsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsResponseProto,
        };
        unsafe {
            instance.get(GetServerDefaultsResponseProto::new)
        }
    }

    // required .hadoop.hdfs.FsServerDefaultsProto serverDefaults = 1;

    pub fn clear_serverDefaults(&mut self) {
        self.serverDefaults.clear();
    }

    pub fn has_serverDefaults(&self) -> bool {
        self.serverDefaults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverDefaults(&mut self, v: super::hdfs::FsServerDefaultsProto) {
        self.serverDefaults = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverDefaults(&mut self) -> &mut super::hdfs::FsServerDefaultsProto {
        if self.serverDefaults.is_none() {
            self.serverDefaults.set_default();
        }
        self.serverDefaults.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverDefaults(&mut self) -> super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.take().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::new())
    }

    pub fn get_serverDefaults(&self) -> &super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.as_ref().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::default_instance())
    }

    fn get_serverDefaults_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto> {
        &self.serverDefaults
    }

    fn mut_serverDefaults_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto> {
        &mut self.serverDefaults
    }
}

impl ::protobuf::Message for GetServerDefaultsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.serverDefaults.is_none() {
            return false;
        }
        for v in &self.serverDefaults {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverDefaults)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serverDefaults.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serverDefaults.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetServerDefaultsResponseProto {
    fn new() -> GetServerDefaultsResponseProto {
        GetServerDefaultsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetServerDefaultsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsServerDefaultsProto>>(
                    "serverDefaults",
                    GetServerDefaultsResponseProto::get_serverDefaults_for_reflect,
                    GetServerDefaultsResponseProto::mut_serverDefaults_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsResponseProto>(
                    "GetServerDefaultsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsResponseProto {
    fn clear(&mut self) {
        self.clear_serverDefaults();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    createFlag: ::std::option::Option<u32>,
    createParent: ::std::option::Option<bool>,
    replication: ::std::option::Option<u32>,
    blockSize: ::std::option::Option<u64>,
    cryptoProtocolVersion: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>,
    unmasked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    ecPolicyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateRequestProto {}

impl CreateRequestProto {
    pub fn new() -> CreateRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRequestProto,
        };
        unsafe {
            instance.get(CreateRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;

    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::acl::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::acl::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    pub fn get_masked(&self) -> &super::acl::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| super::acl::FsPermissionProto::default_instance())
    }

    fn get_masked_for_reflect(&self) -> &::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &self.masked
    }

    fn mut_masked_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &mut self.masked
    }

    // required string clientName = 3;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // required uint32 createFlag = 4;

    pub fn clear_createFlag(&mut self) {
        self.createFlag = ::std::option::Option::None;
    }

    pub fn has_createFlag(&self) -> bool {
        self.createFlag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createFlag(&mut self, v: u32) {
        self.createFlag = ::std::option::Option::Some(v);
    }

    pub fn get_createFlag(&self) -> u32 {
        self.createFlag.unwrap_or(0)
    }

    fn get_createFlag_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.createFlag
    }

    fn mut_createFlag_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.createFlag
    }

    // required bool createParent = 5;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    fn get_createParent_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createParent
    }

    fn mut_createParent_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createParent
    }

    // required uint32 replication = 6;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    fn get_replication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replication
    }

    fn mut_replication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replication
    }

    // required uint64 blockSize = 7;

    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    pub fn get_blockSize(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }

    fn get_blockSize_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.blockSize
    }

    fn mut_blockSize_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.blockSize
    }

    // repeated .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 8;

    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>) {
        self.cryptoProtocolVersion = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoProtocolVersion(&mut self) -> &mut ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }

    // Take field
    pub fn take_cryptoProtocolVersion(&mut self) -> ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        ::std::mem::replace(&mut self.cryptoProtocolVersion, ::std::vec::Vec::new())
    }

    pub fn get_cryptoProtocolVersion(&self) -> &[super::hdfs::CryptoProtocolVersionProto] {
        &self.cryptoProtocolVersion
    }

    fn get_cryptoProtocolVersion_for_reflect(&self) -> &::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &self.cryptoProtocolVersion
    }

    fn mut_cryptoProtocolVersion_for_reflect(&mut self) -> &mut ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }

    // optional .hadoop.hdfs.FsPermissionProto unmasked = 9;

    pub fn clear_unmasked(&mut self) {
        self.unmasked.clear();
    }

    pub fn has_unmasked(&self) -> bool {
        self.unmasked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unmasked(&mut self, v: super::acl::FsPermissionProto) {
        self.unmasked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unmasked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.unmasked.is_none() {
            self.unmasked.set_default();
        }
        self.unmasked.as_mut().unwrap()
    }

    // Take field
    pub fn take_unmasked(&mut self) -> super::acl::FsPermissionProto {
        self.unmasked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    pub fn get_unmasked(&self) -> &super::acl::FsPermissionProto {
        self.unmasked.as_ref().unwrap_or_else(|| super::acl::FsPermissionProto::default_instance())
    }

    fn get_unmasked_for_reflect(&self) -> &::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &self.unmasked
    }

    fn mut_unmasked_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &mut self.unmasked
    }

    // optional string ecPolicyName = 10;

    pub fn clear_ecPolicyName(&mut self) {
        self.ecPolicyName.clear();
    }

    pub fn has_ecPolicyName(&self) -> bool {
        self.ecPolicyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecPolicyName(&mut self, v: ::std::string::String) {
        self.ecPolicyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecPolicyName(&mut self) -> &mut ::std::string::String {
        if self.ecPolicyName.is_none() {
            self.ecPolicyName.set_default();
        }
        self.ecPolicyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecPolicyName(&mut self) -> ::std::string::String {
        self.ecPolicyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ecPolicyName(&self) -> &str {
        match self.ecPolicyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ecPolicyName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ecPolicyName
    }

    fn mut_ecPolicyName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ecPolicyName
    }
}

impl ::protobuf::Message for CreateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        if self.createFlag.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        if self.blockSize.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unmasked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.createFlag = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.cryptoProtocolVersion)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unmasked)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ecPolicyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.createFlag {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockSize {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        if let Some(ref v) = self.unmasked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ecPolicyName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.createFlag {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.blockSize {
            os.write_uint64(7, v)?;
        }
        for v in &self.cryptoProtocolVersion {
            os.write_enum(8, v.value())?;
        };
        if let Some(ref v) = self.unmasked.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ecPolicyName.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateRequestProto {
    fn new() -> CreateRequestProto {
        CreateRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    CreateRequestProto::get_src_for_reflect,
                    CreateRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                    "masked",
                    CreateRequestProto::get_masked_for_reflect,
                    CreateRequestProto::mut_masked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    CreateRequestProto::get_clientName_for_reflect,
                    CreateRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "createFlag",
                    CreateRequestProto::get_createFlag_for_reflect,
                    CreateRequestProto::mut_createFlag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    CreateRequestProto::get_createParent_for_reflect,
                    CreateRequestProto::mut_createParent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    CreateRequestProto::get_replication_for_reflect,
                    CreateRequestProto::mut_replication_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockSize",
                    CreateRequestProto::get_blockSize_for_reflect,
                    CreateRequestProto::mut_blockSize_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::CryptoProtocolVersionProto>>(
                    "cryptoProtocolVersion",
                    CreateRequestProto::get_cryptoProtocolVersion_for_reflect,
                    CreateRequestProto::mut_cryptoProtocolVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                    "unmasked",
                    CreateRequestProto::get_unmasked_for_reflect,
                    CreateRequestProto::mut_unmasked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ecPolicyName",
                    CreateRequestProto::get_ecPolicyName_for_reflect,
                    CreateRequestProto::mut_ecPolicyName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRequestProto>(
                    "CreateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_masked();
        self.clear_clientName();
        self.clear_createFlag();
        self.clear_createParent();
        self.clear_replication();
        self.clear_blockSize();
        self.clear_cryptoProtocolVersion();
        self.clear_unmasked();
        self.clear_ecPolicyName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateResponseProto {}

impl CreateResponseProto {
    pub fn new() -> CreateResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResponseProto,
        };
        unsafe {
            instance.get(CreateResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_fs_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.fs
    }

    fn mut_fs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.fs
    }
}

impl ::protobuf::Message for CreateResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateResponseProto {
    fn new() -> CreateResponseProto {
        CreateResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    CreateResponseProto::get_fs_for_reflect,
                    CreateResponseProto::mut_fs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResponseProto>(
                    "CreateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    flag: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AppendRequestProto {}

impl AppendRequestProto {
    pub fn new() -> AppendRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AppendRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendRequestProto,
        };
        unsafe {
            instance.get(AppendRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // optional uint32 flag = 3;

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }

    pub fn get_flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }

    fn get_flag_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flag
    }

    fn mut_flag_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flag
    }
}

impl ::protobuf::Message for AppendRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AppendRequestProto {
    fn new() -> AppendRequestProto {
        AppendRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AppendRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    AppendRequestProto::get_src_for_reflect,
                    AppendRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    AppendRequestProto::get_clientName_for_reflect,
                    AppendRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flag",
                    AppendRequestProto::get_flag_for_reflect,
                    AppendRequestProto::mut_flag_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendRequestProto>(
                    "AppendRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AppendRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    stat: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AppendResponseProto {}

impl AppendResponseProto {
    pub fn new() -> AppendResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AppendResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendResponseProto,
        };
        unsafe {
            instance.get(AppendResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.stat.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_stat(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.stat.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.stat
    }
}

impl ::protobuf::Message for AppendResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AppendResponseProto {
    fn new() -> AppendResponseProto {
        AppendResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AppendResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    AppendResponseProto::get_block_for_reflect,
                    AppendResponseProto::mut_block_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "stat",
                    AppendResponseProto::get_stat_for_reflect,
                    AppendResponseProto::mut_stat_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendResponseProto>(
                    "AppendResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AppendResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.clear_stat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetReplicationRequestProto {}

impl SetReplicationRequestProto {
    pub fn new() -> SetReplicationRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetReplicationRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationRequestProto,
        };
        unsafe {
            instance.get(SetReplicationRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint32 replication = 2;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    fn get_replication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replication
    }

    fn mut_replication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replication
    }
}

impl ::protobuf::Message for SetReplicationRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetReplicationRequestProto {
    fn new() -> SetReplicationRequestProto {
        SetReplicationRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetReplicationRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetReplicationRequestProto::get_src_for_reflect,
                    SetReplicationRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    SetReplicationRequestProto::get_replication_for_reflect,
                    SetReplicationRequestProto::mut_replication_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationRequestProto>(
                    "SetReplicationRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetReplicationRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_replication();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetReplicationResponseProto {}

impl SetReplicationResponseProto {
    pub fn new() -> SetReplicationResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetReplicationResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationResponseProto,
        };
        unsafe {
            instance.get(SetReplicationResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for SetReplicationResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetReplicationResponseProto {
    fn new() -> SetReplicationResponseProto {
        SetReplicationResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetReplicationResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    SetReplicationResponseProto::get_result_for_reflect,
                    SetReplicationResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationResponseProto>(
                    "SetReplicationResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetReplicationResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    policyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetStoragePolicyRequestProto {}

impl SetStoragePolicyRequestProto {
    pub fn new() -> SetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(SetStoragePolicyRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string policyName = 2;

    pub fn clear_policyName(&mut self) {
        self.policyName.clear();
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName.set_default();
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_policyName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.policyName
    }

    fn mut_policyName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.policyName
    }
}

impl ::protobuf::Message for SetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.policyName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.policyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.policyName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetStoragePolicyRequestProto {
    fn new() -> SetStoragePolicyRequestProto {
        SetStoragePolicyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetStoragePolicyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetStoragePolicyRequestProto::get_src_for_reflect,
                    SetStoragePolicyRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "policyName",
                    SetStoragePolicyRequestProto::get_policyName_for_reflect,
                    SetStoragePolicyRequestProto::mut_policyName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyRequestProto>(
                    "SetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_policyName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetStoragePolicyResponseProto {}

impl SetStoragePolicyResponseProto {
    pub fn new() -> SetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(SetStoragePolicyResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetStoragePolicyResponseProto {
    fn new() -> SetStoragePolicyResponseProto {
        SetStoragePolicyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetStoragePolicyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyResponseProto>(
                    "SetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UnsetStoragePolicyRequestProto {}

impl UnsetStoragePolicyRequestProto {
    pub fn new() -> UnsetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UnsetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UnsetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(UnsetStoragePolicyRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for UnsetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UnsetStoragePolicyRequestProto {
    fn new() -> UnsetStoragePolicyRequestProto {
        UnsetStoragePolicyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UnsetStoragePolicyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    UnsetStoragePolicyRequestProto::get_src_for_reflect,
                    UnsetStoragePolicyRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnsetStoragePolicyRequestProto>(
                    "UnsetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UnsetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsetStoragePolicyResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UnsetStoragePolicyResponseProto {}

impl UnsetStoragePolicyResponseProto {
    pub fn new() -> UnsetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UnsetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UnsetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(UnsetStoragePolicyResponseProto::new)
        }
    }
}

impl ::protobuf::Message for UnsetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UnsetStoragePolicyResponseProto {
    fn new() -> UnsetStoragePolicyResponseProto {
        UnsetStoragePolicyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UnsetStoragePolicyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UnsetStoragePolicyResponseProto>(
                    "UnsetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UnsetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePolicyRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetStoragePolicyRequestProto {}

impl GetStoragePolicyRequestProto {
    pub fn new() -> GetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(GetStoragePolicyRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for GetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePolicyRequestProto {
    fn new() -> GetStoragePolicyRequestProto {
        GetStoragePolicyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePolicyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GetStoragePolicyRequestProto::get_path_for_reflect,
                    GetStoragePolicyRequestProto::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePolicyRequestProto>(
                    "GetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePolicyResponseProto {
    // message fields
    storagePolicy: ::protobuf::SingularPtrField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetStoragePolicyResponseProto {}

impl GetStoragePolicyResponseProto {
    pub fn new() -> GetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(GetStoragePolicyResponseProto::new)
        }
    }

    // required .hadoop.hdfs.BlockStoragePolicyProto storagePolicy = 1;

    pub fn clear_storagePolicy(&mut self) {
        self.storagePolicy.clear();
    }

    pub fn has_storagePolicy(&self) -> bool {
        self.storagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicy(&mut self, v: super::hdfs::BlockStoragePolicyProto) {
        self.storagePolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicy(&mut self) -> &mut super::hdfs::BlockStoragePolicyProto {
        if self.storagePolicy.is_none() {
            self.storagePolicy.set_default();
        }
        self.storagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicy(&mut self) -> super::hdfs::BlockStoragePolicyProto {
        self.storagePolicy.take().unwrap_or_else(|| super::hdfs::BlockStoragePolicyProto::new())
    }

    pub fn get_storagePolicy(&self) -> &super::hdfs::BlockStoragePolicyProto {
        self.storagePolicy.as_ref().unwrap_or_else(|| super::hdfs::BlockStoragePolicyProto::default_instance())
    }

    fn get_storagePolicy_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::BlockStoragePolicyProto> {
        &self.storagePolicy
    }

    fn mut_storagePolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.storagePolicy
    }
}

impl ::protobuf::Message for GetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        if self.storagePolicy.is_none() {
            return false;
        }
        for v in &self.storagePolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storagePolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storagePolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storagePolicy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePolicyResponseProto {
    fn new() -> GetStoragePolicyResponseProto {
        GetStoragePolicyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePolicyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                    "storagePolicy",
                    GetStoragePolicyResponseProto::get_storagePolicy_for_reflect,
                    GetStoragePolicyResponseProto::mut_storagePolicy_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePolicyResponseProto>(
                    "GetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.clear_storagePolicy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetStoragePoliciesRequestProto {}

impl GetStoragePoliciesRequestProto {
    pub fn new() -> GetStoragePoliciesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePoliciesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesRequestProto,
        };
        unsafe {
            instance.get(GetStoragePoliciesRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetStoragePoliciesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePoliciesRequestProto {
    fn new() -> GetStoragePoliciesRequestProto {
        GetStoragePoliciesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePoliciesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesRequestProto>(
                    "GetStoragePoliciesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesResponseProto {
    // message fields
    policies: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetStoragePoliciesResponseProto {}

impl GetStoragePoliciesResponseProto {
    pub fn new() -> GetStoragePoliciesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetStoragePoliciesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesResponseProto,
        };
        unsafe {
            instance.get(GetStoragePoliciesResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.BlockStoragePolicyProto policies = 1;

    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }

    pub fn get_policies(&self) -> &[super::hdfs::BlockStoragePolicyProto] {
        &self.policies
    }

    fn get_policies_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &self.policies
    }

    fn mut_policies_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.policies
    }
}

impl ::protobuf::Message for GetStoragePoliciesResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.policies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetStoragePoliciesResponseProto {
    fn new() -> GetStoragePoliciesResponseProto {
        GetStoragePoliciesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetStoragePoliciesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                    "policies",
                    GetStoragePoliciesResponseProto::get_policies_for_reflect,
                    GetStoragePoliciesResponseProto::mut_policies_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesResponseProto>(
                    "GetStoragePoliciesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesResponseProto {
    fn clear(&mut self) {
        self.clear_policies();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    permission: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetPermissionRequestProto {}

impl SetPermissionRequestProto {
    pub fn new() -> SetPermissionRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetPermissionRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionRequestProto,
        };
        unsafe {
            instance.get(SetPermissionRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 2;

    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::acl::FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::acl::FsPermissionProto {
        self.permission.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    pub fn get_permission(&self) -> &super::acl::FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| super::acl::FsPermissionProto::default_instance())
    }

    fn get_permission_for_reflect(&self) -> &::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &self.permission
    }

    fn mut_permission_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &mut self.permission
    }
}

impl ::protobuf::Message for SetPermissionRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetPermissionRequestProto {
    fn new() -> SetPermissionRequestProto {
        SetPermissionRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetPermissionRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetPermissionRequestProto::get_src_for_reflect,
                    SetPermissionRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                    "permission",
                    SetPermissionRequestProto::get_permission_for_reflect,
                    SetPermissionRequestProto::mut_permission_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionRequestProto>(
                    "SetPermissionRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetPermissionRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_permission();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetPermissionResponseProto {}

impl SetPermissionResponseProto {
    pub fn new() -> SetPermissionResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetPermissionResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionResponseProto,
        };
        unsafe {
            instance.get(SetPermissionResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetPermissionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetPermissionResponseProto {
    fn new() -> SetPermissionResponseProto {
        SetPermissionResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetPermissionResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionResponseProto>(
                    "SetPermissionResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetPermissionResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    username: ::protobuf::SingularField<::std::string::String>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetOwnerRequestProto {}

impl SetOwnerRequestProto {
    pub fn new() -> SetOwnerRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetOwnerRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerRequestProto,
        };
        unsafe {
            instance.get(SetOwnerRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // optional string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_username_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.username
    }

    fn mut_username_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.username
    }

    // optional string groupname = 3;

    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_groupname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.groupname
    }

    fn mut_groupname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.groupname
    }
}

impl ::protobuf::Message for SetOwnerRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetOwnerRequestProto {
    fn new() -> SetOwnerRequestProto {
        SetOwnerRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetOwnerRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetOwnerRequestProto::get_src_for_reflect,
                    SetOwnerRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    SetOwnerRequestProto::get_username_for_reflect,
                    SetOwnerRequestProto::mut_username_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groupname",
                    SetOwnerRequestProto::get_groupname_for_reflect,
                    SetOwnerRequestProto::mut_groupname_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerRequestProto>(
                    "SetOwnerRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetOwnerRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_username();
        self.clear_groupname();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetOwnerResponseProto {}

impl SetOwnerResponseProto {
    pub fn new() -> SetOwnerResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetOwnerResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerResponseProto,
        };
        unsafe {
            instance.get(SetOwnerResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetOwnerResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetOwnerResponseProto {
    fn new() -> SetOwnerResponseProto {
        SetOwnerResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetOwnerResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerResponseProto>(
                    "SetOwnerResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetOwnerResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockRequestProto {
    // message fields
    b: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    src: ::protobuf::SingularField<::std::string::String>,
    holder: ::protobuf::SingularField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AbandonBlockRequestProto {}

impl AbandonBlockRequestProto {
    pub fn new() -> AbandonBlockRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AbandonBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockRequestProto,
        };
        unsafe {
            instance.get(AbandonBlockRequestProto::new)
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;

    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_b(&self) -> &super::hdfs::ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_b_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.b
    }

    fn mut_b_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.b
    }

    // required string src = 2;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string holder = 3;

    pub fn clear_holder(&mut self) {
        self.holder.clear();
    }

    pub fn has_holder(&self) -> bool {
        self.holder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holder(&mut self, v: ::std::string::String) {
        self.holder = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder(&mut self) -> &mut ::std::string::String {
        if self.holder.is_none() {
            self.holder.set_default();
        }
        self.holder.as_mut().unwrap()
    }

    // Take field
    pub fn take_holder(&mut self) -> ::std::string::String {
        self.holder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_holder(&self) -> &str {
        match self.holder.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_holder_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.holder
    }

    fn mut_holder_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.holder
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for AbandonBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        }
        if self.src.is_none() {
            return false;
        }
        if self.holder.is_none() {
            return false;
        }
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.holder)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.holder.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.holder.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AbandonBlockRequestProto {
    fn new() -> AbandonBlockRequestProto {
        AbandonBlockRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AbandonBlockRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "b",
                    AbandonBlockRequestProto::get_b_for_reflect,
                    AbandonBlockRequestProto::mut_b_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    AbandonBlockRequestProto::get_src_for_reflect,
                    AbandonBlockRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "holder",
                    AbandonBlockRequestProto::get_holder_for_reflect,
                    AbandonBlockRequestProto::mut_holder_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    AbandonBlockRequestProto::get_fileId_for_reflect,
                    AbandonBlockRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockRequestProto>(
                    "AbandonBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AbandonBlockRequestProto {
    fn clear(&mut self) {
        self.clear_b();
        self.clear_src();
        self.clear_holder();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AbandonBlockResponseProto {}

impl AbandonBlockResponseProto {
    pub fn new() -> AbandonBlockResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AbandonBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockResponseProto,
        };
        unsafe {
            instance.get(AbandonBlockResponseProto::new)
        }
    }
}

impl ::protobuf::Message for AbandonBlockResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AbandonBlockResponseProto {
    fn new() -> AbandonBlockResponseProto {
        AbandonBlockResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AbandonBlockResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockResponseProto>(
                    "AbandonBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AbandonBlockResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    previous: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    excludeNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    fileId: ::std::option::Option<u64>,
    favoredNodes: ::protobuf::RepeatedField<::std::string::String>,
    flags: ::std::vec::Vec<AddBlockFlagProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddBlockRequestProto {}

impl AddBlockRequestProto {
    pub fn new() -> AddBlockRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockRequestProto,
        };
        unsafe {
            instance.get(AddBlockRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // optional .hadoop.hdfs.ExtendedBlockProto previous = 3;

    pub fn clear_previous(&mut self) {
        self.previous.clear();
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.previous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.previous.is_none() {
            self.previous.set_default();
        }
        self.previous.as_mut().unwrap()
    }

    // Take field
    pub fn take_previous(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.previous.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_previous(&self) -> &super::hdfs::ExtendedBlockProto {
        self.previous.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_previous_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.previous
    }

    fn mut_previous_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.previous
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludeNodes = 4;

    pub fn clear_excludeNodes(&mut self) {
        self.excludeNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludeNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // Take field
    pub fn take_excludeNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludeNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_excludeNodes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludeNodes
    }

    fn get_excludeNodes_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.excludeNodes
    }

    fn mut_excludeNodes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // optional uint64 fileId = 5;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }

    // repeated string favoredNodes = 6;

    pub fn clear_favoredNodes(&mut self) {
        self.favoredNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_favoredNodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.favoredNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_favoredNodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }

    // Take field
    pub fn take_favoredNodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.favoredNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_favoredNodes(&self) -> &[::std::string::String] {
        &self.favoredNodes
    }

    fn get_favoredNodes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.favoredNodes
    }

    fn mut_favoredNodes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }

    // repeated .hadoop.hdfs.AddBlockFlagProto flags = 7;

    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: ::std::vec::Vec<AddBlockFlagProto>) {
        self.flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flags(&mut self) -> &mut ::std::vec::Vec<AddBlockFlagProto> {
        &mut self.flags
    }

    // Take field
    pub fn take_flags(&mut self) -> ::std::vec::Vec<AddBlockFlagProto> {
        ::std::mem::replace(&mut self.flags, ::std::vec::Vec::new())
    }

    pub fn get_flags(&self) -> &[AddBlockFlagProto] {
        &self.flags
    }

    fn get_flags_for_reflect(&self) -> &::std::vec::Vec<AddBlockFlagProto> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::vec::Vec<AddBlockFlagProto> {
        &mut self.flags
    }
}

impl ::protobuf::Message for AddBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.previous {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludeNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.previous)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludeNodes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.favoredNodes)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.previous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.excludeNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.favoredNodes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.flags {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.previous.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.excludeNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(5, v)?;
        }
        for v in &self.favoredNodes {
            os.write_string(6, &v)?;
        };
        for v in &self.flags {
            os.write_enum(7, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddBlockRequestProto {
    fn new() -> AddBlockRequestProto {
        AddBlockRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddBlockRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    AddBlockRequestProto::get_src_for_reflect,
                    AddBlockRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    AddBlockRequestProto::get_clientName_for_reflect,
                    AddBlockRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "previous",
                    AddBlockRequestProto::get_previous_for_reflect,
                    AddBlockRequestProto::mut_previous_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "excludeNodes",
                    AddBlockRequestProto::get_excludeNodes_for_reflect,
                    AddBlockRequestProto::mut_excludeNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    AddBlockRequestProto::get_fileId_for_reflect,
                    AddBlockRequestProto::mut_fileId_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "favoredNodes",
                    AddBlockRequestProto::get_favoredNodes_for_reflect,
                    AddBlockRequestProto::mut_favoredNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddBlockFlagProto>>(
                    "flags",
                    AddBlockRequestProto::get_flags_for_reflect,
                    AddBlockRequestProto::mut_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockRequestProto>(
                    "AddBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddBlockRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_previous();
        self.clear_excludeNodes();
        self.clear_fileId();
        self.clear_favoredNodes();
        self.clear_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddBlockResponseProto {}

impl AddBlockResponseProto {
    pub fn new() -> AddBlockResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockResponseProto,
        };
        unsafe {
            instance.get(AddBlockResponseProto::new)
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for AddBlockResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddBlockResponseProto {
    fn new() -> AddBlockResponseProto {
        AddBlockResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddBlockResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    AddBlockResponseProto::get_block_for_reflect,
                    AddBlockResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockResponseProto>(
                    "AddBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddBlockResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    blk: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    existings: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    excludes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    numAdditionalNodes: ::std::option::Option<u32>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    existingStorageUuids: ::protobuf::RepeatedField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetAdditionalDatanodeRequestProto {}

impl GetAdditionalDatanodeRequestProto {
    pub fn new() -> GetAdditionalDatanodeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetAdditionalDatanodeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeRequestProto,
        };
        unsafe {
            instance.get(GetAdditionalDatanodeRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.ExtendedBlockProto blk = 2;

    pub fn clear_blk(&mut self) {
        self.blk.clear();
    }

    pub fn has_blk(&self) -> bool {
        self.blk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blk(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.blk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blk(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.blk.is_none() {
            self.blk.set_default();
        }
        self.blk.as_mut().unwrap()
    }

    // Take field
    pub fn take_blk(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.blk.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_blk(&self) -> &super::hdfs::ExtendedBlockProto {
        self.blk.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_blk_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.blk
    }

    fn mut_blk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.blk
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto existings = 3;

    pub fn clear_existings(&mut self) {
        self.existings.clear();
    }

    // Param is passed by value, moved
    pub fn set_existings(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.existings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existings(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.existings
    }

    // Take field
    pub fn take_existings(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.existings, ::protobuf::RepeatedField::new())
    }

    pub fn get_existings(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.existings
    }

    fn get_existings_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.existings
    }

    fn mut_existings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.existings
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludes = 4;

    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    pub fn get_excludes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludes
    }

    fn get_excludes_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.excludes
    }

    fn mut_excludes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludes
    }

    // required uint32 numAdditionalNodes = 5;

    pub fn clear_numAdditionalNodes(&mut self) {
        self.numAdditionalNodes = ::std::option::Option::None;
    }

    pub fn has_numAdditionalNodes(&self) -> bool {
        self.numAdditionalNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numAdditionalNodes(&mut self, v: u32) {
        self.numAdditionalNodes = ::std::option::Option::Some(v);
    }

    pub fn get_numAdditionalNodes(&self) -> u32 {
        self.numAdditionalNodes.unwrap_or(0)
    }

    fn get_numAdditionalNodes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.numAdditionalNodes
    }

    fn mut_numAdditionalNodes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.numAdditionalNodes
    }

    // required string clientName = 6;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // repeated string existingStorageUuids = 7;

    pub fn clear_existingStorageUuids(&mut self) {
        self.existingStorageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_existingStorageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.existingStorageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existingStorageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // Take field
    pub fn take_existingStorageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.existingStorageUuids, ::protobuf::RepeatedField::new())
    }

    pub fn get_existingStorageUuids(&self) -> &[::std::string::String] {
        &self.existingStorageUuids
    }

    fn get_existingStorageUuids_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.existingStorageUuids
    }

    fn mut_existingStorageUuids_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // optional uint64 fileId = 8;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.blk.is_none() {
            return false;
        }
        if self.numAdditionalNodes.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.blk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.existings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blk)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.existings)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numAdditionalNodes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.existingStorageUuids)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.blk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.existings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.excludes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numAdditionalNodes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.existingStorageUuids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.blk.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.existings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.excludes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numAdditionalNodes {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.existingStorageUuids {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetAdditionalDatanodeRequestProto {
    fn new() -> GetAdditionalDatanodeRequestProto {
        GetAdditionalDatanodeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetAdditionalDatanodeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetAdditionalDatanodeRequestProto::get_src_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "blk",
                    GetAdditionalDatanodeRequestProto::get_blk_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_blk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "existings",
                    GetAdditionalDatanodeRequestProto::get_existings_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_existings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "excludes",
                    GetAdditionalDatanodeRequestProto::get_excludes_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_excludes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numAdditionalNodes",
                    GetAdditionalDatanodeRequestProto::get_numAdditionalNodes_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_numAdditionalNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    GetAdditionalDatanodeRequestProto::get_clientName_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "existingStorageUuids",
                    GetAdditionalDatanodeRequestProto::get_existingStorageUuids_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_existingStorageUuids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    GetAdditionalDatanodeRequestProto::get_fileId_for_reflect,
                    GetAdditionalDatanodeRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeRequestProto>(
                    "GetAdditionalDatanodeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_blk();
        self.clear_existings();
        self.clear_excludes();
        self.clear_numAdditionalNodes();
        self.clear_clientName();
        self.clear_existingStorageUuids();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetAdditionalDatanodeResponseProto {}

impl GetAdditionalDatanodeResponseProto {
    pub fn new() -> GetAdditionalDatanodeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetAdditionalDatanodeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeResponseProto,
        };
        unsafe {
            instance.get(GetAdditionalDatanodeResponseProto::new)
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetAdditionalDatanodeResponseProto {
    fn new() -> GetAdditionalDatanodeResponseProto {
        GetAdditionalDatanodeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetAdditionalDatanodeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    GetAdditionalDatanodeResponseProto::get_block_for_reflect,
                    GetAdditionalDatanodeResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeResponseProto>(
                    "GetAdditionalDatanodeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    last: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CompleteRequestProto {}

impl CompleteRequestProto {
    pub fn new() -> CompleteRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteRequestProto,
        };
        unsafe {
            instance.get(CompleteRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // optional .hadoop.hdfs.ExtendedBlockProto last = 3;

    pub fn clear_last(&mut self) {
        self.last.clear();
    }

    pub fn has_last(&self) -> bool {
        self.last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.last = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.last.is_none() {
            self.last.set_default();
        }
        self.last.as_mut().unwrap()
    }

    // Take field
    pub fn take_last(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.last.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_last(&self) -> &super::hdfs::ExtendedBlockProto {
        self.last.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_last_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.last
    }

    fn mut_last_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.last
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for CompleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.last {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.last.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.last.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompleteRequestProto {
    fn new() -> CompleteRequestProto {
        CompleteRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompleteRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    CompleteRequestProto::get_src_for_reflect,
                    CompleteRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    CompleteRequestProto::get_clientName_for_reflect,
                    CompleteRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "last",
                    CompleteRequestProto::get_last_for_reflect,
                    CompleteRequestProto::mut_last_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    CompleteRequestProto::get_fileId_for_reflect,
                    CompleteRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteRequestProto>(
                    "CompleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompleteRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.clear_last();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CompleteResponseProto {}

impl CompleteResponseProto {
    pub fn new() -> CompleteResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteResponseProto,
        };
        unsafe {
            instance.get(CompleteResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CompleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompleteResponseProto {
    fn new() -> CompleteResponseProto {
        CompleteResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompleteResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CompleteResponseProto::get_result_for_reflect,
                    CompleteResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteResponseProto>(
                    "CompleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompleteResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksRequestProto {
    // message fields
    blocks: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReportBadBlocksRequestProto {}

impl ReportBadBlocksRequestProto {
    pub fn new() -> ReportBadBlocksRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReportBadBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksRequestProto,
        };
        unsafe {
            instance.get(ReportBadBlocksRequestProto::new)
        }
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::hdfs::LocatedBlockProto] {
        &self.blocks
    }

    fn get_blocks_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &self.blocks
    }

    fn mut_blocks_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }
}

impl ::protobuf::Message for ReportBadBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReportBadBlocksRequestProto {
    fn new() -> ReportBadBlocksRequestProto {
        ReportBadBlocksRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReportBadBlocksRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "blocks",
                    ReportBadBlocksRequestProto::get_blocks_for_reflect,
                    ReportBadBlocksRequestProto::mut_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksRequestProto>(
                    "ReportBadBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksRequestProto {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReportBadBlocksResponseProto {}

impl ReportBadBlocksResponseProto {
    pub fn new() -> ReportBadBlocksResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReportBadBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksResponseProto,
        };
        unsafe {
            instance.get(ReportBadBlocksResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ReportBadBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReportBadBlocksResponseProto {
    fn new() -> ReportBadBlocksResponseProto {
        ReportBadBlocksResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReportBadBlocksResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksResponseProto>(
                    "ReportBadBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatRequestProto {
    // message fields
    trg: ::protobuf::SingularField<::std::string::String>,
    srcs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConcatRequestProto {}

impl ConcatRequestProto {
    pub fn new() -> ConcatRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConcatRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatRequestProto,
        };
        unsafe {
            instance.get(ConcatRequestProto::new)
        }
    }

    // required string trg = 1;

    pub fn clear_trg(&mut self) {
        self.trg.clear();
    }

    pub fn has_trg(&self) -> bool {
        self.trg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trg(&mut self, v: ::std::string::String) {
        self.trg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trg(&mut self) -> &mut ::std::string::String {
        if self.trg.is_none() {
            self.trg.set_default();
        }
        self.trg.as_mut().unwrap()
    }

    // Take field
    pub fn take_trg(&mut self) -> ::std::string::String {
        self.trg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_trg(&self) -> &str {
        match self.trg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_trg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.trg
    }

    fn mut_trg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.trg
    }

    // repeated string srcs = 2;

    pub fn clear_srcs(&mut self) {
        self.srcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.srcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_srcs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }

    // Take field
    pub fn take_srcs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.srcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_srcs(&self) -> &[::std::string::String] {
        &self.srcs
    }

    fn get_srcs_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.srcs
    }

    fn mut_srcs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }
}

impl ::protobuf::Message for ConcatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.trg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trg)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.srcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.srcs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trg.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.srcs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConcatRequestProto {
    fn new() -> ConcatRequestProto {
        ConcatRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConcatRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "trg",
                    ConcatRequestProto::get_trg_for_reflect,
                    ConcatRequestProto::mut_trg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "srcs",
                    ConcatRequestProto::get_srcs_for_reflect,
                    ConcatRequestProto::mut_srcs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConcatRequestProto>(
                    "ConcatRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConcatRequestProto {
    fn clear(&mut self) {
        self.clear_trg();
        self.clear_srcs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConcatResponseProto {}

impl ConcatResponseProto {
    pub fn new() -> ConcatResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConcatResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatResponseProto,
        };
        unsafe {
            instance.get(ConcatResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ConcatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConcatResponseProto {
    fn new() -> ConcatResponseProto {
        ConcatResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConcatResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConcatResponseProto>(
                    "ConcatResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConcatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    newLength: ::std::option::Option<u64>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TruncateRequestProto {}

impl TruncateRequestProto {
    pub fn new() -> TruncateRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TruncateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<TruncateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncateRequestProto,
        };
        unsafe {
            instance.get(TruncateRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint64 newLength = 2;

    pub fn clear_newLength(&mut self) {
        self.newLength = ::std::option::Option::None;
    }

    pub fn has_newLength(&self) -> bool {
        self.newLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLength(&mut self, v: u64) {
        self.newLength = ::std::option::Option::Some(v);
    }

    pub fn get_newLength(&self) -> u64 {
        self.newLength.unwrap_or(0)
    }

    fn get_newLength_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.newLength
    }

    fn mut_newLength_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.newLength
    }

    // required string clientName = 3;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for TruncateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.newLength.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.newLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.newLength {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TruncateRequestProto {
    fn new() -> TruncateRequestProto {
        TruncateRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<TruncateRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    TruncateRequestProto::get_src_for_reflect,
                    TruncateRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newLength",
                    TruncateRequestProto::get_newLength_for_reflect,
                    TruncateRequestProto::mut_newLength_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    TruncateRequestProto::get_clientName_for_reflect,
                    TruncateRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncateRequestProto>(
                    "TruncateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TruncateRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_newLength();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncateResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TruncateResponseProto {}

impl TruncateResponseProto {
    pub fn new() -> TruncateResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TruncateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<TruncateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncateResponseProto,
        };
        unsafe {
            instance.get(TruncateResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for TruncateResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TruncateResponseProto {
    fn new() -> TruncateResponseProto {
        TruncateResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<TruncateResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    TruncateResponseProto::get_result_for_reflect,
                    TruncateResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncateResponseProto>(
                    "TruncateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TruncateResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameRequestProto {}

impl RenameRequestProto {
    pub fn new() -> RenameRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameRequestProto,
        };
        unsafe {
            instance.get(RenameRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dst_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dst
    }

    fn mut_dst_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dst
    }
}

impl ::protobuf::Message for RenameRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameRequestProto {
    fn new() -> RenameRequestProto {
        RenameRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    RenameRequestProto::get_src_for_reflect,
                    RenameRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst",
                    RenameRequestProto::get_dst_for_reflect,
                    RenameRequestProto::mut_dst_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameRequestProto>(
                    "RenameRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameResponseProto {}

impl RenameResponseProto {
    pub fn new() -> RenameResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameResponseProto,
        };
        unsafe {
            instance.get(RenameResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for RenameResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameResponseProto {
    fn new() -> RenameResponseProto {
        RenameResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    RenameResponseProto::get_result_for_reflect,
                    RenameResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameResponseProto>(
                    "RenameResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2RequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    overwriteDest: ::std::option::Option<bool>,
    moveToTrash: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Rename2RequestProto {}

impl Rename2RequestProto {
    pub fn new() -> Rename2RequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Rename2RequestProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2RequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2RequestProto,
        };
        unsafe {
            instance.get(Rename2RequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dst_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dst
    }

    fn mut_dst_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dst
    }

    // required bool overwriteDest = 3;

    pub fn clear_overwriteDest(&mut self) {
        self.overwriteDest = ::std::option::Option::None;
    }

    pub fn has_overwriteDest(&self) -> bool {
        self.overwriteDest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwriteDest(&mut self, v: bool) {
        self.overwriteDest = ::std::option::Option::Some(v);
    }

    pub fn get_overwriteDest(&self) -> bool {
        self.overwriteDest.unwrap_or(false)
    }

    fn get_overwriteDest_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.overwriteDest
    }

    fn mut_overwriteDest_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.overwriteDest
    }

    // optional bool moveToTrash = 4;

    pub fn clear_moveToTrash(&mut self) {
        self.moveToTrash = ::std::option::Option::None;
    }

    pub fn has_moveToTrash(&self) -> bool {
        self.moveToTrash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moveToTrash(&mut self, v: bool) {
        self.moveToTrash = ::std::option::Option::Some(v);
    }

    pub fn get_moveToTrash(&self) -> bool {
        self.moveToTrash.unwrap_or(false)
    }

    fn get_moveToTrash_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.moveToTrash
    }

    fn mut_moveToTrash_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.moveToTrash
    }
}

impl ::protobuf::Message for Rename2RequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        if self.overwriteDest.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwriteDest = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.moveToTrash = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.overwriteDest {
            my_size += 2;
        }
        if let Some(v) = self.moveToTrash {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.overwriteDest {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.moveToTrash {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Rename2RequestProto {
    fn new() -> Rename2RequestProto {
        Rename2RequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<Rename2RequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    Rename2RequestProto::get_src_for_reflect,
                    Rename2RequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst",
                    Rename2RequestProto::get_dst_for_reflect,
                    Rename2RequestProto::mut_dst_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "overwriteDest",
                    Rename2RequestProto::get_overwriteDest_for_reflect,
                    Rename2RequestProto::mut_overwriteDest_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "moveToTrash",
                    Rename2RequestProto::get_moveToTrash_for_reflect,
                    Rename2RequestProto::mut_moveToTrash_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rename2RequestProto>(
                    "Rename2RequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Rename2RequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.clear_overwriteDest();
        self.clear_moveToTrash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2RequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2ResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Rename2ResponseProto {}

impl Rename2ResponseProto {
    pub fn new() -> Rename2ResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Rename2ResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2ResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2ResponseProto,
        };
        unsafe {
            instance.get(Rename2ResponseProto::new)
        }
    }
}

impl ::protobuf::Message for Rename2ResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Rename2ResponseProto {
    fn new() -> Rename2ResponseProto {
        Rename2ResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<Rename2ResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Rename2ResponseProto>(
                    "Rename2ResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Rename2ResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2ResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    recursive: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteRequestProto {}

impl DeleteRequestProto {
    pub fn new() -> DeleteRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRequestProto,
        };
        unsafe {
            instance.get(DeleteRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required bool recursive = 2;

    pub fn clear_recursive(&mut self) {
        self.recursive = ::std::option::Option::None;
    }

    pub fn has_recursive(&self) -> bool {
        self.recursive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = ::std::option::Option::Some(v);
    }

    pub fn get_recursive(&self) -> bool {
        self.recursive.unwrap_or(false)
    }

    fn get_recursive_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.recursive
    }

    fn mut_recursive_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.recursive
    }
}

impl ::protobuf::Message for DeleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.recursive.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.recursive {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.recursive {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteRequestProto {
    fn new() -> DeleteRequestProto {
        DeleteRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    DeleteRequestProto::get_src_for_reflect,
                    DeleteRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "recursive",
                    DeleteRequestProto::get_recursive_for_reflect,
                    DeleteRequestProto::mut_recursive_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRequestProto>(
                    "DeleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_recursive();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteResponseProto {}

impl DeleteResponseProto {
    pub fn new() -> DeleteResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteResponseProto,
        };
        unsafe {
            instance.get(DeleteResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for DeleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteResponseProto {
    fn new() -> DeleteResponseProto {
        DeleteResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    DeleteResponseProto::get_result_for_reflect,
                    DeleteResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteResponseProto>(
                    "DeleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    unmasked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MkdirsRequestProto {}

impl MkdirsRequestProto {
    pub fn new() -> MkdirsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsRequestProto,
        };
        unsafe {
            instance.get(MkdirsRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;

    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::acl::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::acl::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    pub fn get_masked(&self) -> &super::acl::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| super::acl::FsPermissionProto::default_instance())
    }

    fn get_masked_for_reflect(&self) -> &::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &self.masked
    }

    fn mut_masked_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &mut self.masked
    }

    // required bool createParent = 3;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    fn get_createParent_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createParent
    }

    fn mut_createParent_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createParent
    }

    // optional .hadoop.hdfs.FsPermissionProto unmasked = 4;

    pub fn clear_unmasked(&mut self) {
        self.unmasked.clear();
    }

    pub fn has_unmasked(&self) -> bool {
        self.unmasked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unmasked(&mut self, v: super::acl::FsPermissionProto) {
        self.unmasked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unmasked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.unmasked.is_none() {
            self.unmasked.set_default();
        }
        self.unmasked.as_mut().unwrap()
    }

    // Take field
    pub fn take_unmasked(&mut self) -> super::acl::FsPermissionProto {
        self.unmasked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    pub fn get_unmasked(&self) -> &super::acl::FsPermissionProto {
        self.unmasked.as_ref().unwrap_or_else(|| super::acl::FsPermissionProto::default_instance())
    }

    fn get_unmasked_for_reflect(&self) -> &::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &self.unmasked
    }

    fn mut_unmasked_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &mut self.unmasked
    }
}

impl ::protobuf::Message for MkdirsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unmasked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unmasked)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        if let Some(ref v) = self.unmasked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.unmasked.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirsRequestProto {
    fn new() -> MkdirsRequestProto {
        MkdirsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    MkdirsRequestProto::get_src_for_reflect,
                    MkdirsRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                    "masked",
                    MkdirsRequestProto::get_masked_for_reflect,
                    MkdirsRequestProto::mut_masked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    MkdirsRequestProto::get_createParent_for_reflect,
                    MkdirsRequestProto::mut_createParent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                    "unmasked",
                    MkdirsRequestProto::get_unmasked_for_reflect,
                    MkdirsRequestProto::mut_unmasked_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsRequestProto>(
                    "MkdirsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirsRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_masked();
        self.clear_createParent();
        self.clear_unmasked();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MkdirsResponseProto {}

impl MkdirsResponseProto {
    pub fn new() -> MkdirsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsResponseProto,
        };
        unsafe {
            instance.get(MkdirsResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for MkdirsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirsResponseProto {
    fn new() -> MkdirsResponseProto {
        MkdirsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    MkdirsResponseProto::get_result_for_reflect,
                    MkdirsResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsResponseProto>(
                    "MkdirsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirsResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    needLocation: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetListingRequestProto {}

impl GetListingRequestProto {
    pub fn new() -> GetListingRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingRequestProto,
        };
        unsafe {
            instance.get(GetListingRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required bytes startAfter = 2;

    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_startAfter_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.startAfter
    }

    fn mut_startAfter_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.startAfter
    }

    // required bool needLocation = 3;

    pub fn clear_needLocation(&mut self) {
        self.needLocation = ::std::option::Option::None;
    }

    pub fn has_needLocation(&self) -> bool {
        self.needLocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needLocation(&mut self, v: bool) {
        self.needLocation = ::std::option::Option::Some(v);
    }

    pub fn get_needLocation(&self) -> bool {
        self.needLocation.unwrap_or(false)
    }

    fn get_needLocation_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.needLocation
    }

    fn mut_needLocation_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.needLocation
    }
}

impl ::protobuf::Message for GetListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.startAfter.is_none() {
            return false;
        }
        if self.needLocation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.needLocation {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.needLocation {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetListingRequestProto {
    fn new() -> GetListingRequestProto {
        GetListingRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetListingRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetListingRequestProto::get_src_for_reflect,
                    GetListingRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "startAfter",
                    GetListingRequestProto::get_startAfter_for_reflect,
                    GetListingRequestProto::mut_startAfter_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needLocation",
                    GetListingRequestProto::get_needLocation_for_reflect,
                    GetListingRequestProto::mut_needLocation_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingRequestProto>(
                    "GetListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetListingRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_startAfter();
        self.clear_needLocation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingResponseProto {
    // message fields
    dirList: ::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetListingResponseProto {}

impl GetListingResponseProto {
    pub fn new() -> GetListingResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingResponseProto,
        };
        unsafe {
            instance.get(GetListingResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.DirectoryListingProto dirList = 1;

    pub fn clear_dirList(&mut self) {
        self.dirList.clear();
    }

    pub fn has_dirList(&self) -> bool {
        self.dirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirList(&mut self, v: super::hdfs::DirectoryListingProto) {
        self.dirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirList(&mut self) -> &mut super::hdfs::DirectoryListingProto {
        if self.dirList.is_none() {
            self.dirList.set_default();
        }
        self.dirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirList(&mut self) -> super::hdfs::DirectoryListingProto {
        self.dirList.take().unwrap_or_else(|| super::hdfs::DirectoryListingProto::new())
    }

    pub fn get_dirList(&self) -> &super::hdfs::DirectoryListingProto {
        self.dirList.as_ref().unwrap_or_else(|| super::hdfs::DirectoryListingProto::default_instance())
    }

    fn get_dirList_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto> {
        &self.dirList
    }

    fn mut_dirList_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto> {
        &mut self.dirList
    }
}

impl ::protobuf::Message for GetListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetListingResponseProto {
    fn new() -> GetListingResponseProto {
        GetListingResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetListingResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DirectoryListingProto>>(
                    "dirList",
                    GetListingResponseProto::get_dirList_for_reflect,
                    GetListingResponseProto::mut_dirList_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingResponseProto>(
                    "GetListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetListingResponseProto {
    fn clear(&mut self) {
        self.clear_dirList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshottableDirListingRequestProto {}

impl GetSnapshottableDirListingRequestProto {
    pub fn new() -> GetSnapshottableDirListingRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshottableDirListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingRequestProto,
        };
        unsafe {
            instance.get(GetSnapshottableDirListingRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshottableDirListingRequestProto {
    fn new() -> GetSnapshottableDirListingRequestProto {
        GetSnapshottableDirListingRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshottableDirListingRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingRequestProto>(
                    "GetSnapshottableDirListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingResponseProto {
    // message fields
    snapshottableDirList: ::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshottableDirListingResponseProto {}

impl GetSnapshottableDirListingResponseProto {
    pub fn new() -> GetSnapshottableDirListingResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshottableDirListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingResponseProto,
        };
        unsafe {
            instance.get(GetSnapshottableDirListingResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.SnapshottableDirectoryListingProto snapshottableDirList = 1;

    pub fn clear_snapshottableDirList(&mut self) {
        self.snapshottableDirList.clear();
    }

    pub fn has_snapshottableDirList(&self) -> bool {
        self.snapshottableDirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirList(&mut self, v: super::hdfs::SnapshottableDirectoryListingProto) {
        self.snapshottableDirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshottableDirList(&mut self) -> &mut super::hdfs::SnapshottableDirectoryListingProto {
        if self.snapshottableDirList.is_none() {
            self.snapshottableDirList.set_default();
        }
        self.snapshottableDirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshottableDirList(&mut self) -> super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.take().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::new())
    }

    pub fn get_snapshottableDirList(&self) -> &super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.as_ref().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::default_instance())
    }

    fn get_snapshottableDirList_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto> {
        &self.snapshottableDirList
    }

    fn mut_snapshottableDirList_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto> {
        &mut self.snapshottableDirList
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshottableDirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshottableDirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshottableDirListingResponseProto {
    fn new() -> GetSnapshottableDirListingResponseProto {
        GetSnapshottableDirListingResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshottableDirListingResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshottableDirectoryListingProto>>(
                    "snapshottableDirList",
                    GetSnapshottableDirListingResponseProto::get_snapshottableDirList_for_reflect,
                    GetSnapshottableDirListingResponseProto::mut_snapshottableDirList_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingResponseProto>(
                    "GetSnapshottableDirListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingResponseProto {
    fn clear(&mut self) {
        self.clear_snapshottableDirList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshotDiffReportRequestProto {}

impl GetSnapshotDiffReportRequestProto {
    pub fn new() -> GetSnapshotDiffReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshotDiffReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportRequestProto,
        };
        unsafe {
            instance.get(GetSnapshotDiffReportRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // required string fromSnapshot = 2;

    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fromSnapshot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fromSnapshot
    }

    fn mut_fromSnapshot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fromSnapshot
    }

    // required string toSnapshot = 3;

    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_toSnapshot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.toSnapshot
    }

    fn mut_toSnapshot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.toSnapshot
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshotDiffReportRequestProto {
    fn new() -> GetSnapshotDiffReportRequestProto {
        GetSnapshotDiffReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshotDiffReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    GetSnapshotDiffReportRequestProto::get_snapshotRoot_for_reflect,
                    GetSnapshotDiffReportRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fromSnapshot",
                    GetSnapshotDiffReportRequestProto::get_fromSnapshot_for_reflect,
                    GetSnapshotDiffReportRequestProto::mut_fromSnapshot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "toSnapshot",
                    GetSnapshotDiffReportRequestProto::get_toSnapshot_for_reflect,
                    GetSnapshotDiffReportRequestProto::mut_toSnapshot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportRequestProto>(
                    "GetSnapshotDiffReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_fromSnapshot();
        self.clear_toSnapshot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportResponseProto {
    // message fields
    diffReport: ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapshotDiffReportResponseProto {}

impl GetSnapshotDiffReportResponseProto {
    pub fn new() -> GetSnapshotDiffReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapshotDiffReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportResponseProto,
        };
        unsafe {
            instance.get(GetSnapshotDiffReportResponseProto::new)
        }
    }

    // required .hadoop.hdfs.SnapshotDiffReportProto diffReport = 1;

    pub fn clear_diffReport(&mut self) {
        self.diffReport.clear();
    }

    pub fn has_diffReport(&self) -> bool {
        self.diffReport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diffReport(&mut self, v: super::hdfs::SnapshotDiffReportProto) {
        self.diffReport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diffReport(&mut self) -> &mut super::hdfs::SnapshotDiffReportProto {
        if self.diffReport.is_none() {
            self.diffReport.set_default();
        }
        self.diffReport.as_mut().unwrap()
    }

    // Take field
    pub fn take_diffReport(&mut self) -> super::hdfs::SnapshotDiffReportProto {
        self.diffReport.take().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::new())
    }

    pub fn get_diffReport(&self) -> &super::hdfs::SnapshotDiffReportProto {
        self.diffReport.as_ref().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::default_instance())
    }

    fn get_diffReport_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto> {
        &self.diffReport
    }

    fn mut_diffReport_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto> {
        &mut self.diffReport
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportResponseProto {
    fn is_initialized(&self) -> bool {
        if self.diffReport.is_none() {
            return false;
        }
        for v in &self.diffReport {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diffReport)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diffReport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diffReport.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapshotDiffReportResponseProto {
    fn new() -> GetSnapshotDiffReportResponseProto {
        GetSnapshotDiffReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapshotDiffReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotDiffReportProto>>(
                    "diffReport",
                    GetSnapshotDiffReportResponseProto::get_diffReport_for_reflect,
                    GetSnapshotDiffReportResponseProto::mut_diffReport_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportResponseProto>(
                    "GetSnapshotDiffReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportResponseProto {
    fn clear(&mut self) {
        self.clear_diffReport();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenewLeaseRequestProto {}

impl RenewLeaseRequestProto {
    pub fn new() -> RenewLeaseRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenewLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseRequestProto,
        };
        unsafe {
            instance.get(RenewLeaseRequestProto::new)
        }
    }

    // required string clientName = 1;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for RenewLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenewLeaseRequestProto {
    fn new() -> RenewLeaseRequestProto {
        RenewLeaseRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenewLeaseRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    RenewLeaseRequestProto::get_clientName_for_reflect,
                    RenewLeaseRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseRequestProto>(
                    "RenewLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenewLeaseRequestProto {
    fn clear(&mut self) {
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenewLeaseResponseProto {}

impl RenewLeaseResponseProto {
    pub fn new() -> RenewLeaseResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenewLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseResponseProto,
        };
        unsafe {
            instance.get(RenewLeaseResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RenewLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenewLeaseResponseProto {
    fn new() -> RenewLeaseResponseProto {
        RenewLeaseResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenewLeaseResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseResponseProto>(
                    "RenewLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenewLeaseResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RecoverLeaseRequestProto {}

impl RecoverLeaseRequestProto {
    pub fn new() -> RecoverLeaseRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RecoverLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseRequestProto,
        };
        unsafe {
            instance.get(RecoverLeaseRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for RecoverLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RecoverLeaseRequestProto {
    fn new() -> RecoverLeaseRequestProto {
        RecoverLeaseRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RecoverLeaseRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    RecoverLeaseRequestProto::get_src_for_reflect,
                    RecoverLeaseRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    RecoverLeaseRequestProto::get_clientName_for_reflect,
                    RecoverLeaseRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseRequestProto>(
                    "RecoverLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RecoverLeaseResponseProto {}

impl RecoverLeaseResponseProto {
    pub fn new() -> RecoverLeaseResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RecoverLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseResponseProto,
        };
        unsafe {
            instance.get(RecoverLeaseResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for RecoverLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RecoverLeaseResponseProto {
    fn new() -> RecoverLeaseResponseProto {
        RecoverLeaseResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RecoverLeaseResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    RecoverLeaseResponseProto::get_result_for_reflect,
                    RecoverLeaseResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseResponseProto>(
                    "RecoverLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatusRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsStatusRequestProto {}

impl GetFsStatusRequestProto {
    pub fn new() -> GetFsStatusRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsStatusRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatusRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatusRequestProto,
        };
        unsafe {
            instance.get(GetFsStatusRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetFsStatusRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsStatusRequestProto {
    fn new() -> GetFsStatusRequestProto {
        GetFsStatusRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsStatusRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatusRequestProto>(
                    "GetFsStatusRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsStatusRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatusRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatsResponseProto {
    // message fields
    capacity: ::std::option::Option<u64>,
    used: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    under_replicated: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    missing_repl_one_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    pending_deletion_blocks: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsStatsResponseProto {}

impl GetFsStatsResponseProto {
    pub fn new() -> GetFsStatsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsStatsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatsResponseProto,
        };
        unsafe {
            instance.get(GetFsStatsResponseProto::new)
        }
    }

    // required uint64 capacity = 1;

    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }

    fn get_capacity_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.capacity
    }

    // required uint64 used = 2;

    pub fn clear_used(&mut self) {
        self.used = ::std::option::Option::None;
    }

    pub fn has_used(&self) -> bool {
        self.used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = ::std::option::Option::Some(v);
    }

    pub fn get_used(&self) -> u64 {
        self.used.unwrap_or(0)
    }

    fn get_used_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.used
    }

    fn mut_used_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.used
    }

    // required uint64 remaining = 3;

    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0)
    }

    fn get_remaining_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.remaining
    }

    fn mut_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.remaining
    }

    // required uint64 under_replicated = 4;

    pub fn clear_under_replicated(&mut self) {
        self.under_replicated = ::std::option::Option::None;
    }

    pub fn has_under_replicated(&self) -> bool {
        self.under_replicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_under_replicated(&mut self, v: u64) {
        self.under_replicated = ::std::option::Option::Some(v);
    }

    pub fn get_under_replicated(&self) -> u64 {
        self.under_replicated.unwrap_or(0)
    }

    fn get_under_replicated_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.under_replicated
    }

    fn mut_under_replicated_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.under_replicated
    }

    // required uint64 corrupt_blocks = 5;

    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }

    fn get_corrupt_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.corrupt_blocks
    }

    fn mut_corrupt_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.corrupt_blocks
    }

    // required uint64 missing_blocks = 6;

    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }

    fn get_missing_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.missing_blocks
    }

    fn mut_missing_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.missing_blocks
    }

    // optional uint64 missing_repl_one_blocks = 7;

    pub fn clear_missing_repl_one_blocks(&mut self) {
        self.missing_repl_one_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_repl_one_blocks(&self) -> bool {
        self.missing_repl_one_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_repl_one_blocks(&mut self, v: u64) {
        self.missing_repl_one_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_repl_one_blocks(&self) -> u64 {
        self.missing_repl_one_blocks.unwrap_or(0)
    }

    fn get_missing_repl_one_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.missing_repl_one_blocks
    }

    fn mut_missing_repl_one_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.missing_repl_one_blocks
    }

    // optional uint64 blocks_in_future = 8;

    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }

    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }

    fn get_blocks_in_future_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.blocks_in_future
    }

    fn mut_blocks_in_future_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.blocks_in_future
    }

    // optional uint64 pending_deletion_blocks = 9;

    pub fn clear_pending_deletion_blocks(&mut self) {
        self.pending_deletion_blocks = ::std::option::Option::None;
    }

    pub fn has_pending_deletion_blocks(&self) -> bool {
        self.pending_deletion_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_deletion_blocks(&mut self, v: u64) {
        self.pending_deletion_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_pending_deletion_blocks(&self) -> u64 {
        self.pending_deletion_blocks.unwrap_or(0)
    }

    fn get_pending_deletion_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.pending_deletion_blocks
    }

    fn mut_pending_deletion_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.pending_deletion_blocks
    }
}

impl ::protobuf::Message for GetFsStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.capacity.is_none() {
            return false;
        }
        if self.used.is_none() {
            return false;
        }
        if self.remaining.is_none() {
            return false;
        }
        if self.under_replicated.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.under_replicated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_repl_one_blocks = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pending_deletion_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.under_replicated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_repl_one_blocks {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_deletion_blocks {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.capacity {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.used {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.under_replicated {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.missing_repl_one_blocks {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.pending_deletion_blocks {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsStatsResponseProto {
    fn new() -> GetFsStatsResponseProto {
        GetFsStatsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsStatsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capacity",
                    GetFsStatsResponseProto::get_capacity_for_reflect,
                    GetFsStatsResponseProto::mut_capacity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "used",
                    GetFsStatsResponseProto::get_used_for_reflect,
                    GetFsStatsResponseProto::mut_used_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "remaining",
                    GetFsStatsResponseProto::get_remaining_for_reflect,
                    GetFsStatsResponseProto::mut_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "under_replicated",
                    GetFsStatsResponseProto::get_under_replicated_for_reflect,
                    GetFsStatsResponseProto::mut_under_replicated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "corrupt_blocks",
                    GetFsStatsResponseProto::get_corrupt_blocks_for_reflect,
                    GetFsStatsResponseProto::mut_corrupt_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_blocks",
                    GetFsStatsResponseProto::get_missing_blocks_for_reflect,
                    GetFsStatsResponseProto::mut_missing_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_repl_one_blocks",
                    GetFsStatsResponseProto::get_missing_repl_one_blocks_for_reflect,
                    GetFsStatsResponseProto::mut_missing_repl_one_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocks_in_future",
                    GetFsStatsResponseProto::get_blocks_in_future_for_reflect,
                    GetFsStatsResponseProto::mut_blocks_in_future_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "pending_deletion_blocks",
                    GetFsStatsResponseProto::get_pending_deletion_blocks_for_reflect,
                    GetFsStatsResponseProto::mut_pending_deletion_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatsResponseProto>(
                    "GetFsStatsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsStatsResponseProto {
    fn clear(&mut self) {
        self.clear_capacity();
        self.clear_used();
        self.clear_remaining();
        self.clear_under_replicated();
        self.clear_corrupt_blocks();
        self.clear_missing_blocks();
        self.clear_missing_repl_one_blocks();
        self.clear_blocks_in_future();
        self.clear_pending_deletion_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsReplicatedBlockStatsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsReplicatedBlockStatsRequestProto {}

impl GetFsReplicatedBlockStatsRequestProto {
    pub fn new() -> GetFsReplicatedBlockStatsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsReplicatedBlockStatsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsReplicatedBlockStatsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsReplicatedBlockStatsRequestProto,
        };
        unsafe {
            instance.get(GetFsReplicatedBlockStatsRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetFsReplicatedBlockStatsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsReplicatedBlockStatsRequestProto {
    fn new() -> GetFsReplicatedBlockStatsRequestProto {
        GetFsReplicatedBlockStatsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsReplicatedBlockStatsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFsReplicatedBlockStatsRequestProto>(
                    "GetFsReplicatedBlockStatsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsReplicatedBlockStatsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsReplicatedBlockStatsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsReplicatedBlockStatsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsReplicatedBlockStatsResponseProto {
    // message fields
    low_redundancy: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    missing_repl_one_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    pending_deletion_blocks: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsReplicatedBlockStatsResponseProto {}

impl GetFsReplicatedBlockStatsResponseProto {
    pub fn new() -> GetFsReplicatedBlockStatsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsReplicatedBlockStatsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsReplicatedBlockStatsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsReplicatedBlockStatsResponseProto,
        };
        unsafe {
            instance.get(GetFsReplicatedBlockStatsResponseProto::new)
        }
    }

    // required uint64 low_redundancy = 1;

    pub fn clear_low_redundancy(&mut self) {
        self.low_redundancy = ::std::option::Option::None;
    }

    pub fn has_low_redundancy(&self) -> bool {
        self.low_redundancy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_redundancy(&mut self, v: u64) {
        self.low_redundancy = ::std::option::Option::Some(v);
    }

    pub fn get_low_redundancy(&self) -> u64 {
        self.low_redundancy.unwrap_or(0)
    }

    fn get_low_redundancy_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.low_redundancy
    }

    fn mut_low_redundancy_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.low_redundancy
    }

    // required uint64 corrupt_blocks = 2;

    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }

    fn get_corrupt_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.corrupt_blocks
    }

    fn mut_corrupt_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.corrupt_blocks
    }

    // required uint64 missing_blocks = 3;

    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }

    fn get_missing_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.missing_blocks
    }

    fn mut_missing_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.missing_blocks
    }

    // required uint64 missing_repl_one_blocks = 4;

    pub fn clear_missing_repl_one_blocks(&mut self) {
        self.missing_repl_one_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_repl_one_blocks(&self) -> bool {
        self.missing_repl_one_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_repl_one_blocks(&mut self, v: u64) {
        self.missing_repl_one_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_repl_one_blocks(&self) -> u64 {
        self.missing_repl_one_blocks.unwrap_or(0)
    }

    fn get_missing_repl_one_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.missing_repl_one_blocks
    }

    fn mut_missing_repl_one_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.missing_repl_one_blocks
    }

    // required uint64 blocks_in_future = 5;

    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }

    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }

    fn get_blocks_in_future_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.blocks_in_future
    }

    fn mut_blocks_in_future_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.blocks_in_future
    }

    // required uint64 pending_deletion_blocks = 6;

    pub fn clear_pending_deletion_blocks(&mut self) {
        self.pending_deletion_blocks = ::std::option::Option::None;
    }

    pub fn has_pending_deletion_blocks(&self) -> bool {
        self.pending_deletion_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_deletion_blocks(&mut self, v: u64) {
        self.pending_deletion_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_pending_deletion_blocks(&self) -> u64 {
        self.pending_deletion_blocks.unwrap_or(0)
    }

    fn get_pending_deletion_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.pending_deletion_blocks
    }

    fn mut_pending_deletion_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.pending_deletion_blocks
    }
}

impl ::protobuf::Message for GetFsReplicatedBlockStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.low_redundancy.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        if self.missing_repl_one_blocks.is_none() {
            return false;
        }
        if self.blocks_in_future.is_none() {
            return false;
        }
        if self.pending_deletion_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.low_redundancy = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_repl_one_blocks = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pending_deletion_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.low_redundancy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_repl_one_blocks {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_deletion_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.low_redundancy {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.missing_repl_one_blocks {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.pending_deletion_blocks {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsReplicatedBlockStatsResponseProto {
    fn new() -> GetFsReplicatedBlockStatsResponseProto {
        GetFsReplicatedBlockStatsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsReplicatedBlockStatsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "low_redundancy",
                    GetFsReplicatedBlockStatsResponseProto::get_low_redundancy_for_reflect,
                    GetFsReplicatedBlockStatsResponseProto::mut_low_redundancy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "corrupt_blocks",
                    GetFsReplicatedBlockStatsResponseProto::get_corrupt_blocks_for_reflect,
                    GetFsReplicatedBlockStatsResponseProto::mut_corrupt_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_blocks",
                    GetFsReplicatedBlockStatsResponseProto::get_missing_blocks_for_reflect,
                    GetFsReplicatedBlockStatsResponseProto::mut_missing_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_repl_one_blocks",
                    GetFsReplicatedBlockStatsResponseProto::get_missing_repl_one_blocks_for_reflect,
                    GetFsReplicatedBlockStatsResponseProto::mut_missing_repl_one_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocks_in_future",
                    GetFsReplicatedBlockStatsResponseProto::get_blocks_in_future_for_reflect,
                    GetFsReplicatedBlockStatsResponseProto::mut_blocks_in_future_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "pending_deletion_blocks",
                    GetFsReplicatedBlockStatsResponseProto::get_pending_deletion_blocks_for_reflect,
                    GetFsReplicatedBlockStatsResponseProto::mut_pending_deletion_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFsReplicatedBlockStatsResponseProto>(
                    "GetFsReplicatedBlockStatsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsReplicatedBlockStatsResponseProto {
    fn clear(&mut self) {
        self.clear_low_redundancy();
        self.clear_corrupt_blocks();
        self.clear_missing_blocks();
        self.clear_missing_repl_one_blocks();
        self.clear_blocks_in_future();
        self.clear_pending_deletion_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsReplicatedBlockStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsReplicatedBlockStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsECBlockGroupStatsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsECBlockGroupStatsRequestProto {}

impl GetFsECBlockGroupStatsRequestProto {
    pub fn new() -> GetFsECBlockGroupStatsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsECBlockGroupStatsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsECBlockGroupStatsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsECBlockGroupStatsRequestProto,
        };
        unsafe {
            instance.get(GetFsECBlockGroupStatsRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetFsECBlockGroupStatsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsECBlockGroupStatsRequestProto {
    fn new() -> GetFsECBlockGroupStatsRequestProto {
        GetFsECBlockGroupStatsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsECBlockGroupStatsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFsECBlockGroupStatsRequestProto>(
                    "GetFsECBlockGroupStatsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsECBlockGroupStatsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsECBlockGroupStatsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsECBlockGroupStatsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsECBlockGroupStatsResponseProto {
    // message fields
    low_redundancy: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    pending_deletion_blocks: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFsECBlockGroupStatsResponseProto {}

impl GetFsECBlockGroupStatsResponseProto {
    pub fn new() -> GetFsECBlockGroupStatsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFsECBlockGroupStatsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsECBlockGroupStatsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsECBlockGroupStatsResponseProto,
        };
        unsafe {
            instance.get(GetFsECBlockGroupStatsResponseProto::new)
        }
    }

    // required uint64 low_redundancy = 1;

    pub fn clear_low_redundancy(&mut self) {
        self.low_redundancy = ::std::option::Option::None;
    }

    pub fn has_low_redundancy(&self) -> bool {
        self.low_redundancy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_redundancy(&mut self, v: u64) {
        self.low_redundancy = ::std::option::Option::Some(v);
    }

    pub fn get_low_redundancy(&self) -> u64 {
        self.low_redundancy.unwrap_or(0)
    }

    fn get_low_redundancy_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.low_redundancy
    }

    fn mut_low_redundancy_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.low_redundancy
    }

    // required uint64 corrupt_blocks = 2;

    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }

    fn get_corrupt_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.corrupt_blocks
    }

    fn mut_corrupt_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.corrupt_blocks
    }

    // required uint64 missing_blocks = 3;

    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }

    fn get_missing_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.missing_blocks
    }

    fn mut_missing_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.missing_blocks
    }

    // required uint64 blocks_in_future = 4;

    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }

    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }

    fn get_blocks_in_future_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.blocks_in_future
    }

    fn mut_blocks_in_future_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.blocks_in_future
    }

    // required uint64 pending_deletion_blocks = 5;

    pub fn clear_pending_deletion_blocks(&mut self) {
        self.pending_deletion_blocks = ::std::option::Option::None;
    }

    pub fn has_pending_deletion_blocks(&self) -> bool {
        self.pending_deletion_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_deletion_blocks(&mut self, v: u64) {
        self.pending_deletion_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_pending_deletion_blocks(&self) -> u64 {
        self.pending_deletion_blocks.unwrap_or(0)
    }

    fn get_pending_deletion_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.pending_deletion_blocks
    }

    fn mut_pending_deletion_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.pending_deletion_blocks
    }
}

impl ::protobuf::Message for GetFsECBlockGroupStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.low_redundancy.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        if self.blocks_in_future.is_none() {
            return false;
        }
        if self.pending_deletion_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.low_redundancy = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pending_deletion_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.low_redundancy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_deletion_blocks {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.low_redundancy {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.pending_deletion_blocks {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFsECBlockGroupStatsResponseProto {
    fn new() -> GetFsECBlockGroupStatsResponseProto {
        GetFsECBlockGroupStatsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFsECBlockGroupStatsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "low_redundancy",
                    GetFsECBlockGroupStatsResponseProto::get_low_redundancy_for_reflect,
                    GetFsECBlockGroupStatsResponseProto::mut_low_redundancy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "corrupt_blocks",
                    GetFsECBlockGroupStatsResponseProto::get_corrupt_blocks_for_reflect,
                    GetFsECBlockGroupStatsResponseProto::mut_corrupt_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_blocks",
                    GetFsECBlockGroupStatsResponseProto::get_missing_blocks_for_reflect,
                    GetFsECBlockGroupStatsResponseProto::mut_missing_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocks_in_future",
                    GetFsECBlockGroupStatsResponseProto::get_blocks_in_future_for_reflect,
                    GetFsECBlockGroupStatsResponseProto::mut_blocks_in_future_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "pending_deletion_blocks",
                    GetFsECBlockGroupStatsResponseProto::get_pending_deletion_blocks_for_reflect,
                    GetFsECBlockGroupStatsResponseProto::mut_pending_deletion_blocks_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFsECBlockGroupStatsResponseProto>(
                    "GetFsECBlockGroupStatsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFsECBlockGroupStatsResponseProto {
    fn clear(&mut self) {
        self.clear_low_redundancy();
        self.clear_corrupt_blocks();
        self.clear_missing_blocks();
        self.clear_blocks_in_future();
        self.clear_pending_deletion_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsECBlockGroupStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsECBlockGroupStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeReportRequestProto {}

impl GetDatanodeReportRequestProto {
    pub fn new() -> GetDatanodeReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportRequestProto,
        };
        unsafe {
            instance.get(GetDatanodeReportRequestProto::new)
        }
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DatanodeReportTypeProto> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DatanodeReportTypeProto> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for GetDatanodeReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeReportRequestProto {
    fn new() -> GetDatanodeReportRequestProto {
        GetDatanodeReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                    "type",
                    GetDatanodeReportRequestProto::get_field_type_for_reflect,
                    GetDatanodeReportRequestProto::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportRequestProto>(
                    "GetDatanodeReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportRequestProto {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportResponseProto {
    // message fields
    di: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeReportResponseProto {}

impl GetDatanodeReportResponseProto {
    pub fn new() -> GetDatanodeReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportResponseProto,
        };
        unsafe {
            instance.get(GetDatanodeReportResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto di = 1;

    pub fn clear_di(&mut self) {
        self.di.clear();
    }

    // Param is passed by value, moved
    pub fn set_di(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.di = v;
    }

    // Mutable pointer to the field.
    pub fn mut_di(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.di
    }

    // Take field
    pub fn take_di(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.di, ::protobuf::RepeatedField::new())
    }

    pub fn get_di(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.di
    }

    fn get_di_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &self.di
    }

    fn mut_di_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.di
    }
}

impl ::protobuf::Message for GetDatanodeReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.di {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.di)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.di {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.di {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeReportResponseProto {
    fn new() -> GetDatanodeReportResponseProto {
        GetDatanodeReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "di",
                    GetDatanodeReportResponseProto::get_di_for_reflect,
                    GetDatanodeReportResponseProto::mut_di_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportResponseProto>(
                    "GetDatanodeReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportResponseProto {
    fn clear(&mut self) {
        self.clear_di();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeStorageReportRequestProto {}

impl GetDatanodeStorageReportRequestProto {
    pub fn new() -> GetDatanodeStorageReportRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeStorageReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportRequestProto,
        };
        unsafe {
            instance.get(GetDatanodeStorageReportRequestProto::new)
        }
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DatanodeReportTypeProto> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DatanodeReportTypeProto> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeStorageReportRequestProto {
    fn new() -> GetDatanodeStorageReportRequestProto {
        GetDatanodeStorageReportRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeStorageReportRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                    "type",
                    GetDatanodeStorageReportRequestProto::get_field_type_for_reflect,
                    GetDatanodeStorageReportRequestProto::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportRequestProto>(
                    "GetDatanodeStorageReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportRequestProto {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeStorageReportProto {
    // message fields
    datanodeInfo: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    storageReports: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DatanodeStorageReportProto {}

impl DatanodeStorageReportProto {
    pub fn new() -> DatanodeStorageReportProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DatanodeStorageReportProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeStorageReportProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeStorageReportProto,
        };
        unsafe {
            instance.get(DatanodeStorageReportProto::new)
        }
    }

    // required .hadoop.hdfs.DatanodeInfoProto datanodeInfo = 1;

    pub fn clear_datanodeInfo(&mut self) {
        self.datanodeInfo.clear();
    }

    pub fn has_datanodeInfo(&self) -> bool {
        self.datanodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeInfo(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.datanodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeInfo(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.datanodeInfo.is_none() {
            self.datanodeInfo.set_default();
        }
        self.datanodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeInfo(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    pub fn get_datanodeInfo(&self) -> &super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.as_ref().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::default_instance())
    }

    fn get_datanodeInfo_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto> {
        &self.datanodeInfo
    }

    fn mut_datanodeInfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto> {
        &mut self.datanodeInfo
    }

    // repeated .hadoop.hdfs.StorageReportProto storageReports = 2;

    pub fn clear_storageReports(&mut self) {
        self.storageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageReports(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>) {
        self.storageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageReports(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.storageReports
    }

    // Take field
    pub fn take_storageReports(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        ::std::mem::replace(&mut self.storageReports, ::protobuf::RepeatedField::new())
    }

    pub fn get_storageReports(&self) -> &[super::hdfs::StorageReportProto] {
        &self.storageReports
    }

    fn get_storageReports_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &self.storageReports
    }

    fn mut_storageReports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.storageReports
    }
}

impl ::protobuf::Message for DatanodeStorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.datanodeInfo.is_none() {
            return false;
        }
        for v in &self.datanodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanodeInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.storageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.storageReports {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DatanodeStorageReportProto {
    fn new() -> DatanodeStorageReportProto {
        DatanodeStorageReportProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DatanodeStorageReportProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "datanodeInfo",
                    DatanodeStorageReportProto::get_datanodeInfo_for_reflect,
                    DatanodeStorageReportProto::mut_datanodeInfo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageReportProto>>(
                    "storageReports",
                    DatanodeStorageReportProto::get_storageReports_for_reflect,
                    DatanodeStorageReportProto::mut_storageReports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeStorageReportProto>(
                    "DatanodeStorageReportProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DatanodeStorageReportProto {
    fn clear(&mut self) {
        self.clear_datanodeInfo();
        self.clear_storageReports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeStorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportResponseProto {
    // message fields
    datanodeStorageReports: ::protobuf::RepeatedField<DatanodeStorageReportProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDatanodeStorageReportResponseProto {}

impl GetDatanodeStorageReportResponseProto {
    pub fn new() -> GetDatanodeStorageReportResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDatanodeStorageReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportResponseProto,
        };
        unsafe {
            instance.get(GetDatanodeStorageReportResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.DatanodeStorageReportProto datanodeStorageReports = 1;

    pub fn clear_datanodeStorageReports(&mut self) {
        self.datanodeStorageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodeStorageReports(&mut self, v: ::protobuf::RepeatedField<DatanodeStorageReportProto>) {
        self.datanodeStorageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodeStorageReports(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }

    // Take field
    pub fn take_datanodeStorageReports(&mut self) -> ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        ::std::mem::replace(&mut self.datanodeStorageReports, ::protobuf::RepeatedField::new())
    }

    pub fn get_datanodeStorageReports(&self) -> &[DatanodeStorageReportProto] {
        &self.datanodeStorageReports
    }

    fn get_datanodeStorageReports_for_reflect(&self) -> &::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &self.datanodeStorageReports
    }

    fn mut_datanodeStorageReports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.datanodeStorageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodeStorageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datanodeStorageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datanodeStorageReports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDatanodeStorageReportResponseProto {
    fn new() -> GetDatanodeStorageReportResponseProto {
        GetDatanodeStorageReportResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDatanodeStorageReportResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeStorageReportProto>>(
                    "datanodeStorageReports",
                    GetDatanodeStorageReportResponseProto::get_datanodeStorageReports_for_reflect,
                    GetDatanodeStorageReportResponseProto::mut_datanodeStorageReports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportResponseProto>(
                    "GetDatanodeStorageReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportResponseProto {
    fn clear(&mut self) {
        self.clear_datanodeStorageReports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetPreferredBlockSizeRequestProto {}

impl GetPreferredBlockSizeRequestProto {
    pub fn new() -> GetPreferredBlockSizeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetPreferredBlockSizeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeRequestProto,
        };
        unsafe {
            instance.get(GetPreferredBlockSizeRequestProto::new)
        }
    }

    // required string filename = 1;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_filename_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.filename
    }

    fn mut_filename_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.filename
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetPreferredBlockSizeRequestProto {
    fn new() -> GetPreferredBlockSizeRequestProto {
        GetPreferredBlockSizeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetPreferredBlockSizeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    GetPreferredBlockSizeRequestProto::get_filename_for_reflect,
                    GetPreferredBlockSizeRequestProto::mut_filename_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeRequestProto>(
                    "GetPreferredBlockSizeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeRequestProto {
    fn clear(&mut self) {
        self.clear_filename();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeResponseProto {
    // message fields
    bsize: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetPreferredBlockSizeResponseProto {}

impl GetPreferredBlockSizeResponseProto {
    pub fn new() -> GetPreferredBlockSizeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetPreferredBlockSizeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeResponseProto,
        };
        unsafe {
            instance.get(GetPreferredBlockSizeResponseProto::new)
        }
    }

    // required uint64 bsize = 1;

    pub fn clear_bsize(&mut self) {
        self.bsize = ::std::option::Option::None;
    }

    pub fn has_bsize(&self) -> bool {
        self.bsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsize(&mut self, v: u64) {
        self.bsize = ::std::option::Option::Some(v);
    }

    pub fn get_bsize(&self) -> u64 {
        self.bsize.unwrap_or(0)
    }

    fn get_bsize_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bsize
    }

    fn mut_bsize_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bsize
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bsize.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bsize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bsize {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetPreferredBlockSizeResponseProto {
    fn new() -> GetPreferredBlockSizeResponseProto {
        GetPreferredBlockSizeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetPreferredBlockSizeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bsize",
                    GetPreferredBlockSizeResponseProto::get_bsize_for_reflect,
                    GetPreferredBlockSizeResponseProto::mut_bsize_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeResponseProto>(
                    "GetPreferredBlockSizeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeResponseProto {
    fn clear(&mut self) {
        self.clear_bsize();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeRequestProto {
    // message fields
    action: ::std::option::Option<SafeModeActionProto>,
    checked: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetSafeModeRequestProto {}

impl SetSafeModeRequestProto {
    pub fn new() -> SetSafeModeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetSafeModeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeRequestProto,
        };
        unsafe {
            instance.get(SetSafeModeRequestProto::new)
        }
    }

    // required .hadoop.hdfs.SafeModeActionProto action = 1;

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SafeModeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    pub fn get_action(&self) -> SafeModeActionProto {
        self.action.unwrap_or(SafeModeActionProto::SAFEMODE_LEAVE)
    }

    fn get_action_for_reflect(&self) -> &::std::option::Option<SafeModeActionProto> {
        &self.action
    }

    fn mut_action_for_reflect(&mut self) -> &mut ::std::option::Option<SafeModeActionProto> {
        &mut self.action
    }

    // optional bool checked = 2;

    pub fn clear_checked(&mut self) {
        self.checked = ::std::option::Option::None;
    }

    pub fn has_checked(&self) -> bool {
        self.checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked(&mut self, v: bool) {
        self.checked = ::std::option::Option::Some(v);
    }

    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }

    fn get_checked_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.checked
    }

    fn mut_checked_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.checked
    }
}

impl ::protobuf::Message for SetSafeModeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetSafeModeRequestProto {
    fn new() -> SetSafeModeRequestProto {
        SetSafeModeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetSafeModeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SafeModeActionProto>>(
                    "action",
                    SetSafeModeRequestProto::get_action_for_reflect,
                    SetSafeModeRequestProto::mut_action_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "checked",
                    SetSafeModeRequestProto::get_checked_for_reflect,
                    SetSafeModeRequestProto::mut_checked_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeRequestProto>(
                    "SetSafeModeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetSafeModeRequestProto {
    fn clear(&mut self) {
        self.clear_action();
        self.clear_checked();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetSafeModeResponseProto {}

impl SetSafeModeResponseProto {
    pub fn new() -> SetSafeModeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetSafeModeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeResponseProto,
        };
        unsafe {
            instance.get(SetSafeModeResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for SetSafeModeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetSafeModeResponseProto {
    fn new() -> SetSafeModeResponseProto {
        SetSafeModeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetSafeModeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    SetSafeModeResponseProto::get_result_for_reflect,
                    SetSafeModeResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeResponseProto>(
                    "SetSafeModeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetSafeModeResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceRequestProto {
    // message fields
    timeWindow: ::std::option::Option<u64>,
    txGap: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SaveNamespaceRequestProto {}

impl SaveNamespaceRequestProto {
    pub fn new() -> SaveNamespaceRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SaveNamespaceRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceRequestProto,
        };
        unsafe {
            instance.get(SaveNamespaceRequestProto::new)
        }
    }

    // optional uint64 timeWindow = 1;

    pub fn clear_timeWindow(&mut self) {
        self.timeWindow = ::std::option::Option::None;
    }

    pub fn has_timeWindow(&self) -> bool {
        self.timeWindow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeWindow(&mut self, v: u64) {
        self.timeWindow = ::std::option::Option::Some(v);
    }

    pub fn get_timeWindow(&self) -> u64 {
        self.timeWindow.unwrap_or(0u64)
    }

    fn get_timeWindow_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.timeWindow
    }

    fn mut_timeWindow_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.timeWindow
    }

    // optional uint64 txGap = 2;

    pub fn clear_txGap(&mut self) {
        self.txGap = ::std::option::Option::None;
    }

    pub fn has_txGap(&self) -> bool {
        self.txGap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txGap(&mut self, v: u64) {
        self.txGap = ::std::option::Option::Some(v);
    }

    pub fn get_txGap(&self) -> u64 {
        self.txGap.unwrap_or(0u64)
    }

    fn get_txGap_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.txGap
    }

    fn mut_txGap_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.txGap
    }
}

impl ::protobuf::Message for SaveNamespaceRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeWindow = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txGap = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeWindow {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txGap {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeWindow {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txGap {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SaveNamespaceRequestProto {
    fn new() -> SaveNamespaceRequestProto {
        SaveNamespaceRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SaveNamespaceRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timeWindow",
                    SaveNamespaceRequestProto::get_timeWindow_for_reflect,
                    SaveNamespaceRequestProto::mut_timeWindow_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "txGap",
                    SaveNamespaceRequestProto::get_txGap_for_reflect,
                    SaveNamespaceRequestProto::mut_txGap_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceRequestProto>(
                    "SaveNamespaceRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceRequestProto {
    fn clear(&mut self) {
        self.clear_timeWindow();
        self.clear_txGap();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceResponseProto {
    // message fields
    saved: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SaveNamespaceResponseProto {}

impl SaveNamespaceResponseProto {
    pub fn new() -> SaveNamespaceResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SaveNamespaceResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceResponseProto,
        };
        unsafe {
            instance.get(SaveNamespaceResponseProto::new)
        }
    }

    // optional bool saved = 1;

    pub fn clear_saved(&mut self) {
        self.saved = ::std::option::Option::None;
    }

    pub fn has_saved(&self) -> bool {
        self.saved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saved(&mut self, v: bool) {
        self.saved = ::std::option::Option::Some(v);
    }

    pub fn get_saved(&self) -> bool {
        self.saved.unwrap_or(true)
    }

    fn get_saved_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.saved
    }

    fn mut_saved_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.saved
    }
}

impl ::protobuf::Message for SaveNamespaceResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.saved = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.saved {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.saved {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SaveNamespaceResponseProto {
    fn new() -> SaveNamespaceResponseProto {
        SaveNamespaceResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SaveNamespaceResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "saved",
                    SaveNamespaceResponseProto::get_saved_for_reflect,
                    SaveNamespaceResponseProto::mut_saved_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceResponseProto>(
                    "SaveNamespaceResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceResponseProto {
    fn clear(&mut self) {
        self.clear_saved();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollEditsRequestProto {}

impl RollEditsRequestProto {
    pub fn new() -> RollEditsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollEditsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsRequestProto,
        };
        unsafe {
            instance.get(RollEditsRequestProto::new)
        }
    }
}

impl ::protobuf::Message for RollEditsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollEditsRequestProto {
    fn new() -> RollEditsRequestProto {
        RollEditsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollEditsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsRequestProto>(
                    "RollEditsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollEditsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsResponseProto {
    // message fields
    newSegmentTxId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollEditsResponseProto {}

impl RollEditsResponseProto {
    pub fn new() -> RollEditsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollEditsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsResponseProto,
        };
        unsafe {
            instance.get(RollEditsResponseProto::new)
        }
    }

    // required uint64 newSegmentTxId = 1;

    pub fn clear_newSegmentTxId(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_newSegmentTxId(&self) -> bool {
        self.newSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newSegmentTxId(&mut self, v: u64) {
        self.newSegmentTxId = ::std::option::Option::Some(v);
    }

    pub fn get_newSegmentTxId(&self) -> u64 {
        self.newSegmentTxId.unwrap_or(0)
    }

    fn get_newSegmentTxId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.newSegmentTxId
    }

    fn mut_newSegmentTxId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.newSegmentTxId
    }
}

impl ::protobuf::Message for RollEditsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.newSegmentTxId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newSegmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.newSegmentTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newSegmentTxId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollEditsResponseProto {
    fn new() -> RollEditsResponseProto {
        RollEditsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollEditsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newSegmentTxId",
                    RollEditsResponseProto::get_newSegmentTxId_for_reflect,
                    RollEditsResponseProto::mut_newSegmentTxId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsResponseProto>(
                    "RollEditsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollEditsResponseProto {
    fn clear(&mut self) {
        self.clear_newSegmentTxId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageRequestProto {
    // message fields
    arg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RestoreFailedStorageRequestProto {}

impl RestoreFailedStorageRequestProto {
    pub fn new() -> RestoreFailedStorageRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RestoreFailedStorageRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageRequestProto,
        };
        unsafe {
            instance.get(RestoreFailedStorageRequestProto::new)
        }
    }

    // required string arg = 1;

    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::std::string::String) {
        self.arg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::std::string::String {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::std::string::String {
        self.arg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_arg(&self) -> &str {
        match self.arg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_arg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.arg
    }

    fn mut_arg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.arg
    }
}

impl ::protobuf::Message for RestoreFailedStorageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.arg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.arg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.arg.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RestoreFailedStorageRequestProto {
    fn new() -> RestoreFailedStorageRequestProto {
        RestoreFailedStorageRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RestoreFailedStorageRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "arg",
                    RestoreFailedStorageRequestProto::get_arg_for_reflect,
                    RestoreFailedStorageRequestProto::mut_arg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageRequestProto>(
                    "RestoreFailedStorageRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageRequestProto {
    fn clear(&mut self) {
        self.clear_arg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RestoreFailedStorageResponseProto {}

impl RestoreFailedStorageResponseProto {
    pub fn new() -> RestoreFailedStorageResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RestoreFailedStorageResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageResponseProto,
        };
        unsafe {
            instance.get(RestoreFailedStorageResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for RestoreFailedStorageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RestoreFailedStorageResponseProto {
    fn new() -> RestoreFailedStorageResponseProto {
        RestoreFailedStorageResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RestoreFailedStorageResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    RestoreFailedStorageResponseProto::get_result_for_reflect,
                    RestoreFailedStorageResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageResponseProto>(
                    "RestoreFailedStorageResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RefreshNodesRequestProto {}

impl RefreshNodesRequestProto {
    pub fn new() -> RefreshNodesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RefreshNodesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesRequestProto,
        };
        unsafe {
            instance.get(RefreshNodesRequestProto::new)
        }
    }
}

impl ::protobuf::Message for RefreshNodesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RefreshNodesRequestProto {
    fn new() -> RefreshNodesRequestProto {
        RefreshNodesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RefreshNodesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesRequestProto>(
                    "RefreshNodesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RefreshNodesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RefreshNodesResponseProto {}

impl RefreshNodesResponseProto {
    pub fn new() -> RefreshNodesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RefreshNodesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesResponseProto,
        };
        unsafe {
            instance.get(RefreshNodesResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RefreshNodesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RefreshNodesResponseProto {
    fn new() -> RefreshNodesResponseProto {
        RefreshNodesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RefreshNodesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesResponseProto>(
                    "RefreshNodesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RefreshNodesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FinalizeUpgradeRequestProto {}

impl FinalizeUpgradeRequestProto {
    pub fn new() -> FinalizeUpgradeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FinalizeUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeRequestProto,
        };
        unsafe {
            instance.get(FinalizeUpgradeRequestProto::new)
        }
    }
}

impl ::protobuf::Message for FinalizeUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FinalizeUpgradeRequestProto {
    fn new() -> FinalizeUpgradeRequestProto {
        FinalizeUpgradeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FinalizeUpgradeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeRequestProto>(
                    "FinalizeUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FinalizeUpgradeResponseProto {}

impl FinalizeUpgradeResponseProto {
    pub fn new() -> FinalizeUpgradeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FinalizeUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeResponseProto,
        };
        unsafe {
            instance.get(FinalizeUpgradeResponseProto::new)
        }
    }
}

impl ::protobuf::Message for FinalizeUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FinalizeUpgradeResponseProto {
    fn new() -> FinalizeUpgradeResponseProto {
        FinalizeUpgradeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FinalizeUpgradeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeResponseProto>(
                    "FinalizeUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeRequestProto {
    // message fields
    action: ::std::option::Option<RollingUpgradeActionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollingUpgradeRequestProto {}

impl RollingUpgradeRequestProto {
    pub fn new() -> RollingUpgradeRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeRequestProto,
        };
        unsafe {
            instance.get(RollingUpgradeRequestProto::new)
        }
    }

    // required .hadoop.hdfs.RollingUpgradeActionProto action = 1;

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RollingUpgradeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    pub fn get_action(&self) -> RollingUpgradeActionProto {
        self.action.unwrap_or(RollingUpgradeActionProto::QUERY)
    }

    fn get_action_for_reflect(&self) -> &::std::option::Option<RollingUpgradeActionProto> {
        &self.action
    }

    fn mut_action_for_reflect(&mut self) -> &mut ::std::option::Option<RollingUpgradeActionProto> {
        &mut self.action
    }
}

impl ::protobuf::Message for RollingUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeRequestProto {
    fn new() -> RollingUpgradeRequestProto {
        RollingUpgradeRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RollingUpgradeActionProto>>(
                    "action",
                    RollingUpgradeRequestProto::get_action_for_reflect,
                    RollingUpgradeRequestProto::mut_action_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeRequestProto>(
                    "RollingUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeRequestProto {
    fn clear(&mut self) {
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeInfoProto {
    // message fields
    status: ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto>,
    startTime: ::std::option::Option<u64>,
    finalizeTime: ::std::option::Option<u64>,
    createdRollbackImages: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollingUpgradeInfoProto {}

impl RollingUpgradeInfoProto {
    pub fn new() -> RollingUpgradeInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeInfoProto,
        };
        unsafe {
            instance.get(RollingUpgradeInfoProto::new)
        }
    }

    // required .hadoop.hdfs.RollingUpgradeStatusProto status = 1;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::hdfs::RollingUpgradeStatusProto) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::hdfs::RollingUpgradeStatusProto {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::hdfs::RollingUpgradeStatusProto {
        self.status.take().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::new())
    }

    pub fn get_status(&self) -> &super::hdfs::RollingUpgradeStatusProto {
        self.status.as_ref().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto> {
        &mut self.status
    }

    // required uint64 startTime = 2;

    pub fn clear_startTime(&mut self) {
        self.startTime = ::std::option::Option::None;
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: u64) {
        self.startTime = ::std::option::Option::Some(v);
    }

    pub fn get_startTime(&self) -> u64 {
        self.startTime.unwrap_or(0)
    }

    fn get_startTime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.startTime
    }

    fn mut_startTime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.startTime
    }

    // required uint64 finalizeTime = 3;

    pub fn clear_finalizeTime(&mut self) {
        self.finalizeTime = ::std::option::Option::None;
    }

    pub fn has_finalizeTime(&self) -> bool {
        self.finalizeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalizeTime(&mut self, v: u64) {
        self.finalizeTime = ::std::option::Option::Some(v);
    }

    pub fn get_finalizeTime(&self) -> u64 {
        self.finalizeTime.unwrap_or(0)
    }

    fn get_finalizeTime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.finalizeTime
    }

    fn mut_finalizeTime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.finalizeTime
    }

    // required bool createdRollbackImages = 4;

    pub fn clear_createdRollbackImages(&mut self) {
        self.createdRollbackImages = ::std::option::Option::None;
    }

    pub fn has_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdRollbackImages(&mut self, v: bool) {
        self.createdRollbackImages = ::std::option::Option::Some(v);
    }

    pub fn get_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.unwrap_or(false)
    }

    fn get_createdRollbackImages_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createdRollbackImages
    }

    fn mut_createdRollbackImages_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createdRollbackImages
    }
}

impl ::protobuf::Message for RollingUpgradeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.startTime.is_none() {
            return false;
        }
        if self.finalizeTime.is_none() {
            return false;
        }
        if self.createdRollbackImages.is_none() {
            return false;
        }
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.finalizeTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createdRollbackImages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.startTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.finalizeTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createdRollbackImages {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.startTime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.finalizeTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.createdRollbackImages {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeInfoProto {
    fn new() -> RollingUpgradeInfoProto {
        RollingUpgradeInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::RollingUpgradeStatusProto>>(
                    "status",
                    RollingUpgradeInfoProto::get_status_for_reflect,
                    RollingUpgradeInfoProto::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "startTime",
                    RollingUpgradeInfoProto::get_startTime_for_reflect,
                    RollingUpgradeInfoProto::mut_startTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "finalizeTime",
                    RollingUpgradeInfoProto::get_finalizeTime_for_reflect,
                    RollingUpgradeInfoProto::mut_finalizeTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createdRollbackImages",
                    RollingUpgradeInfoProto::get_createdRollbackImages_for_reflect,
                    RollingUpgradeInfoProto::mut_createdRollbackImages_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeInfoProto>(
                    "RollingUpgradeInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeInfoProto {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_startTime();
        self.clear_finalizeTime();
        self.clear_createdRollbackImages();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeResponseProto {
    // message fields
    rollingUpgradeInfo: ::protobuf::SingularPtrField<RollingUpgradeInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RollingUpgradeResponseProto {}

impl RollingUpgradeResponseProto {
    pub fn new() -> RollingUpgradeResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RollingUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeResponseProto,
        };
        unsafe {
            instance.get(RollingUpgradeResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.RollingUpgradeInfoProto rollingUpgradeInfo = 1;

    pub fn clear_rollingUpgradeInfo(&mut self) {
        self.rollingUpgradeInfo.clear();
    }

    pub fn has_rollingUpgradeInfo(&self) -> bool {
        self.rollingUpgradeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeInfo(&mut self, v: RollingUpgradeInfoProto) {
        self.rollingUpgradeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeInfo(&mut self) -> &mut RollingUpgradeInfoProto {
        if self.rollingUpgradeInfo.is_none() {
            self.rollingUpgradeInfo.set_default();
        }
        self.rollingUpgradeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeInfo(&mut self) -> RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.take().unwrap_or_else(|| RollingUpgradeInfoProto::new())
    }

    pub fn get_rollingUpgradeInfo(&self) -> &RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.as_ref().unwrap_or_else(|| RollingUpgradeInfoProto::default_instance())
    }

    fn get_rollingUpgradeInfo_for_reflect(&self) -> &::protobuf::SingularPtrField<RollingUpgradeInfoProto> {
        &self.rollingUpgradeInfo
    }

    fn mut_rollingUpgradeInfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<RollingUpgradeInfoProto> {
        &mut self.rollingUpgradeInfo
    }
}

impl ::protobuf::Message for RollingUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.rollingUpgradeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollingUpgradeInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RollingUpgradeResponseProto {
    fn new() -> RollingUpgradeResponseProto {
        RollingUpgradeResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RollingUpgradeResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RollingUpgradeInfoProto>>(
                    "rollingUpgradeInfo",
                    RollingUpgradeResponseProto::get_rollingUpgradeInfo_for_reflect,
                    RollingUpgradeResponseProto::mut_rollingUpgradeInfo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeResponseProto>(
                    "RollingUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeResponseProto {
    fn clear(&mut self) {
        self.clear_rollingUpgradeInfo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCorruptFileBlocksRequestProto {}

impl ListCorruptFileBlocksRequestProto {
    pub fn new() -> ListCorruptFileBlocksRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCorruptFileBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksRequestProto,
        };
        unsafe {
            instance.get(ListCorruptFileBlocksRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional string cookie = 2;

    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_cookie_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.cookie
    }

    fn mut_cookie_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.cookie
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCorruptFileBlocksRequestProto {
    fn new() -> ListCorruptFileBlocksRequestProto {
        ListCorruptFileBlocksRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCorruptFileBlocksRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    ListCorruptFileBlocksRequestProto::get_path_for_reflect,
                    ListCorruptFileBlocksRequestProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cookie",
                    ListCorruptFileBlocksRequestProto::get_cookie_for_reflect,
                    ListCorruptFileBlocksRequestProto::mut_cookie_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksRequestProto>(
                    "ListCorruptFileBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_cookie();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksResponseProto {
    // message fields
    corrupt: ::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCorruptFileBlocksResponseProto {}

impl ListCorruptFileBlocksResponseProto {
    pub fn new() -> ListCorruptFileBlocksResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCorruptFileBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksResponseProto,
        };
        unsafe {
            instance.get(ListCorruptFileBlocksResponseProto::new)
        }
    }

    // required .hadoop.hdfs.CorruptFileBlocksProto corrupt = 1;

    pub fn clear_corrupt(&mut self) {
        self.corrupt.clear();
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: super::hdfs::CorruptFileBlocksProto) {
        self.corrupt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_corrupt(&mut self) -> &mut super::hdfs::CorruptFileBlocksProto {
        if self.corrupt.is_none() {
            self.corrupt.set_default();
        }
        self.corrupt.as_mut().unwrap()
    }

    // Take field
    pub fn take_corrupt(&mut self) -> super::hdfs::CorruptFileBlocksProto {
        self.corrupt.take().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::new())
    }

    pub fn get_corrupt(&self) -> &super::hdfs::CorruptFileBlocksProto {
        self.corrupt.as_ref().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::default_instance())
    }

    fn get_corrupt_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto> {
        &self.corrupt
    }

    fn mut_corrupt_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto> {
        &mut self.corrupt
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        if self.corrupt.is_none() {
            return false;
        }
        for v in &self.corrupt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.corrupt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.corrupt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.corrupt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCorruptFileBlocksResponseProto {
    fn new() -> ListCorruptFileBlocksResponseProto {
        ListCorruptFileBlocksResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCorruptFileBlocksResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::CorruptFileBlocksProto>>(
                    "corrupt",
                    ListCorruptFileBlocksResponseProto::get_corrupt_for_reflect,
                    ListCorruptFileBlocksResponseProto::mut_corrupt_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksResponseProto>(
                    "ListCorruptFileBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksResponseProto {
    fn clear(&mut self) {
        self.clear_corrupt();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MetaSaveRequestProto {}

impl MetaSaveRequestProto {
    pub fn new() -> MetaSaveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MetaSaveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveRequestProto,
        };
        unsafe {
            instance.get(MetaSaveRequestProto::new)
        }
    }

    // required string filename = 1;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_filename_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.filename
    }

    fn mut_filename_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.filename
    }
}

impl ::protobuf::Message for MetaSaveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MetaSaveRequestProto {
    fn new() -> MetaSaveRequestProto {
        MetaSaveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MetaSaveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    MetaSaveRequestProto::get_filename_for_reflect,
                    MetaSaveRequestProto::mut_filename_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveRequestProto>(
                    "MetaSaveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MetaSaveRequestProto {
    fn clear(&mut self) {
        self.clear_filename();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MetaSaveResponseProto {}

impl MetaSaveResponseProto {
    pub fn new() -> MetaSaveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MetaSaveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveResponseProto,
        };
        unsafe {
            instance.get(MetaSaveResponseProto::new)
        }
    }
}

impl ::protobuf::Message for MetaSaveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MetaSaveResponseProto {
    fn new() -> MetaSaveResponseProto {
        MetaSaveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<MetaSaveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveResponseProto>(
                    "MetaSaveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MetaSaveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileInfoRequestProto {}

impl GetFileInfoRequestProto {
    pub fn new() -> GetFileInfoRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoRequestProto,
        };
        unsafe {
            instance.get(GetFileInfoRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for GetFileInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileInfoRequestProto {
    fn new() -> GetFileInfoRequestProto {
        GetFileInfoRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileInfoRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetFileInfoRequestProto::get_src_for_reflect,
                    GetFileInfoRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoRequestProto>(
                    "GetFileInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileInfoRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileInfoResponseProto {}

impl GetFileInfoResponseProto {
    pub fn new() -> GetFileInfoResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoResponseProto,
        };
        unsafe {
            instance.get(GetFileInfoResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_fs_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.fs
    }

    fn mut_fs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.fs
    }
}

impl ::protobuf::Message for GetFileInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileInfoResponseProto {
    fn new() -> GetFileInfoResponseProto {
        GetFileInfoResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileInfoResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    GetFileInfoResponseProto::get_fs_for_reflect,
                    GetFileInfoResponseProto::mut_fs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoResponseProto>(
                    "GetFileInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileInfoResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IsFileClosedRequestProto {}

impl IsFileClosedRequestProto {
    pub fn new() -> IsFileClosedRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IsFileClosedRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedRequestProto,
        };
        unsafe {
            instance.get(IsFileClosedRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for IsFileClosedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IsFileClosedRequestProto {
    fn new() -> IsFileClosedRequestProto {
        IsFileClosedRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<IsFileClosedRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    IsFileClosedRequestProto::get_src_for_reflect,
                    IsFileClosedRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedRequestProto>(
                    "IsFileClosedRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IsFileClosedRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IsFileClosedResponseProto {}

impl IsFileClosedResponseProto {
    pub fn new() -> IsFileClosedResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IsFileClosedResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedResponseProto,
        };
        unsafe {
            instance.get(IsFileClosedResponseProto::new)
        }
    }

    // required bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for IsFileClosedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IsFileClosedResponseProto {
    fn new() -> IsFileClosedResponseProto {
        IsFileClosedResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<IsFileClosedResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    IsFileClosedResponseProto::get_result_for_reflect,
                    IsFileClosedResponseProto::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedResponseProto>(
                    "IsFileClosedResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IsFileClosedResponseProto {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    pool: ::protobuf::SingularField<::std::string::String>,
    expiration: ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveInfoProto {}

impl CacheDirectiveInfoProto {
    pub fn new() -> CacheDirectiveInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoProto,
        };
        unsafe {
            instance.get(CacheDirectiveInfoProto::new)
        }
    }

    // optional int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional uint32 replication = 3;

    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }

    fn get_replication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replication
    }

    fn mut_replication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replication
    }

    // optional string pool = 4;

    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pool_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pool
    }

    fn mut_pool_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pool
    }

    // optional .hadoop.hdfs.CacheDirectiveInfoExpirationProto expiration = 5;

    pub fn clear_expiration(&mut self) {
        self.expiration.clear();
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: CacheDirectiveInfoExpirationProto) {
        self.expiration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration(&mut self) -> &mut CacheDirectiveInfoExpirationProto {
        if self.expiration.is_none() {
            self.expiration.set_default();
        }
        self.expiration.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration(&mut self) -> CacheDirectiveInfoExpirationProto {
        self.expiration.take().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::new())
    }

    pub fn get_expiration(&self) -> &CacheDirectiveInfoExpirationProto {
        self.expiration.as_ref().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::default_instance())
    }

    fn get_expiration_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto> {
        &self.expiration
    }

    fn mut_expiration_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto> {
        &mut self.expiration
    }
}

impl ::protobuf::Message for CacheDirectiveInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.expiration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.expiration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.expiration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveInfoProto {
    fn new() -> CacheDirectiveInfoProto {
        CacheDirectiveInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    CacheDirectiveInfoProto::get_id_for_reflect,
                    CacheDirectiveInfoProto::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CacheDirectiveInfoProto::get_path_for_reflect,
                    CacheDirectiveInfoProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    CacheDirectiveInfoProto::get_replication_for_reflect,
                    CacheDirectiveInfoProto::mut_replication_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pool",
                    CacheDirectiveInfoProto::get_pool_for_reflect,
                    CacheDirectiveInfoProto::mut_pool_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoExpirationProto>>(
                    "expiration",
                    CacheDirectiveInfoProto::get_expiration_for_reflect,
                    CacheDirectiveInfoProto::mut_expiration_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoProto>(
                    "CacheDirectiveInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_path();
        self.clear_replication();
        self.clear_pool();
        self.clear_expiration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoExpirationProto {
    // message fields
    millis: ::std::option::Option<i64>,
    isRelative: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveInfoExpirationProto {}

impl CacheDirectiveInfoExpirationProto {
    pub fn new() -> CacheDirectiveInfoExpirationProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveInfoExpirationProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoExpirationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoExpirationProto,
        };
        unsafe {
            instance.get(CacheDirectiveInfoExpirationProto::new)
        }
    }

    // required int64 millis = 1;

    pub fn clear_millis(&mut self) {
        self.millis = ::std::option::Option::None;
    }

    pub fn has_millis(&self) -> bool {
        self.millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_millis(&mut self, v: i64) {
        self.millis = ::std::option::Option::Some(v);
    }

    pub fn get_millis(&self) -> i64 {
        self.millis.unwrap_or(0)
    }

    fn get_millis_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.millis
    }

    fn mut_millis_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.millis
    }

    // required bool isRelative = 2;

    pub fn clear_isRelative(&mut self) {
        self.isRelative = ::std::option::Option::None;
    }

    pub fn has_isRelative(&self) -> bool {
        self.isRelative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRelative(&mut self, v: bool) {
        self.isRelative = ::std::option::Option::Some(v);
    }

    pub fn get_isRelative(&self) -> bool {
        self.isRelative.unwrap_or(false)
    }

    fn get_isRelative_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.isRelative
    }

    fn mut_isRelative_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.isRelative
    }
}

impl ::protobuf::Message for CacheDirectiveInfoExpirationProto {
    fn is_initialized(&self) -> bool {
        if self.millis.is_none() {
            return false;
        }
        if self.isRelative.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.millis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRelative = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.millis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isRelative {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.millis {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.isRelative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveInfoExpirationProto {
    fn new() -> CacheDirectiveInfoExpirationProto {
        CacheDirectiveInfoExpirationProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveInfoExpirationProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "millis",
                    CacheDirectiveInfoExpirationProto::get_millis_for_reflect,
                    CacheDirectiveInfoExpirationProto::mut_millis_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isRelative",
                    CacheDirectiveInfoExpirationProto::get_isRelative_for_reflect,
                    CacheDirectiveInfoExpirationProto::mut_isRelative_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoExpirationProto>(
                    "CacheDirectiveInfoExpirationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoExpirationProto {
    fn clear(&mut self) {
        self.clear_millis();
        self.clear_isRelative();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoExpirationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoExpirationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    hasExpired: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveStatsProto {}

impl CacheDirectiveStatsProto {
    pub fn new() -> CacheDirectiveStatsProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveStatsProto,
        };
        unsafe {
            instance.get(CacheDirectiveStatsProto::new)
        }
    }

    // required int64 bytesNeeded = 1;

    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }

    fn get_bytesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesNeeded
    }

    fn mut_bytesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesNeeded
    }

    // required int64 bytesCached = 2;

    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }

    fn get_bytesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesCached
    }

    fn mut_bytesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesCached
    }

    // required int64 filesNeeded = 3;

    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }

    fn get_filesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesNeeded
    }

    fn mut_filesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesNeeded
    }

    // required int64 filesCached = 4;

    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }

    fn get_filesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesCached
    }

    fn mut_filesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesCached
    }

    // required bool hasExpired = 5;

    pub fn clear_hasExpired(&mut self) {
        self.hasExpired = ::std::option::Option::None;
    }

    pub fn has_hasExpired(&self) -> bool {
        self.hasExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasExpired(&mut self, v: bool) {
        self.hasExpired = ::std::option::Option::Some(v);
    }

    pub fn get_hasExpired(&self) -> bool {
        self.hasExpired.unwrap_or(false)
    }

    fn get_hasExpired_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasExpired
    }

    fn mut_hasExpired_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasExpired
    }
}

impl ::protobuf::Message for CacheDirectiveStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        if self.hasExpired.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasExpired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasExpired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.hasExpired {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveStatsProto {
    fn new() -> CacheDirectiveStatsProto {
        CacheDirectiveStatsProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveStatsProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesNeeded",
                    CacheDirectiveStatsProto::get_bytesNeeded_for_reflect,
                    CacheDirectiveStatsProto::mut_bytesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesCached",
                    CacheDirectiveStatsProto::get_bytesCached_for_reflect,
                    CacheDirectiveStatsProto::mut_bytesCached_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesNeeded",
                    CacheDirectiveStatsProto::get_filesNeeded_for_reflect,
                    CacheDirectiveStatsProto::mut_filesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesCached",
                    CacheDirectiveStatsProto::get_filesCached_for_reflect,
                    CacheDirectiveStatsProto::mut_filesCached_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasExpired",
                    CacheDirectiveStatsProto::get_hasExpired_for_reflect,
                    CacheDirectiveStatsProto::mut_hasExpired_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveStatsProto>(
                    "CacheDirectiveStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveStatsProto {
    fn clear(&mut self) {
        self.clear_bytesNeeded();
        self.clear_bytesCached();
        self.clear_filesNeeded();
        self.clear_filesCached();
        self.clear_hasExpired();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCacheDirectiveRequestProto {}

impl AddCacheDirectiveRequestProto {
    pub fn new() -> AddCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(AddCacheDirectiveRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.info
    }

    // optional uint32 cacheFlags = 2;

    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }

    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }

    fn get_cacheFlags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cacheFlags
    }

    fn mut_cacheFlags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cacheFlags
    }
}

impl ::protobuf::Message for AddCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCacheDirectiveRequestProto {
    fn new() -> AddCacheDirectiveRequestProto {
        AddCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    AddCacheDirectiveRequestProto::get_info_for_reflect,
                    AddCacheDirectiveRequestProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cacheFlags",
                    AddCacheDirectiveRequestProto::get_cacheFlags_for_reflect,
                    AddCacheDirectiveRequestProto::mut_cacheFlags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveRequestProto>(
                    "AddCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_cacheFlags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCacheDirectiveResponseProto {}

impl AddCacheDirectiveResponseProto {
    pub fn new() -> AddCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(AddCacheDirectiveResponseProto::new)
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }
}

impl ::protobuf::Message for AddCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCacheDirectiveResponseProto {
    fn new() -> AddCacheDirectiveResponseProto {
        AddCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    AddCacheDirectiveResponseProto::get_id_for_reflect,
                    AddCacheDirectiveResponseProto::mut_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveResponseProto>(
                    "AddCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCacheDirectiveRequestProto {}

impl ModifyCacheDirectiveRequestProto {
    pub fn new() -> ModifyCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(ModifyCacheDirectiveRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.info
    }

    // optional uint32 cacheFlags = 2;

    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }

    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }

    fn get_cacheFlags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cacheFlags
    }

    fn mut_cacheFlags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cacheFlags
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCacheDirectiveRequestProto {
    fn new() -> ModifyCacheDirectiveRequestProto {
        ModifyCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    ModifyCacheDirectiveRequestProto::get_info_for_reflect,
                    ModifyCacheDirectiveRequestProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cacheFlags",
                    ModifyCacheDirectiveRequestProto::get_cacheFlags_for_reflect,
                    ModifyCacheDirectiveRequestProto::mut_cacheFlags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveRequestProto>(
                    "ModifyCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_cacheFlags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCacheDirectiveResponseProto {}

impl ModifyCacheDirectiveResponseProto {
    pub fn new() -> ModifyCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(ModifyCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCacheDirectiveResponseProto {
    fn new() -> ModifyCacheDirectiveResponseProto {
        ModifyCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveResponseProto>(
                    "ModifyCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCacheDirectiveRequestProto {}

impl RemoveCacheDirectiveRequestProto {
    pub fn new() -> RemoveCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(RemoveCacheDirectiveRequestProto::new)
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCacheDirectiveRequestProto {
    fn new() -> RemoveCacheDirectiveRequestProto {
        RemoveCacheDirectiveRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCacheDirectiveRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    RemoveCacheDirectiveRequestProto::get_id_for_reflect,
                    RemoveCacheDirectiveRequestProto::mut_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveRequestProto>(
                    "RemoveCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCacheDirectiveResponseProto {}

impl RemoveCacheDirectiveResponseProto {
    pub fn new() -> RemoveCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(RemoveCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCacheDirectiveResponseProto {
    fn new() -> RemoveCacheDirectiveResponseProto {
        RemoveCacheDirectiveResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCacheDirectiveResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveResponseProto>(
                    "RemoveCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesRequestProto {
    // message fields
    prevId: ::std::option::Option<i64>,
    filter: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCacheDirectivesRequestProto {}

impl ListCacheDirectivesRequestProto {
    pub fn new() -> ListCacheDirectivesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCacheDirectivesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesRequestProto,
        };
        unsafe {
            instance.get(ListCacheDirectivesRequestProto::new)
        }
    }

    // required int64 prevId = 1;

    pub fn clear_prevId(&mut self) {
        self.prevId = ::std::option::Option::None;
    }

    pub fn has_prevId(&self) -> bool {
        self.prevId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevId(&mut self, v: i64) {
        self.prevId = ::std::option::Option::Some(v);
    }

    pub fn get_prevId(&self) -> i64 {
        self.prevId.unwrap_or(0)
    }

    fn get_prevId_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.prevId
    }

    fn mut_prevId_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.prevId
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto filter = 2;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: CacheDirectiveInfoProto) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> CacheDirectiveInfoProto {
        self.filter.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_filter(&self) -> &CacheDirectiveInfoProto {
        self.filter.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_filter_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.filter
    }

    fn mut_filter_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.filter
    }
}

impl ::protobuf::Message for ListCacheDirectivesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevId.is_none() {
            return false;
        }
        if self.filter.is_none() {
            return false;
        }
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prevId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prevId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prevId {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCacheDirectivesRequestProto {
    fn new() -> ListCacheDirectivesRequestProto {
        ListCacheDirectivesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCacheDirectivesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prevId",
                    ListCacheDirectivesRequestProto::get_prevId_for_reflect,
                    ListCacheDirectivesRequestProto::mut_prevId_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "filter",
                    ListCacheDirectivesRequestProto::get_filter_for_reflect,
                    ListCacheDirectivesRequestProto::mut_filter_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesRequestProto>(
                    "ListCacheDirectivesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesRequestProto {
    fn clear(&mut self) {
        self.clear_prevId();
        self.clear_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    stats: ::protobuf::SingularPtrField<CacheDirectiveStatsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CacheDirectiveEntryProto {}

impl CacheDirectiveEntryProto {
    pub fn new() -> CacheDirectiveEntryProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CacheDirectiveEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveEntryProto,
        };
        unsafe {
            instance.get(CacheDirectiveEntryProto::new)
        }
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveInfoProto> {
        &mut self.info
    }

    // required .hadoop.hdfs.CacheDirectiveStatsProto stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CacheDirectiveStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CacheDirectiveStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CacheDirectiveStatsProto {
        self.stats.take().unwrap_or_else(|| CacheDirectiveStatsProto::new())
    }

    pub fn get_stats(&self) -> &CacheDirectiveStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CacheDirectiveStatsProto::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CacheDirectiveStatsProto> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CacheDirectiveStatsProto> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CacheDirectiveEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CacheDirectiveEntryProto {
    fn new() -> CacheDirectiveEntryProto {
        CacheDirectiveEntryProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CacheDirectiveEntryProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    CacheDirectiveEntryProto::get_info_for_reflect,
                    CacheDirectiveEntryProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveStatsProto>>(
                    "stats",
                    CacheDirectiveEntryProto::get_stats_for_reflect,
                    CacheDirectiveEntryProto::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveEntryProto>(
                    "CacheDirectiveEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveEntryProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesResponseProto {
    // message fields
    elements: ::protobuf::RepeatedField<CacheDirectiveEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCacheDirectivesResponseProto {}

impl ListCacheDirectivesResponseProto {
    pub fn new() -> ListCacheDirectivesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCacheDirectivesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesResponseProto,
        };
        unsafe {
            instance.get(ListCacheDirectivesResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.CacheDirectiveEntryProto elements = 1;

    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<CacheDirectiveEntryProto>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    pub fn get_elements(&self) -> &[CacheDirectiveEntryProto] {
        &self.elements
    }

    fn get_elements_for_reflect(&self) -> &::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &self.elements
    }

    fn mut_elements_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    fn get_hasMore_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasMore
    }

    fn mut_hasMore_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasMore
    }
}

impl ::protobuf::Message for ListCacheDirectivesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCacheDirectivesResponseProto {
    fn new() -> ListCacheDirectivesResponseProto {
        ListCacheDirectivesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCacheDirectivesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveEntryProto>>(
                    "elements",
                    ListCacheDirectivesResponseProto::get_elements_for_reflect,
                    ListCacheDirectivesResponseProto::mut_elements_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    ListCacheDirectivesResponseProto::get_hasMore_for_reflect,
                    ListCacheDirectivesResponseProto::mut_hasMore_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesResponseProto>(
                    "ListCacheDirectivesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesResponseProto {
    fn clear(&mut self) {
        self.clear_elements();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolInfoProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    ownerName: ::protobuf::SingularField<::std::string::String>,
    groupName: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    limit: ::std::option::Option<i64>,
    maxRelativeExpiry: ::std::option::Option<i64>,
    defaultReplication: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CachePoolInfoProto {}

impl CachePoolInfoProto {
    pub fn new() -> CachePoolInfoProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolInfoProto,
        };
        unsafe {
            instance.get(CachePoolInfoProto::new)
        }
    }

    // optional string poolName = 1;

    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_poolName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.poolName
    }

    fn mut_poolName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.poolName
    }

    // optional string ownerName = 2;

    pub fn clear_ownerName(&mut self) {
        self.ownerName.clear();
    }

    pub fn has_ownerName(&self) -> bool {
        self.ownerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownerName(&mut self, v: ::std::string::String) {
        self.ownerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerName(&mut self) -> &mut ::std::string::String {
        if self.ownerName.is_none() {
            self.ownerName.set_default();
        }
        self.ownerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ownerName(&mut self) -> ::std::string::String {
        self.ownerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ownerName(&self) -> &str {
        match self.ownerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ownerName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ownerName
    }

    fn mut_ownerName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ownerName
    }

    // optional string groupName = 3;

    pub fn clear_groupName(&mut self) {
        self.groupName.clear();
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName(&mut self) -> &mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName.set_default();
        }
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_groupName(&self) -> &str {
        match self.groupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_groupName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.groupName
    }

    fn mut_groupName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.groupName
    }

    // optional int32 mode = 4;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mode
    }

    // optional int64 limit = 5;

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    pub fn get_limit(&self) -> i64 {
        self.limit.unwrap_or(0)
    }

    fn get_limit_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.limit
    }

    fn mut_limit_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.limit
    }

    // optional int64 maxRelativeExpiry = 6;

    pub fn clear_maxRelativeExpiry(&mut self) {
        self.maxRelativeExpiry = ::std::option::Option::None;
    }

    pub fn has_maxRelativeExpiry(&self) -> bool {
        self.maxRelativeExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxRelativeExpiry(&mut self, v: i64) {
        self.maxRelativeExpiry = ::std::option::Option::Some(v);
    }

    pub fn get_maxRelativeExpiry(&self) -> i64 {
        self.maxRelativeExpiry.unwrap_or(0)
    }

    fn get_maxRelativeExpiry_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.maxRelativeExpiry
    }

    fn mut_maxRelativeExpiry_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.maxRelativeExpiry
    }

    // optional uint32 defaultReplication = 7;

    pub fn clear_defaultReplication(&mut self) {
        self.defaultReplication = ::std::option::Option::None;
    }

    pub fn has_defaultReplication(&self) -> bool {
        self.defaultReplication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultReplication(&mut self, v: u32) {
        self.defaultReplication = ::std::option::Option::Some(v);
    }

    pub fn get_defaultReplication(&self) -> u32 {
        self.defaultReplication.unwrap_or(1u32)
    }

    fn get_defaultReplication_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.defaultReplication
    }

    fn mut_defaultReplication_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.defaultReplication
    }
}

impl ::protobuf::Message for CachePoolInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ownerName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxRelativeExpiry = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defaultReplication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxRelativeExpiry {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defaultReplication {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.maxRelativeExpiry {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.defaultReplication {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolInfoProto {
    fn new() -> CachePoolInfoProto {
        CachePoolInfoProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolInfoProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolName",
                    CachePoolInfoProto::get_poolName_for_reflect,
                    CachePoolInfoProto::mut_poolName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ownerName",
                    CachePoolInfoProto::get_ownerName_for_reflect,
                    CachePoolInfoProto::mut_ownerName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groupName",
                    CachePoolInfoProto::get_groupName_for_reflect,
                    CachePoolInfoProto::mut_groupName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode",
                    CachePoolInfoProto::get_mode_for_reflect,
                    CachePoolInfoProto::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    CachePoolInfoProto::get_limit_for_reflect,
                    CachePoolInfoProto::mut_limit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "maxRelativeExpiry",
                    CachePoolInfoProto::get_maxRelativeExpiry_for_reflect,
                    CachePoolInfoProto::mut_maxRelativeExpiry_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defaultReplication",
                    CachePoolInfoProto::get_defaultReplication_for_reflect,
                    CachePoolInfoProto::mut_defaultReplication_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolInfoProto>(
                    "CachePoolInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolInfoProto {
    fn clear(&mut self) {
        self.clear_poolName();
        self.clear_ownerName();
        self.clear_groupName();
        self.clear_mode();
        self.clear_limit();
        self.clear_maxRelativeExpiry();
        self.clear_defaultReplication();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    bytesOverlimit: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CachePoolStatsProto {}

impl CachePoolStatsProto {
    pub fn new() -> CachePoolStatsProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolStatsProto,
        };
        unsafe {
            instance.get(CachePoolStatsProto::new)
        }
    }

    // required int64 bytesNeeded = 1;

    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }

    fn get_bytesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesNeeded
    }

    fn mut_bytesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesNeeded
    }

    // required int64 bytesCached = 2;

    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }

    fn get_bytesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesCached
    }

    fn mut_bytesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesCached
    }

    // required int64 bytesOverlimit = 3;

    pub fn clear_bytesOverlimit(&mut self) {
        self.bytesOverlimit = ::std::option::Option::None;
    }

    pub fn has_bytesOverlimit(&self) -> bool {
        self.bytesOverlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOverlimit(&mut self, v: i64) {
        self.bytesOverlimit = ::std::option::Option::Some(v);
    }

    pub fn get_bytesOverlimit(&self) -> i64 {
        self.bytesOverlimit.unwrap_or(0)
    }

    fn get_bytesOverlimit_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bytesOverlimit
    }

    fn mut_bytesOverlimit_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bytesOverlimit
    }

    // required int64 filesNeeded = 4;

    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }

    fn get_filesNeeded_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesNeeded
    }

    fn mut_filesNeeded_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesNeeded
    }

    // required int64 filesCached = 5;

    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }

    fn get_filesCached_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.filesCached
    }

    fn mut_filesCached_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.filesCached
    }
}

impl ::protobuf::Message for CachePoolStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.bytesOverlimit.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesOverlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesOverlimit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bytesOverlimit {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolStatsProto {
    fn new() -> CachePoolStatsProto {
        CachePoolStatsProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolStatsProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesNeeded",
                    CachePoolStatsProto::get_bytesNeeded_for_reflect,
                    CachePoolStatsProto::mut_bytesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesCached",
                    CachePoolStatsProto::get_bytesCached_for_reflect,
                    CachePoolStatsProto::mut_bytesCached_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesOverlimit",
                    CachePoolStatsProto::get_bytesOverlimit_for_reflect,
                    CachePoolStatsProto::mut_bytesOverlimit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesNeeded",
                    CachePoolStatsProto::get_filesNeeded_for_reflect,
                    CachePoolStatsProto::mut_filesNeeded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesCached",
                    CachePoolStatsProto::get_filesCached_for_reflect,
                    CachePoolStatsProto::mut_filesCached_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolStatsProto>(
                    "CachePoolStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolStatsProto {
    fn clear(&mut self) {
        self.clear_bytesNeeded();
        self.clear_bytesCached();
        self.clear_bytesOverlimit();
        self.clear_filesNeeded();
        self.clear_filesCached();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCachePoolRequestProto {}

impl AddCachePoolRequestProto {
    pub fn new() -> AddCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolRequestProto,
        };
        unsafe {
            instance.get(AddCachePoolRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolInfoProto> {
        &mut self.info
    }
}

impl ::protobuf::Message for AddCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCachePoolRequestProto {
    fn new() -> AddCachePoolRequestProto {
        AddCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    AddCachePoolRequestProto::get_info_for_reflect,
                    AddCachePoolRequestProto::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolRequestProto>(
                    "AddCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AddCachePoolResponseProto {}

impl AddCachePoolResponseProto {
    pub fn new() -> AddCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AddCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolResponseProto,
        };
        unsafe {
            instance.get(AddCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Message for AddCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AddCachePoolResponseProto {
    fn new() -> AddCachePoolResponseProto {
        AddCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AddCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolResponseProto>(
                    "AddCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AddCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCachePoolRequestProto {}

impl ModifyCachePoolRequestProto {
    pub fn new() -> ModifyCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolRequestProto,
        };
        unsafe {
            instance.get(ModifyCachePoolRequestProto::new)
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolInfoProto> {
        &mut self.info
    }
}

impl ::protobuf::Message for ModifyCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCachePoolRequestProto {
    fn new() -> ModifyCachePoolRequestProto {
        ModifyCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    ModifyCachePoolRequestProto::get_info_for_reflect,
                    ModifyCachePoolRequestProto::mut_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolRequestProto>(
                    "ModifyCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ModifyCachePoolResponseProto {}

impl ModifyCachePoolResponseProto {
    pub fn new() -> ModifyCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ModifyCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolResponseProto,
        };
        unsafe {
            instance.get(ModifyCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Message for ModifyCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ModifyCachePoolResponseProto {
    fn new() -> ModifyCachePoolResponseProto {
        ModifyCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ModifyCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolResponseProto>(
                    "ModifyCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolRequestProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCachePoolRequestProto {}

impl RemoveCachePoolRequestProto {
    pub fn new() -> RemoveCachePoolRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolRequestProto,
        };
        unsafe {
            instance.get(RemoveCachePoolRequestProto::new)
        }
    }

    // required string poolName = 1;

    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_poolName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.poolName
    }

    fn mut_poolName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.poolName
    }
}

impl ::protobuf::Message for RemoveCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.poolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCachePoolRequestProto {
    fn new() -> RemoveCachePoolRequestProto {
        RemoveCachePoolRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCachePoolRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolName",
                    RemoveCachePoolRequestProto::get_poolName_for_reflect,
                    RemoveCachePoolRequestProto::mut_poolName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolRequestProto>(
                    "RemoveCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolRequestProto {
    fn clear(&mut self) {
        self.clear_poolName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RemoveCachePoolResponseProto {}

impl RemoveCachePoolResponseProto {
    pub fn new() -> RemoveCachePoolResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RemoveCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolResponseProto,
        };
        unsafe {
            instance.get(RemoveCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RemoveCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RemoveCachePoolResponseProto {
    fn new() -> RemoveCachePoolResponseProto {
        RemoveCachePoolResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RemoveCachePoolResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolResponseProto>(
                    "RemoveCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsRequestProto {
    // message fields
    prevPoolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCachePoolsRequestProto {}

impl ListCachePoolsRequestProto {
    pub fn new() -> ListCachePoolsRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCachePoolsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsRequestProto,
        };
        unsafe {
            instance.get(ListCachePoolsRequestProto::new)
        }
    }

    // required string prevPoolName = 1;

    pub fn clear_prevPoolName(&mut self) {
        self.prevPoolName.clear();
    }

    pub fn has_prevPoolName(&self) -> bool {
        self.prevPoolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevPoolName(&mut self, v: ::std::string::String) {
        self.prevPoolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevPoolName(&mut self) -> &mut ::std::string::String {
        if self.prevPoolName.is_none() {
            self.prevPoolName.set_default();
        }
        self.prevPoolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_prevPoolName(&mut self) -> ::std::string::String {
        self.prevPoolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_prevPoolName(&self) -> &str {
        match self.prevPoolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_prevPoolName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.prevPoolName
    }

    fn mut_prevPoolName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.prevPoolName
    }
}

impl ::protobuf::Message for ListCachePoolsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevPoolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prevPoolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prevPoolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prevPoolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCachePoolsRequestProto {
    fn new() -> ListCachePoolsRequestProto {
        ListCachePoolsRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCachePoolsRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prevPoolName",
                    ListCachePoolsRequestProto::get_prevPoolName_for_reflect,
                    ListCachePoolsRequestProto::mut_prevPoolName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsRequestProto>(
                    "ListCachePoolsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsRequestProto {
    fn clear(&mut self) {
        self.clear_prevPoolName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsResponseProto {
    // message fields
    entries: ::protobuf::RepeatedField<CachePoolEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListCachePoolsResponseProto {}

impl ListCachePoolsResponseProto {
    pub fn new() -> ListCachePoolsResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListCachePoolsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsResponseProto,
        };
        unsafe {
            instance.get(ListCachePoolsResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.CachePoolEntryProto entries = 1;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CachePoolEntryProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CachePoolEntryProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[CachePoolEntryProto] {
        &self.entries
    }

    fn get_entries_for_reflect(&self) -> &::protobuf::RepeatedField<CachePoolEntryProto> {
        &self.entries
    }

    fn mut_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    fn get_hasMore_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasMore
    }

    fn mut_hasMore_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasMore
    }
}

impl ::protobuf::Message for ListCachePoolsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListCachePoolsResponseProto {
    fn new() -> ListCachePoolsResponseProto {
        ListCachePoolsResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListCachePoolsResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolEntryProto>>(
                    "entries",
                    ListCachePoolsResponseProto::get_entries_for_reflect,
                    ListCachePoolsResponseProto::mut_entries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    ListCachePoolsResponseProto::get_hasMore_for_reflect,
                    ListCachePoolsResponseProto::mut_hasMore_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsResponseProto>(
                    "ListCachePoolsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsResponseProto {
    fn clear(&mut self) {
        self.clear_entries();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    stats: ::protobuf::SingularPtrField<CachePoolStatsProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CachePoolEntryProto {}

impl CachePoolEntryProto {
    pub fn new() -> CachePoolEntryProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CachePoolEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolEntryProto,
        };
        unsafe {
            instance.get(CachePoolEntryProto::new)
        }
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }

    fn get_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolInfoProto> {
        &self.info
    }

    fn mut_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolInfoProto> {
        &mut self.info
    }

    // required .hadoop.hdfs.CachePoolStatsProto stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CachePoolStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CachePoolStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CachePoolStatsProto {
        self.stats.take().unwrap_or_else(|| CachePoolStatsProto::new())
    }

    pub fn get_stats(&self) -> &CachePoolStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CachePoolStatsProto::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CachePoolStatsProto> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CachePoolStatsProto> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CachePoolEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CachePoolEntryProto {
    fn new() -> CachePoolEntryProto {
        CachePoolEntryProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CachePoolEntryProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    CachePoolEntryProto::get_info_for_reflect,
                    CachePoolEntryProto::mut_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolStatsProto>>(
                    "stats",
                    CachePoolEntryProto::get_stats_for_reflect,
                    CachePoolEntryProto::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolEntryProto>(
                    "CachePoolEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CachePoolEntryProto {
    fn clear(&mut self) {
        self.clear_info();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileLinkInfoRequestProto {}

impl GetFileLinkInfoRequestProto {
    pub fn new() -> GetFileLinkInfoRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileLinkInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoRequestProto,
        };
        unsafe {
            instance.get(GetFileLinkInfoRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }
}

impl ::protobuf::Message for GetFileLinkInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileLinkInfoRequestProto {
    fn new() -> GetFileLinkInfoRequestProto {
        GetFileLinkInfoRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileLinkInfoRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    GetFileLinkInfoRequestProto::get_src_for_reflect,
                    GetFileLinkInfoRequestProto::mut_src_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoRequestProto>(
                    "GetFileLinkInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetFileLinkInfoResponseProto {}

impl GetFileLinkInfoResponseProto {
    pub fn new() -> GetFileLinkInfoResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetFileLinkInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoResponseProto,
        };
        unsafe {
            instance.get(GetFileLinkInfoResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;

    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }

    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }

    fn get_fs_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &self.fs
    }

    fn mut_fs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto> {
        &mut self.fs
    }
}

impl ::protobuf::Message for GetFileLinkInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetFileLinkInfoResponseProto {
    fn new() -> GetFileLinkInfoResponseProto {
        GetFileLinkInfoResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetFileLinkInfoResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    GetFileLinkInfoResponseProto::get_fs_for_reflect,
                    GetFileLinkInfoResponseProto::mut_fs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoResponseProto>(
                    "GetFileLinkInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoResponseProto {
    fn clear(&mut self) {
        self.clear_fs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetContentSummaryRequestProto {}

impl GetContentSummaryRequestProto {
    pub fn new() -> GetContentSummaryRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetContentSummaryRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryRequestProto,
        };
        unsafe {
            instance.get(GetContentSummaryRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for GetContentSummaryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetContentSummaryRequestProto {
    fn new() -> GetContentSummaryRequestProto {
        GetContentSummaryRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetContentSummaryRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GetContentSummaryRequestProto::get_path_for_reflect,
                    GetContentSummaryRequestProto::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryRequestProto>(
                    "GetContentSummaryRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryResponseProto {
    // message fields
    summary: ::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetContentSummaryResponseProto {}

impl GetContentSummaryResponseProto {
    pub fn new() -> GetContentSummaryResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetContentSummaryResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryResponseProto,
        };
        unsafe {
            instance.get(GetContentSummaryResponseProto::new)
        }
    }

    // required .hadoop.hdfs.ContentSummaryProto summary = 1;

    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: super::hdfs::ContentSummaryProto) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut super::hdfs::ContentSummaryProto {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> super::hdfs::ContentSummaryProto {
        self.summary.take().unwrap_or_else(|| super::hdfs::ContentSummaryProto::new())
    }

    pub fn get_summary(&self) -> &super::hdfs::ContentSummaryProto {
        self.summary.as_ref().unwrap_or_else(|| super::hdfs::ContentSummaryProto::default_instance())
    }

    fn get_summary_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto> {
        &self.summary
    }

    fn mut_summary_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto> {
        &mut self.summary
    }
}

impl ::protobuf::Message for GetContentSummaryResponseProto {
    fn is_initialized(&self) -> bool {
        if self.summary.is_none() {
            return false;
        }
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetContentSummaryResponseProto {
    fn new() -> GetContentSummaryResponseProto {
        GetContentSummaryResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetContentSummaryResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ContentSummaryProto>>(
                    "summary",
                    GetContentSummaryResponseProto::get_summary_for_reflect,
                    GetContentSummaryResponseProto::mut_summary_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryResponseProto>(
                    "GetContentSummaryResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryResponseProto {
    fn clear(&mut self) {
        self.clear_summary();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQuotaUsageRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetQuotaUsageRequestProto {}

impl GetQuotaUsageRequestProto {
    pub fn new() -> GetQuotaUsageRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetQuotaUsageRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetQuotaUsageRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetQuotaUsageRequestProto,
        };
        unsafe {
            instance.get(GetQuotaUsageRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for GetQuotaUsageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetQuotaUsageRequestProto {
    fn new() -> GetQuotaUsageRequestProto {
        GetQuotaUsageRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetQuotaUsageRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GetQuotaUsageRequestProto::get_path_for_reflect,
                    GetQuotaUsageRequestProto::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetQuotaUsageRequestProto>(
                    "GetQuotaUsageRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetQuotaUsageRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQuotaUsageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQuotaUsageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQuotaUsageResponseProto {
    // message fields
    usage: ::protobuf::SingularPtrField<super::hdfs::QuotaUsageProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetQuotaUsageResponseProto {}

impl GetQuotaUsageResponseProto {
    pub fn new() -> GetQuotaUsageResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetQuotaUsageResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetQuotaUsageResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetQuotaUsageResponseProto,
        };
        unsafe {
            instance.get(GetQuotaUsageResponseProto::new)
        }
    }

    // required .hadoop.hdfs.QuotaUsageProto usage = 1;

    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: super::hdfs::QuotaUsageProto) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut super::hdfs::QuotaUsageProto {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> super::hdfs::QuotaUsageProto {
        self.usage.take().unwrap_or_else(|| super::hdfs::QuotaUsageProto::new())
    }

    pub fn get_usage(&self) -> &super::hdfs::QuotaUsageProto {
        self.usage.as_ref().unwrap_or_else(|| super::hdfs::QuotaUsageProto::default_instance())
    }

    fn get_usage_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::QuotaUsageProto> {
        &self.usage
    }

    fn mut_usage_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::QuotaUsageProto> {
        &mut self.usage
    }
}

impl ::protobuf::Message for GetQuotaUsageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.usage.is_none() {
            return false;
        }
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetQuotaUsageResponseProto {
    fn new() -> GetQuotaUsageResponseProto {
        GetQuotaUsageResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetQuotaUsageResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::QuotaUsageProto>>(
                    "usage",
                    GetQuotaUsageResponseProto::get_usage_for_reflect,
                    GetQuotaUsageResponseProto::mut_usage_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetQuotaUsageResponseProto>(
                    "GetQuotaUsageResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetQuotaUsageResponseProto {
    fn clear(&mut self) {
        self.clear_usage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQuotaUsageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQuotaUsageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    namespaceQuota: ::std::option::Option<u64>,
    storagespaceQuota: ::std::option::Option<u64>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetQuotaRequestProto {}

impl SetQuotaRequestProto {
    pub fn new() -> SetQuotaRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetQuotaRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaRequestProto,
        };
        unsafe {
            instance.get(SetQuotaRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // required uint64 namespaceQuota = 2;

    pub fn clear_namespaceQuota(&mut self) {
        self.namespaceQuota = ::std::option::Option::None;
    }

    pub fn has_namespaceQuota(&self) -> bool {
        self.namespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceQuota(&mut self, v: u64) {
        self.namespaceQuota = ::std::option::Option::Some(v);
    }

    pub fn get_namespaceQuota(&self) -> u64 {
        self.namespaceQuota.unwrap_or(0)
    }

    fn get_namespaceQuota_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.namespaceQuota
    }

    fn mut_namespaceQuota_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.namespaceQuota
    }

    // required uint64 storagespaceQuota = 3;

    pub fn clear_storagespaceQuota(&mut self) {
        self.storagespaceQuota = ::std::option::Option::None;
    }

    pub fn has_storagespaceQuota(&self) -> bool {
        self.storagespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagespaceQuota(&mut self, v: u64) {
        self.storagespaceQuota = ::std::option::Option::Some(v);
    }

    pub fn get_storagespaceQuota(&self) -> u64 {
        self.storagespaceQuota.unwrap_or(0)
    }

    fn get_storagespaceQuota_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.storagespaceQuota
    }

    fn mut_storagespaceQuota_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.storagespaceQuota
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 4;

    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }

    fn get_storageType_for_reflect(&self) -> &::std::option::Option<super::hdfs::StorageTypeProto> {
        &self.storageType
    }

    fn mut_storageType_for_reflect(&mut self) -> &mut ::std::option::Option<super::hdfs::StorageTypeProto> {
        &mut self.storageType
    }
}

impl ::protobuf::Message for SetQuotaRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.namespaceQuota.is_none() {
            return false;
        }
        if self.storagespaceQuota.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namespaceQuota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storagespaceQuota = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.storageType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespaceQuota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storagespaceQuota {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.namespaceQuota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.storagespaceQuota {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetQuotaRequestProto {
    fn new() -> SetQuotaRequestProto {
        SetQuotaRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetQuotaRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    SetQuotaRequestProto::get_path_for_reflect,
                    SetQuotaRequestProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "namespaceQuota",
                    SetQuotaRequestProto::get_namespaceQuota_for_reflect,
                    SetQuotaRequestProto::mut_namespaceQuota_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "storagespaceQuota",
                    SetQuotaRequestProto::get_storagespaceQuota_for_reflect,
                    SetQuotaRequestProto::mut_storagespaceQuota_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                    "storageType",
                    SetQuotaRequestProto::get_storageType_for_reflect,
                    SetQuotaRequestProto::mut_storageType_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaRequestProto>(
                    "SetQuotaRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetQuotaRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_namespaceQuota();
        self.clear_storagespaceQuota();
        self.clear_storageType();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetQuotaResponseProto {}

impl SetQuotaResponseProto {
    pub fn new() -> SetQuotaResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetQuotaResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaResponseProto,
        };
        unsafe {
            instance.get(SetQuotaResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetQuotaResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetQuotaResponseProto {
    fn new() -> SetQuotaResponseProto {
        SetQuotaResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetQuotaResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaResponseProto>(
                    "SetQuotaResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetQuotaResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    client: ::protobuf::SingularField<::std::string::String>,
    lastBlockLength: ::std::option::Option<i64>,
    fileId: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FsyncRequestProto {}

impl FsyncRequestProto {
    pub fn new() -> FsyncRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FsyncRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncRequestProto,
        };
        unsafe {
            instance.get(FsyncRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required string client = 2;

    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        if self.client.is_none() {
            self.client.set_default();
        }
        self.client.as_mut().unwrap()
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        self.client.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_client(&self) -> &str {
        match self.client.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_client_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.client
    }

    fn mut_client_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.client
    }

    // optional sint64 lastBlockLength = 3;

    pub fn clear_lastBlockLength(&mut self) {
        self.lastBlockLength = ::std::option::Option::None;
    }

    pub fn has_lastBlockLength(&self) -> bool {
        self.lastBlockLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockLength(&mut self, v: i64) {
        self.lastBlockLength = ::std::option::Option::Some(v);
    }

    pub fn get_lastBlockLength(&self) -> i64 {
        self.lastBlockLength.unwrap_or(-1i64)
    }

    fn get_lastBlockLength_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.lastBlockLength
    }

    fn mut_lastBlockLength_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.lastBlockLength
    }

    // optional uint64 fileId = 4;

    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }

    fn get_fileId_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fileId
    }

    fn mut_fileId_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fileId
    }
}

impl ::protobuf::Message for FsyncRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.client.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lastBlockLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.client.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastBlockLength {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.client.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lastBlockLength {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FsyncRequestProto {
    fn new() -> FsyncRequestProto {
        FsyncRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FsyncRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    FsyncRequestProto::get_src_for_reflect,
                    FsyncRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client",
                    FsyncRequestProto::get_client_for_reflect,
                    FsyncRequestProto::mut_client_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "lastBlockLength",
                    FsyncRequestProto::get_lastBlockLength_for_reflect,
                    FsyncRequestProto::mut_lastBlockLength_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    FsyncRequestProto::get_fileId_for_reflect,
                    FsyncRequestProto::mut_fileId_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FsyncRequestProto>(
                    "FsyncRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FsyncRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_client();
        self.clear_lastBlockLength();
        self.clear_fileId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FsyncResponseProto {}

impl FsyncResponseProto {
    pub fn new() -> FsyncResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FsyncResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncResponseProto,
        };
        unsafe {
            instance.get(FsyncResponseProto::new)
        }
    }
}

impl ::protobuf::Message for FsyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FsyncResponseProto {
    fn new() -> FsyncResponseProto {
        FsyncResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<FsyncResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FsyncResponseProto>(
                    "FsyncResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FsyncResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    mtime: ::std::option::Option<u64>,
    atime: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetTimesRequestProto {}

impl SetTimesRequestProto {
    pub fn new() -> SetTimesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetTimesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesRequestProto,
        };
        unsafe {
            instance.get(SetTimesRequestProto::new)
        }
    }

    // required string src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_src_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.src
    }

    fn mut_src_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.src
    }

    // required uint64 mtime = 2;

    pub fn clear_mtime(&mut self) {
        self.mtime = ::std::option::Option::None;
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = ::std::option::Option::Some(v);
    }

    pub fn get_mtime(&self) -> u64 {
        self.mtime.unwrap_or(0)
    }

    fn get_mtime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.mtime
    }

    fn mut_mtime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.mtime
    }

    // required uint64 atime = 3;

    pub fn clear_atime(&mut self) {
        self.atime = ::std::option::Option::None;
    }

    pub fn has_atime(&self) -> bool {
        self.atime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_atime(&mut self, v: u64) {
        self.atime = ::std::option::Option::Some(v);
    }

    pub fn get_atime(&self) -> u64 {
        self.atime.unwrap_or(0)
    }

    fn get_atime_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.atime
    }

    fn mut_atime_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.atime
    }
}

impl ::protobuf::Message for SetTimesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.mtime.is_none() {
            return false;
        }
        if self.atime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.atime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.atime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mtime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.atime {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetTimesRequestProto {
    fn new() -> SetTimesRequestProto {
        SetTimesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetTimesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    SetTimesRequestProto::get_src_for_reflect,
                    SetTimesRequestProto::mut_src_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mtime",
                    SetTimesRequestProto::get_mtime_for_reflect,
                    SetTimesRequestProto::mut_mtime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "atime",
                    SetTimesRequestProto::get_atime_for_reflect,
                    SetTimesRequestProto::mut_atime_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesRequestProto>(
                    "SetTimesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetTimesRequestProto {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_mtime();
        self.clear_atime();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetTimesResponseProto {}

impl SetTimesResponseProto {
    pub fn new() -> SetTimesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetTimesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesResponseProto,
        };
        unsafe {
            instance.get(SetTimesResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetTimesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetTimesResponseProto {
    fn new() -> SetTimesResponseProto {
        SetTimesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetTimesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesResponseProto>(
                    "SetTimesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetTimesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkRequestProto {
    // message fields
    target: ::protobuf::SingularField<::std::string::String>,
    link: ::protobuf::SingularField<::std::string::String>,
    dirPerm: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSymlinkRequestProto {}

impl CreateSymlinkRequestProto {
    pub fn new() -> CreateSymlinkRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSymlinkRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkRequestProto,
        };
        unsafe {
            instance.get(CreateSymlinkRequestProto::new)
        }
    }

    // required string target = 1;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_target_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.target
    }

    fn mut_target_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.target
    }

    // required string link = 2;

    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut ::std::string::String {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        self.link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_link(&self) -> &str {
        match self.link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_link_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.link
    }

    fn mut_link_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.link
    }

    // required .hadoop.hdfs.FsPermissionProto dirPerm = 3;

    pub fn clear_dirPerm(&mut self) {
        self.dirPerm.clear();
    }

    pub fn has_dirPerm(&self) -> bool {
        self.dirPerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirPerm(&mut self, v: super::acl::FsPermissionProto) {
        self.dirPerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirPerm(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.dirPerm.is_none() {
            self.dirPerm.set_default();
        }
        self.dirPerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirPerm(&mut self) -> super::acl::FsPermissionProto {
        self.dirPerm.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    pub fn get_dirPerm(&self) -> &super::acl::FsPermissionProto {
        self.dirPerm.as_ref().unwrap_or_else(|| super::acl::FsPermissionProto::default_instance())
    }

    fn get_dirPerm_for_reflect(&self) -> &::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &self.dirPerm
    }

    fn mut_dirPerm_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::acl::FsPermissionProto> {
        &mut self.dirPerm
    }

    // required bool createParent = 4;

    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }

    fn get_createParent_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.createParent
    }

    fn mut_createParent_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.createParent
    }
}

impl ::protobuf::Message for CreateSymlinkRequestProto {
    fn is_initialized(&self) -> bool {
        if self.target.is_none() {
            return false;
        }
        if self.link.is_none() {
            return false;
        }
        if self.dirPerm.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.dirPerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirPerm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSymlinkRequestProto {
    fn new() -> CreateSymlinkRequestProto {
        CreateSymlinkRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSymlinkRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    CreateSymlinkRequestProto::get_target_for_reflect,
                    CreateSymlinkRequestProto::mut_target_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "link",
                    CreateSymlinkRequestProto::get_link_for_reflect,
                    CreateSymlinkRequestProto::mut_link_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                    "dirPerm",
                    CreateSymlinkRequestProto::get_dirPerm_for_reflect,
                    CreateSymlinkRequestProto::mut_dirPerm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    CreateSymlinkRequestProto::get_createParent_for_reflect,
                    CreateSymlinkRequestProto::mut_createParent_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkRequestProto>(
                    "CreateSymlinkRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkRequestProto {
    fn clear(&mut self) {
        self.clear_target();
        self.clear_link();
        self.clear_dirPerm();
        self.clear_createParent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSymlinkResponseProto {}

impl CreateSymlinkResponseProto {
    pub fn new() -> CreateSymlinkResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSymlinkResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkResponseProto,
        };
        unsafe {
            instance.get(CreateSymlinkResponseProto::new)
        }
    }
}

impl ::protobuf::Message for CreateSymlinkResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSymlinkResponseProto {
    fn new() -> CreateSymlinkResponseProto {
        CreateSymlinkResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSymlinkResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkResponseProto>(
                    "CreateSymlinkResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetLinkTargetRequestProto {}

impl GetLinkTargetRequestProto {
    pub fn new() -> GetLinkTargetRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetLinkTargetRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetRequestProto,
        };
        unsafe {
            instance.get(GetLinkTargetRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for GetLinkTargetRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetLinkTargetRequestProto {
    fn new() -> GetLinkTargetRequestProto {
        GetLinkTargetRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetLinkTargetRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GetLinkTargetRequestProto::get_path_for_reflect,
                    GetLinkTargetRequestProto::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetRequestProto>(
                    "GetLinkTargetRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetResponseProto {
    // message fields
    targetPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetLinkTargetResponseProto {}

impl GetLinkTargetResponseProto {
    pub fn new() -> GetLinkTargetResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetLinkTargetResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetResponseProto,
        };
        unsafe {
            instance.get(GetLinkTargetResponseProto::new)
        }
    }

    // optional string targetPath = 1;

    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::string::String) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::string::String {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::string::String {
        self.targetPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_targetPath(&self) -> &str {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_targetPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.targetPath
    }

    fn mut_targetPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.targetPath
    }
}

impl ::protobuf::Message for GetLinkTargetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetLinkTargetResponseProto {
    fn new() -> GetLinkTargetResponseProto {
        GetLinkTargetResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetLinkTargetResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetPath",
                    GetLinkTargetResponseProto::get_targetPath_for_reflect,
                    GetLinkTargetResponseProto::mut_targetPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetResponseProto>(
                    "GetLinkTargetResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetResponseProto {
    fn clear(&mut self) {
        self.clear_targetPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineRequestProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdateBlockForPipelineRequestProto {}

impl UpdateBlockForPipelineRequestProto {
    pub fn new() -> UpdateBlockForPipelineRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdateBlockForPipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineRequestProto,
        };
        unsafe {
            instance.get(UpdateBlockForPipelineRequestProto::new)
        }
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.block
    }

    // required string clientName = 2;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdateBlockForPipelineRequestProto {
    fn new() -> UpdateBlockForPipelineRequestProto {
        UpdateBlockForPipelineRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdateBlockForPipelineRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "block",
                    UpdateBlockForPipelineRequestProto::get_block_for_reflect,
                    UpdateBlockForPipelineRequestProto::mut_block_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    UpdateBlockForPipelineRequestProto::get_clientName_for_reflect,
                    UpdateBlockForPipelineRequestProto::mut_clientName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineRequestProto>(
                    "UpdateBlockForPipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineRequestProto {
    fn clear(&mut self) {
        self.clear_block();
        self.clear_clientName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdateBlockForPipelineResponseProto {}

impl UpdateBlockForPipelineResponseProto {
    pub fn new() -> UpdateBlockForPipelineResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdateBlockForPipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineResponseProto,
        };
        unsafe {
            instance.get(UpdateBlockForPipelineResponseProto::new)
        }
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }

    fn get_block_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &self.block
    }

    fn mut_block_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto> {
        &mut self.block
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdateBlockForPipelineResponseProto {
    fn new() -> UpdateBlockForPipelineResponseProto {
        UpdateBlockForPipelineResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdateBlockForPipelineResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    UpdateBlockForPipelineResponseProto::get_block_for_reflect,
                    UpdateBlockForPipelineResponseProto::mut_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineResponseProto>(
                    "UpdateBlockForPipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineResponseProto {
    fn clear(&mut self) {
        self.clear_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    oldBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>,
    storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdatePipelineRequestProto {}

impl UpdatePipelineRequestProto {
    pub fn new() -> UpdatePipelineRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdatePipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineRequestProto,
        };
        unsafe {
            instance.get(UpdatePipelineRequestProto::new)
        }
    }

    // required string clientName = 1;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // required .hadoop.hdfs.ExtendedBlockProto oldBlock = 2;

    pub fn clear_oldBlock(&mut self) {
        self.oldBlock.clear();
    }

    pub fn has_oldBlock(&self) -> bool {
        self.oldBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.oldBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.oldBlock.is_none() {
            self.oldBlock.set_default();
        }
        self.oldBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.oldBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_oldBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.oldBlock.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_oldBlock_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.oldBlock
    }

    fn mut_oldBlock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.oldBlock
    }

    // required .hadoop.hdfs.ExtendedBlockProto newBlock = 3;

    pub fn clear_newBlock(&mut self) {
        self.newBlock.clear();
    }

    pub fn has_newBlock(&self) -> bool {
        self.newBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.newBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.newBlock.is_none() {
            self.newBlock.set_default();
        }
        self.newBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_newBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.newBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    pub fn get_newBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.newBlock.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }

    fn get_newBlock_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &self.newBlock
    }

    fn mut_newBlock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto> {
        &mut self.newBlock
    }

    // repeated .hadoop.hdfs.DatanodeIDProto newNodes = 4;

    pub fn clear_newNodes(&mut self) {
        self.newNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_newNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>) {
        self.newNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newNodes
    }

    // Take field
    pub fn take_newNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        ::std::mem::replace(&mut self.newNodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_newNodes(&self) -> &[super::hdfs::DatanodeIDProto] {
        &self.newNodes
    }

    fn get_newNodes_for_reflect(&self) -> &::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &self.newNodes
    }

    fn mut_newNodes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newNodes
    }

    // repeated string storageIDs = 5;

    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }

    pub fn get_storageIDs(&self) -> &[::std::string::String] {
        &self.storageIDs
    }

    fn get_storageIDs_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.storageIDs
    }

    fn mut_storageIDs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }
}

impl ::protobuf::Message for UpdatePipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        if self.oldBlock.is_none() {
            return false;
        }
        if self.newBlock.is_none() {
            return false;
        }
        for v in &self.oldBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oldBlock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newBlock)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.newNodes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.newNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.storageIDs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.newNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.storageIDs {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdatePipelineRequestProto {
    fn new() -> UpdatePipelineRequestProto {
        UpdatePipelineRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdatePipelineRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    UpdatePipelineRequestProto::get_clientName_for_reflect,
                    UpdatePipelineRequestProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "oldBlock",
                    UpdatePipelineRequestProto::get_oldBlock_for_reflect,
                    UpdatePipelineRequestProto::mut_oldBlock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "newBlock",
                    UpdatePipelineRequestProto::get_newBlock_for_reflect,
                    UpdatePipelineRequestProto::mut_newBlock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                    "newNodes",
                    UpdatePipelineRequestProto::get_newNodes_for_reflect,
                    UpdatePipelineRequestProto::mut_newNodes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageIDs",
                    UpdatePipelineRequestProto::get_storageIDs_for_reflect,
                    UpdatePipelineRequestProto::mut_storageIDs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineRequestProto>(
                    "UpdatePipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineRequestProto {
    fn clear(&mut self) {
        self.clear_clientName();
        self.clear_oldBlock();
        self.clear_newBlock();
        self.clear_newNodes();
        self.clear_storageIDs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UpdatePipelineResponseProto {}

impl UpdatePipelineResponseProto {
    pub fn new() -> UpdatePipelineResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UpdatePipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineResponseProto,
        };
        unsafe {
            instance.get(UpdatePipelineResponseProto::new)
        }
    }
}

impl ::protobuf::Message for UpdatePipelineResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UpdatePipelineResponseProto {
    fn new() -> UpdatePipelineResponseProto {
        UpdatePipelineResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<UpdatePipelineResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineResponseProto>(
                    "UpdatePipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthRequestProto {
    // message fields
    bandwidth: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetBalancerBandwidthRequestProto {}

impl SetBalancerBandwidthRequestProto {
    pub fn new() -> SetBalancerBandwidthRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetBalancerBandwidthRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthRequestProto,
        };
        unsafe {
            instance.get(SetBalancerBandwidthRequestProto::new)
        }
    }

    // required int64 bandwidth = 1;

    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: i64) {
        self.bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_bandwidth(&self) -> i64 {
        self.bandwidth.unwrap_or(0)
    }

    fn get_bandwidth_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.bandwidth
    }

    fn mut_bandwidth_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.bandwidth
    }
}

impl ::protobuf::Message for SetBalancerBandwidthRequestProto {
    fn is_initialized(&self) -> bool {
        if self.bandwidth.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bandwidth {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetBalancerBandwidthRequestProto {
    fn new() -> SetBalancerBandwidthRequestProto {
        SetBalancerBandwidthRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetBalancerBandwidthRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bandwidth",
                    SetBalancerBandwidthRequestProto::get_bandwidth_for_reflect,
                    SetBalancerBandwidthRequestProto::mut_bandwidth_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthRequestProto>(
                    "SetBalancerBandwidthRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthRequestProto {
    fn clear(&mut self) {
        self.clear_bandwidth();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetBalancerBandwidthResponseProto {}

impl SetBalancerBandwidthResponseProto {
    pub fn new() -> SetBalancerBandwidthResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetBalancerBandwidthResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthResponseProto,
        };
        unsafe {
            instance.get(SetBalancerBandwidthResponseProto::new)
        }
    }
}

impl ::protobuf::Message for SetBalancerBandwidthResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetBalancerBandwidthResponseProto {
    fn new() -> SetBalancerBandwidthResponseProto {
        SetBalancerBandwidthResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetBalancerBandwidthResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthResponseProto>(
                    "SetBalancerBandwidthResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDataEncryptionKeyRequestProto {}

impl GetDataEncryptionKeyRequestProto {
    pub fn new() -> GetDataEncryptionKeyRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDataEncryptionKeyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyRequestProto,
        };
        unsafe {
            instance.get(GetDataEncryptionKeyRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDataEncryptionKeyRequestProto {
    fn new() -> GetDataEncryptionKeyRequestProto {
        GetDataEncryptionKeyRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDataEncryptionKeyRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyRequestProto>(
                    "GetDataEncryptionKeyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyResponseProto {
    // message fields
    dataEncryptionKey: ::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetDataEncryptionKeyResponseProto {}

impl GetDataEncryptionKeyResponseProto {
    pub fn new() -> GetDataEncryptionKeyResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetDataEncryptionKeyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyResponseProto,
        };
        unsafe {
            instance.get(GetDataEncryptionKeyResponseProto::new)
        }
    }

    // optional .hadoop.hdfs.DataEncryptionKeyProto dataEncryptionKey = 1;

    pub fn clear_dataEncryptionKey(&mut self) {
        self.dataEncryptionKey.clear();
    }

    pub fn has_dataEncryptionKey(&self) -> bool {
        self.dataEncryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataEncryptionKey(&mut self, v: super::hdfs::DataEncryptionKeyProto) {
        self.dataEncryptionKey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataEncryptionKey(&mut self) -> &mut super::hdfs::DataEncryptionKeyProto {
        if self.dataEncryptionKey.is_none() {
            self.dataEncryptionKey.set_default();
        }
        self.dataEncryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataEncryptionKey(&mut self) -> super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.take().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::new())
    }

    pub fn get_dataEncryptionKey(&self) -> &super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.as_ref().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::default_instance())
    }

    fn get_dataEncryptionKey_for_reflect(&self) -> &::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto> {
        &self.dataEncryptionKey
    }

    fn mut_dataEncryptionKey_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto> {
        &mut self.dataEncryptionKey
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dataEncryptionKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataEncryptionKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetDataEncryptionKeyResponseProto {
    fn new() -> GetDataEncryptionKeyResponseProto {
        GetDataEncryptionKeyResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetDataEncryptionKeyResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DataEncryptionKeyProto>>(
                    "dataEncryptionKey",
                    GetDataEncryptionKeyResponseProto::get_dataEncryptionKey_for_reflect,
                    GetDataEncryptionKeyResponseProto::mut_dataEncryptionKey_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyResponseProto>(
                    "GetDataEncryptionKeyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyResponseProto {
    fn clear(&mut self) {
        self.clear_dataEncryptionKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSnapshotRequestProto {}

impl CreateSnapshotRequestProto {
    pub fn new() -> CreateSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotRequestProto,
        };
        unsafe {
            instance.get(CreateSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // optional string snapshotName = 2;

    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotName
    }

    fn mut_snapshotName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotName
    }
}

impl ::protobuf::Message for CreateSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSnapshotRequestProto {
    fn new() -> CreateSnapshotRequestProto {
        CreateSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    CreateSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    CreateSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    CreateSnapshotRequestProto::get_snapshotName_for_reflect,
                    CreateSnapshotRequestProto::mut_snapshotName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotRequestProto>(
                    "CreateSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotResponseProto {
    // message fields
    snapshotPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateSnapshotResponseProto {}

impl CreateSnapshotResponseProto {
    pub fn new() -> CreateSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotResponseProto,
        };
        unsafe {
            instance.get(CreateSnapshotResponseProto::new)
        }
    }

    // required string snapshotPath = 1;

    pub fn clear_snapshotPath(&mut self) {
        self.snapshotPath.clear();
    }

    pub fn has_snapshotPath(&self) -> bool {
        self.snapshotPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotPath(&mut self, v: ::std::string::String) {
        self.snapshotPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotPath(&mut self) -> &mut ::std::string::String {
        if self.snapshotPath.is_none() {
            self.snapshotPath.set_default();
        }
        self.snapshotPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotPath(&mut self) -> ::std::string::String {
        self.snapshotPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotPath(&self) -> &str {
        match self.snapshotPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotPath
    }

    fn mut_snapshotPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotPath
    }
}

impl ::protobuf::Message for CreateSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotPath.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateSnapshotResponseProto {
    fn new() -> CreateSnapshotResponseProto {
        CreateSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotPath",
                    CreateSnapshotResponseProto::get_snapshotPath_for_reflect,
                    CreateSnapshotResponseProto::mut_snapshotPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotResponseProto>(
                    "CreateSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotResponseProto {
    fn clear(&mut self) {
        self.clear_snapshotPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotOldName: ::protobuf::SingularField<::std::string::String>,
    snapshotNewName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameSnapshotRequestProto {}

impl RenameSnapshotRequestProto {
    pub fn new() -> RenameSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotRequestProto,
        };
        unsafe {
            instance.get(RenameSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // required string snapshotOldName = 2;

    pub fn clear_snapshotOldName(&mut self) {
        self.snapshotOldName.clear();
    }

    pub fn has_snapshotOldName(&self) -> bool {
        self.snapshotOldName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotOldName(&mut self, v: ::std::string::String) {
        self.snapshotOldName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotOldName(&mut self) -> &mut ::std::string::String {
        if self.snapshotOldName.is_none() {
            self.snapshotOldName.set_default();
        }
        self.snapshotOldName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotOldName(&mut self) -> ::std::string::String {
        self.snapshotOldName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotOldName(&self) -> &str {
        match self.snapshotOldName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotOldName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotOldName
    }

    fn mut_snapshotOldName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotOldName
    }

    // required string snapshotNewName = 3;

    pub fn clear_snapshotNewName(&mut self) {
        self.snapshotNewName.clear();
    }

    pub fn has_snapshotNewName(&self) -> bool {
        self.snapshotNewName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotNewName(&mut self, v: ::std::string::String) {
        self.snapshotNewName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotNewName(&mut self) -> &mut ::std::string::String {
        if self.snapshotNewName.is_none() {
            self.snapshotNewName.set_default();
        }
        self.snapshotNewName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotNewName(&mut self) -> ::std::string::String {
        self.snapshotNewName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotNewName(&self) -> &str {
        match self.snapshotNewName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotNewName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotNewName
    }

    fn mut_snapshotNewName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotNewName
    }
}

impl ::protobuf::Message for RenameSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotOldName.is_none() {
            return false;
        }
        if self.snapshotNewName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotOldName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotNewName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameSnapshotRequestProto {
    fn new() -> RenameSnapshotRequestProto {
        RenameSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    RenameSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    RenameSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotOldName",
                    RenameSnapshotRequestProto::get_snapshotOldName_for_reflect,
                    RenameSnapshotRequestProto::mut_snapshotOldName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotNewName",
                    RenameSnapshotRequestProto::get_snapshotNewName_for_reflect,
                    RenameSnapshotRequestProto::mut_snapshotNewName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotRequestProto>(
                    "RenameSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotOldName();
        self.clear_snapshotNewName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameSnapshotResponseProto {}

impl RenameSnapshotResponseProto {
    pub fn new() -> RenameSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotResponseProto,
        };
        unsafe {
            instance.get(RenameSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for RenameSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameSnapshotResponseProto {
    fn new() -> RenameSnapshotResponseProto {
        RenameSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotResponseProto>(
                    "RenameSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AllowSnapshotRequestProto {}

impl AllowSnapshotRequestProto {
    pub fn new() -> AllowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AllowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotRequestProto,
        };
        unsafe {
            instance.get(AllowSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }
}

impl ::protobuf::Message for AllowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AllowSnapshotRequestProto {
    fn new() -> AllowSnapshotRequestProto {
        AllowSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AllowSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    AllowSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    AllowSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotRequestProto>(
                    "AllowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AllowSnapshotResponseProto {}

impl AllowSnapshotResponseProto {
    pub fn new() -> AllowSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AllowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotResponseProto,
        };
        unsafe {
            instance.get(AllowSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for AllowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AllowSnapshotResponseProto {
    fn new() -> AllowSnapshotResponseProto {
        AllowSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<AllowSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotResponseProto>(
                    "AllowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DisallowSnapshotRequestProto {}

impl DisallowSnapshotRequestProto {
    pub fn new() -> DisallowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisallowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotRequestProto,
        };
        unsafe {
            instance.get(DisallowSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }
}

impl ::protobuf::Message for DisallowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisallowSnapshotRequestProto {
    fn new() -> DisallowSnapshotRequestProto {
        DisallowSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisallowSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    DisallowSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    DisallowSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotRequestProto>(
                    "DisallowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DisallowSnapshotResponseProto {}

impl DisallowSnapshotResponseProto {
    pub fn new() -> DisallowSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisallowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotResponseProto,
        };
        unsafe {
            instance.get(DisallowSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for DisallowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisallowSnapshotResponseProto {
    fn new() -> DisallowSnapshotResponseProto {
        DisallowSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisallowSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotResponseProto>(
                    "DisallowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteSnapshotRequestProto {}

impl DeleteSnapshotRequestProto {
    pub fn new() -> DeleteSnapshotRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotRequestProto,
        };
        unsafe {
            instance.get(DeleteSnapshotRequestProto::new)
        }
    }

    // required string snapshotRoot = 1;

    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotRoot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotRoot
    }

    fn mut_snapshotRoot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotRoot
    }

    // required string snapshotName = 2;

    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_snapshotName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.snapshotName
    }

    fn mut_snapshotName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.snapshotName
    }
}

impl ::protobuf::Message for DeleteSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteSnapshotRequestProto {
    fn new() -> DeleteSnapshotRequestProto {
        DeleteSnapshotRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteSnapshotRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    DeleteSnapshotRequestProto::get_snapshotRoot_for_reflect,
                    DeleteSnapshotRequestProto::mut_snapshotRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    DeleteSnapshotRequestProto::get_snapshotName_for_reflect,
                    DeleteSnapshotRequestProto::mut_snapshotName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotRequestProto>(
                    "DeleteSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequestProto {
    fn clear(&mut self) {
        self.clear_snapshotRoot();
        self.clear_snapshotName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteSnapshotResponseProto {}

impl DeleteSnapshotResponseProto {
    pub fn new() -> DeleteSnapshotResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotResponseProto,
        };
        unsafe {
            instance.get(DeleteSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Message for DeleteSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteSnapshotResponseProto {
    fn new() -> DeleteSnapshotResponseProto {
        DeleteSnapshotResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteSnapshotResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotResponseProto>(
                    "DeleteSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<super::acl::AclEntryProto_FsActionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckAccessRequestProto {}

impl CheckAccessRequestProto {
    pub fn new() -> CheckAccessRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckAccessRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessRequestProto,
        };
        unsafe {
            instance.get(CheckAccessRequestProto::new)
        }
    }

    // required string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // required .hadoop.hdfs.AclEntryProto.FsActionProto mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::acl::AclEntryProto_FsActionProto) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> super::acl::AclEntryProto_FsActionProto {
        self.mode.unwrap_or(super::acl::AclEntryProto_FsActionProto::NONE)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<super::acl::AclEntryProto_FsActionProto> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<super::acl::AclEntryProto_FsActionProto> {
        &mut self.mode
    }
}

impl ::protobuf::Message for CheckAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckAccessRequestProto {
    fn new() -> CheckAccessRequestProto {
        CheckAccessRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckAccessRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CheckAccessRequestProto::get_path_for_reflect,
                    CheckAccessRequestProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::acl::AclEntryProto_FsActionProto>>(
                    "mode",
                    CheckAccessRequestProto::get_mode_for_reflect,
                    CheckAccessRequestProto::mut_mode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessRequestProto>(
                    "CheckAccessRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckAccessRequestProto {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessResponseProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CheckAccessResponseProto {}

impl CheckAccessResponseProto {
    pub fn new() -> CheckAccessResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CheckAccessResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessResponseProto,
        };
        unsafe {
            instance.get(CheckAccessResponseProto::new)
        }
    }
}

impl ::protobuf::Message for CheckAccessResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CheckAccessResponseProto {
    fn new() -> CheckAccessResponseProto {
        CheckAccessResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<CheckAccessResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessResponseProto>(
                    "CheckAccessResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CheckAccessResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidRequestProto {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetCurrentEditLogTxidRequestProto {}

impl GetCurrentEditLogTxidRequestProto {
    pub fn new() -> GetCurrentEditLogTxidRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetCurrentEditLogTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidRequestProto,
        };
        unsafe {
            instance.get(GetCurrentEditLogTxidRequestProto::new)
        }
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetCurrentEditLogTxidRequestProto {
    fn new() -> GetCurrentEditLogTxidRequestProto {
        GetCurrentEditLogTxidRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetCurrentEditLogTxidRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidRequestProto>(
                    "GetCurrentEditLogTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidResponseProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetCurrentEditLogTxidResponseProto {}

impl GetCurrentEditLogTxidResponseProto {
    pub fn new() -> GetCurrentEditLogTxidResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetCurrentEditLogTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidResponseProto,
        };
        unsafe {
            instance.get(GetCurrentEditLogTxidResponseProto::new)
        }
    }

    // required int64 txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }

    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }

    fn get_txid_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.txid
    }

    fn mut_txid_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.txid
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetCurrentEditLogTxidResponseProto {
    fn new() -> GetCurrentEditLogTxidResponseProto {
        GetCurrentEditLogTxidResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetCurrentEditLogTxidResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "txid",
                    GetCurrentEditLogTxidResponseProto::get_txid_for_reflect,
                    GetCurrentEditLogTxidResponseProto::mut_txid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidResponseProto>(
                    "GetCurrentEditLogTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidResponseProto {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidRequestProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetEditsFromTxidRequestProto {}

impl GetEditsFromTxidRequestProto {
    pub fn new() -> GetEditsFromTxidRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetEditsFromTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidRequestProto,
        };
        unsafe {
            instance.get(GetEditsFromTxidRequestProto::new)
        }
    }

    // required int64 txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }

    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }

    fn get_txid_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.txid
    }

    fn mut_txid_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.txid
    }
}

impl ::protobuf::Message for GetEditsFromTxidRequestProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetEditsFromTxidRequestProto {
    fn new() -> GetEditsFromTxidRequestProto {
        GetEditsFromTxidRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetEditsFromTxidRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "txid",
                    GetEditsFromTxidRequestProto::get_txid_for_reflect,
                    GetEditsFromTxidRequestProto::mut_txid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidRequestProto>(
                    "GetEditsFromTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidRequestProto {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidResponseProto {
    // message fields
    eventsList: ::protobuf::SingularPtrField<super::inotify::EventsListProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetEditsFromTxidResponseProto {}

impl GetEditsFromTxidResponseProto {
    pub fn new() -> GetEditsFromTxidResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetEditsFromTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidResponseProto,
        };
        unsafe {
            instance.get(GetEditsFromTxidResponseProto::new)
        }
    }

    // required .hadoop.hdfs.EventsListProto eventsList = 1;

    pub fn clear_eventsList(&mut self) {
        self.eventsList.clear();
    }

    pub fn has_eventsList(&self) -> bool {
        self.eventsList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsList(&mut self, v: super::inotify::EventsListProto) {
        self.eventsList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventsList(&mut self) -> &mut super::inotify::EventsListProto {
        if self.eventsList.is_none() {
            self.eventsList.set_default();
        }
        self.eventsList.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventsList(&mut self) -> super::inotify::EventsListProto {
        self.eventsList.take().unwrap_or_else(|| super::inotify::EventsListProto::new())
    }

    pub fn get_eventsList(&self) -> &super::inotify::EventsListProto {
        self.eventsList.as_ref().unwrap_or_else(|| super::inotify::EventsListProto::default_instance())
    }

    fn get_eventsList_for_reflect(&self) -> &::protobuf::SingularPtrField<super::inotify::EventsListProto> {
        &self.eventsList
    }

    fn mut_eventsList_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::inotify::EventsListProto> {
        &mut self.eventsList
    }
}

impl ::protobuf::Message for GetEditsFromTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.eventsList.is_none() {
            return false;
        }
        for v in &self.eventsList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventsList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventsList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventsList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetEditsFromTxidResponseProto {
    fn new() -> GetEditsFromTxidResponseProto {
        GetEditsFromTxidResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetEditsFromTxidResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::inotify::EventsListProto>>(
                    "eventsList",
                    GetEditsFromTxidResponseProto::get_eventsList_for_reflect,
                    GetEditsFromTxidResponseProto::mut_eventsList_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidResponseProto>(
                    "GetEditsFromTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidResponseProto {
    fn clear(&mut self) {
        self.clear_eventsList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOpenFilesRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListOpenFilesRequestProto {}

impl ListOpenFilesRequestProto {
    pub fn new() -> ListOpenFilesRequestProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListOpenFilesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListOpenFilesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListOpenFilesRequestProto,
        };
        unsafe {
            instance.get(ListOpenFilesRequestProto::new)
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }
}

impl ::protobuf::Message for ListOpenFilesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListOpenFilesRequestProto {
    fn new() -> ListOpenFilesRequestProto {
        ListOpenFilesRequestProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListOpenFilesRequestProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    ListOpenFilesRequestProto::get_id_for_reflect,
                    ListOpenFilesRequestProto::mut_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListOpenFilesRequestProto>(
                    "ListOpenFilesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListOpenFilesRequestProto {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOpenFilesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenFilesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenFilesBatchResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    clientMachine: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OpenFilesBatchResponseProto {}

impl OpenFilesBatchResponseProto {
    pub fn new() -> OpenFilesBatchResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OpenFilesBatchResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<OpenFilesBatchResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenFilesBatchResponseProto,
        };
        unsafe {
            instance.get(OpenFilesBatchResponseProto::new)
        }
    }

    // required int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.id
    }

    // required string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // required string clientName = 3;

    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientName
    }

    fn mut_clientName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientName
    }

    // required string clientMachine = 4;

    pub fn clear_clientMachine(&mut self) {
        self.clientMachine.clear();
    }

    pub fn has_clientMachine(&self) -> bool {
        self.clientMachine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientMachine(&mut self, v: ::std::string::String) {
        self.clientMachine = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientMachine(&mut self) -> &mut ::std::string::String {
        if self.clientMachine.is_none() {
            self.clientMachine.set_default();
        }
        self.clientMachine.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientMachine(&mut self) -> ::std::string::String {
        self.clientMachine.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clientMachine(&self) -> &str {
        match self.clientMachine.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clientMachine_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clientMachine
    }

    fn mut_clientMachine_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clientMachine
    }
}

impl ::protobuf::Message for OpenFilesBatchResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        if self.clientMachine.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientMachine)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.clientMachine.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.clientMachine.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OpenFilesBatchResponseProto {
    fn new() -> OpenFilesBatchResponseProto {
        OpenFilesBatchResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<OpenFilesBatchResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    OpenFilesBatchResponseProto::get_id_for_reflect,
                    OpenFilesBatchResponseProto::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    OpenFilesBatchResponseProto::get_path_for_reflect,
                    OpenFilesBatchResponseProto::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    OpenFilesBatchResponseProto::get_clientName_for_reflect,
                    OpenFilesBatchResponseProto::mut_clientName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientMachine",
                    OpenFilesBatchResponseProto::get_clientMachine_for_reflect,
                    OpenFilesBatchResponseProto::mut_clientMachine_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenFilesBatchResponseProto>(
                    "OpenFilesBatchResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OpenFilesBatchResponseProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_path();
        self.clear_clientName();
        self.clear_clientMachine();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenFilesBatchResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFilesBatchResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOpenFilesResponseProto {
    // message fields
    entries: ::protobuf::RepeatedField<OpenFilesBatchResponseProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListOpenFilesResponseProto {}

impl ListOpenFilesResponseProto {
    pub fn new() -> ListOpenFilesResponseProto {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListOpenFilesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListOpenFilesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListOpenFilesResponseProto,
        };
        unsafe {
            instance.get(ListOpenFilesResponseProto::new)
        }
    }

    // repeated .hadoop.hdfs.OpenFilesBatchResponseProto entries = 1;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<OpenFilesBatchResponseProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<OpenFilesBatchResponseProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<OpenFilesBatchResponseProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[OpenFilesBatchResponseProto] {
        &self.entries
    }

    fn get_entries_for_reflect(&self) -> &::protobuf::RepeatedField<OpenFilesBatchResponseProto> {
        &self.entries
    }

    fn mut_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<OpenFilesBatchResponseProto> {
        &mut self.entries
    }

    // required bool hasMore = 2;

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    fn get_hasMore_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hasMore
    }

    fn mut_hasMore_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hasMore
    }
}

impl ::protobuf::Message for ListOpenFilesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListOpenFilesResponseProto {
    fn new() -> ListOpenFilesResponseProto {
        ListOpenFilesResponseProto::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListOpenFilesResponseProto>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpenFilesBatchResponseProto>>(
                    "entries",
                    ListOpenFilesResponseProto::get_entries_for_reflect,
                    ListOpenFilesResponseProto::mut_entries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    ListOpenFilesResponseProto::get_hasMore_for_reflect,
                    ListOpenFilesResponseProto::mut_hasMore_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListOpenFilesResponseProto>(
                    "ListOpenFilesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListOpenFilesResponseProto {
    fn clear(&mut self) {
        self.clear_entries();
        self.clear_hasMore();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOpenFilesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenFilesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateFlagProto {
    CREATE = 1,
    OVERWRITE = 2,
    APPEND = 4,
    LAZY_PERSIST = 16,
    NEW_BLOCK = 32,
    SHOULD_REPLICATE = 128,
}

impl ::protobuf::ProtobufEnum for CreateFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CreateFlagProto::CREATE),
            2 => ::std::option::Option::Some(CreateFlagProto::OVERWRITE),
            4 => ::std::option::Option::Some(CreateFlagProto::APPEND),
            16 => ::std::option::Option::Some(CreateFlagProto::LAZY_PERSIST),
            32 => ::std::option::Option::Some(CreateFlagProto::NEW_BLOCK),
            128 => ::std::option::Option::Some(CreateFlagProto::SHOULD_REPLICATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateFlagProto] = &[
            CreateFlagProto::CREATE,
            CreateFlagProto::OVERWRITE,
            CreateFlagProto::APPEND,
            CreateFlagProto::LAZY_PERSIST,
            CreateFlagProto::NEW_BLOCK,
            CreateFlagProto::SHOULD_REPLICATE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CreateFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CreateFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CreateFlagProto {
}

impl ::protobuf::reflect::ProtobufValue for CreateFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddBlockFlagProto {
    NO_LOCAL_WRITE = 1,
}

impl ::protobuf::ProtobufEnum for AddBlockFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddBlockFlagProto> {
        match value {
            1 => ::std::option::Option::Some(AddBlockFlagProto::NO_LOCAL_WRITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddBlockFlagProto] = &[
            AddBlockFlagProto::NO_LOCAL_WRITE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<AddBlockFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AddBlockFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AddBlockFlagProto {
}

impl ::protobuf::reflect::ProtobufValue for AddBlockFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeReportTypeProto {
    ALL = 1,
    LIVE = 2,
    DEAD = 3,
    DECOMMISSIONING = 4,
    ENTERING_MAINTENANCE = 5,
    IN_MAINTENANCE = 6,
}

impl ::protobuf::ProtobufEnum for DatanodeReportTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeReportTypeProto> {
        match value {
            1 => ::std::option::Option::Some(DatanodeReportTypeProto::ALL),
            2 => ::std::option::Option::Some(DatanodeReportTypeProto::LIVE),
            3 => ::std::option::Option::Some(DatanodeReportTypeProto::DEAD),
            4 => ::std::option::Option::Some(DatanodeReportTypeProto::DECOMMISSIONING),
            5 => ::std::option::Option::Some(DatanodeReportTypeProto::ENTERING_MAINTENANCE),
            6 => ::std::option::Option::Some(DatanodeReportTypeProto::IN_MAINTENANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeReportTypeProto] = &[
            DatanodeReportTypeProto::ALL,
            DatanodeReportTypeProto::LIVE,
            DatanodeReportTypeProto::DEAD,
            DatanodeReportTypeProto::DECOMMISSIONING,
            DatanodeReportTypeProto::ENTERING_MAINTENANCE,
            DatanodeReportTypeProto::IN_MAINTENANCE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DatanodeReportTypeProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DatanodeReportTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatanodeReportTypeProto {
}

impl ::protobuf::reflect::ProtobufValue for DatanodeReportTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SafeModeActionProto {
    SAFEMODE_LEAVE = 1,
    SAFEMODE_ENTER = 2,
    SAFEMODE_GET = 3,
    SAFEMODE_FORCE_EXIT = 4,
}

impl ::protobuf::ProtobufEnum for SafeModeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafeModeActionProto> {
        match value {
            1 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_LEAVE),
            2 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_ENTER),
            3 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_GET),
            4 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_FORCE_EXIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SafeModeActionProto] = &[
            SafeModeActionProto::SAFEMODE_LEAVE,
            SafeModeActionProto::SAFEMODE_ENTER,
            SafeModeActionProto::SAFEMODE_GET,
            SafeModeActionProto::SAFEMODE_FORCE_EXIT,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<SafeModeActionProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SafeModeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SafeModeActionProto {
}

impl ::protobuf::reflect::ProtobufValue for SafeModeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RollingUpgradeActionProto {
    QUERY = 1,
    START = 2,
    FINALIZE = 3,
}

impl ::protobuf::ProtobufEnum for RollingUpgradeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RollingUpgradeActionProto> {
        match value {
            1 => ::std::option::Option::Some(RollingUpgradeActionProto::QUERY),
            2 => ::std::option::Option::Some(RollingUpgradeActionProto::START),
            3 => ::std::option::Option::Some(RollingUpgradeActionProto::FINALIZE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RollingUpgradeActionProto] = &[
            RollingUpgradeActionProto::QUERY,
            RollingUpgradeActionProto::START,
            RollingUpgradeActionProto::FINALIZE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<RollingUpgradeActionProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RollingUpgradeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RollingUpgradeActionProto {
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CacheFlagProto {
    FORCE = 1,
}

impl ::protobuf::ProtobufEnum for CacheFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CacheFlagProto::FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CacheFlagProto] = &[
            CacheFlagProto::FORCE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CacheFlagProto>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CacheFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CacheFlagProto {
}

impl ::protobuf::reflect::ProtobufValue for CacheFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cClientNamenodeProtocol.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.pr\
    oto\x1a\nhdfs.proto\x1a\tacl.proto\x1a\x0bxattr.proto\x1a\x10encryption.\
    proto\x1a\rinotify.proto\x1a\x13erasurecoding.proto\"a\n\x1dGetBlockLoca\
    tionsRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x16\n\
    \x06offset\x18\x02\x20\x02(\x04R\x06offset\x12\x16\n\x06length\x18\x03\
    \x20\x02(\x04R\x06length\"_\n\x1eGetBlockLocationsResponseProto\x12=\n\t\
    locations\x18\x01\x20\x01(\x0b2\x1f.hadoop.hdfs.LocatedBlocksProtoR\tloc\
    ations\"\x1f\n\x1dGetServerDefaultsRequestProto\"l\n\x1eGetServerDefault\
    sResponseProto\x12J\n\x0eserverDefaults\x18\x01\x20\x02(\x0b2\".hadoop.h\
    dfs.FsServerDefaultsProtoR\x0eserverDefaults\"\xc1\x03\n\x12CreateReques\
    tProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x126\n\x06masked\x18\
    \x02\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\x06masked\x12\x1e\
    \n\nclientName\x18\x03\x20\x02(\tR\nclientName\x12\x1e\n\ncreateFlag\x18\
    \x04\x20\x02(\rR\ncreateFlag\x12\"\n\x0ccreateParent\x18\x05\x20\x02(\
    \x08R\x0ccreateParent\x12\x20\n\x0breplication\x18\x06\x20\x02(\rR\x0bre\
    plication\x12\x1c\n\tblockSize\x18\x07\x20\x02(\x04R\tblockSize\x12]\n\
    \x15cryptoProtocolVersion\x18\x08\x20\x03(\x0e2'.hadoop.hdfs.CryptoProto\
    colVersionProtoR\x15cryptoProtocolVersion\x12:\n\x08unmasked\x18\t\x20\
    \x01(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\x08unmasked\x12\"\n\x0cecP\
    olicyName\x18\n\x20\x01(\tR\x0cecPolicyName\"G\n\x13CreateResponseProto\
    \x120\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\
    \x02fs\"Z\n\x12AppendRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\
    \x03src\x12\x1e\n\nclientName\x18\x02\x20\x02(\tR\nclientName\x12\x12\n\
    \x04flag\x18\x03\x20\x01(\rR\x04flag\"\x81\x01\n\x13AppendResponseProto\
    \x124\n\x05block\x18\x01\x20\x01(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\
    R\x05block\x124\n\x04stat\x18\x02\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsFile\
    StatusProtoR\x04stat\"P\n\x1aSetReplicationRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12\x20\n\x0breplication\x18\x02\x20\x02(\rR\
    \x0breplication\"5\n\x1bSetReplicationResponseProto\x12\x16\n\x06result\
    \x18\x01\x20\x02(\x08R\x06result\"P\n\x1cSetStoragePolicyRequestProto\
    \x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\npolicyName\x18\
    \x02\x20\x02(\tR\npolicyName\"\x1f\n\x1dSetStoragePolicyResponseProto\"2\
    \n\x1eUnsetStoragePolicyRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\t\
    R\x03src\"!\n\x1fUnsetStoragePolicyResponseProto\"2\n\x1cGetStoragePolic\
    yRequestProto\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\"k\n\x1dGetS\
    toragePolicyResponseProto\x12J\n\rstoragePolicy\x18\x01\x20\x02(\x0b2$.h\
    adoop.hdfs.BlockStoragePolicyProtoR\rstoragePolicy\"\x20\n\x1eGetStorage\
    PoliciesRequestProto\"c\n\x1fGetStoragePoliciesResponseProto\x12@\n\x08p\
    olicies\x18\x01\x20\x03(\x0b2$.hadoop.hdfs.BlockStoragePolicyProtoR\x08p\
    olicies\"m\n\x19SetPermissionRequestProto\x12\x10\n\x03src\x18\x01\x20\
    \x02(\tR\x03src\x12>\n\npermission\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs\
    .FsPermissionProtoR\npermission\"\x1c\n\x1aSetPermissionResponseProto\"b\
    \n\x14SetOwnerRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\
    \x12\x1a\n\x08username\x18\x02\x20\x01(\tR\x08username\x12\x1c\n\tgroupn\
    ame\x18\x03\x20\x01(\tR\tgroupname\"\x17\n\x15SetOwnerResponseProto\"\
    \x8e\x01\n\x18AbandonBlockRequestProto\x12-\n\x01b\x18\x01\x20\x02(\x0b2\
    \x1f.hadoop.hdfs.ExtendedBlockProtoR\x01b\x12\x10\n\x03src\x18\x02\x20\
    \x02(\tR\x03src\x12\x16\n\x06holder\x18\x03\x20\x02(\tR\x06holder\x12\
    \x19\n\x06fileId\x18\x04\x20\x01(\x04:\x010R\x06fileId\"\x1b\n\x19Abando\
    nBlockResponseProto\"\xbe\x02\n\x14AddBlockRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\x02\x20\x02(\tR\nc\
    lientName\x12;\n\x08previous\x18\x03\x20\x01(\x0b2\x1f.hadoop.hdfs.Exten\
    dedBlockProtoR\x08previous\x12B\n\x0cexcludeNodes\x18\x04\x20\x03(\x0b2\
    \x1e.hadoop.hdfs.DatanodeInfoProtoR\x0cexcludeNodes\x12\x19\n\x06fileId\
    \x18\x05\x20\x01(\x04:\x010R\x06fileId\x12\"\n\x0cfavoredNodes\x18\x06\
    \x20\x03(\tR\x0cfavoredNodes\x124\n\x05flags\x18\x07\x20\x03(\x0e2\x1e.h\
    adoop.hdfs.AddBlockFlagProtoR\x05flags\"M\n\x15AddBlockResponseProto\x12\
    4\n\x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProtoR\
    \x05block\"\x81\x03\n!GetAdditionalDatanodeRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x121\n\x03blk\x18\x02\x20\x02(\x0b2\x1f.hado\
    op.hdfs.ExtendedBlockProtoR\x03blk\x12<\n\texistings\x18\x03\x20\x03(\
    \x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\texistings\x12:\n\x08excludes\
    \x18\x04\x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x08excludes\
    \x12.\n\x12numAdditionalNodes\x18\x05\x20\x02(\rR\x12numAdditionalNodes\
    \x12\x1e\n\nclientName\x18\x06\x20\x02(\tR\nclientName\x122\n\x14existin\
    gStorageUuids\x18\x07\x20\x03(\tR\x14existingStorageUuids\x12\x19\n\x06f\
    ileId\x18\x08\x20\x01(\x04:\x010R\x06fileId\"Z\n\"GetAdditionalDatanodeR\
    esponseProto\x124\n\x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.Locat\
    edBlockProtoR\x05block\"\x98\x01\n\x14CompleteRequestProto\x12\x10\n\x03\
    src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\x02\x20\x02(\tR\
    \nclientName\x123\n\x04last\x18\x03\x20\x01(\x0b2\x1f.hadoop.hdfs.Extend\
    edBlockProtoR\x04last\x12\x19\n\x06fileId\x18\x04\x20\x01(\x04:\x010R\
    \x06fileId\"/\n\x15CompleteResponseProto\x12\x16\n\x06result\x18\x01\x20\
    \x02(\x08R\x06result\"U\n\x1bReportBadBlocksRequestProto\x126\n\x06block\
    s\x18\x01\x20\x03(\x0b2\x1e.hadoop.hdfs.LocatedBlockProtoR\x06blocks\"\
    \x1e\n\x1cReportBadBlocksResponseProto\":\n\x12ConcatRequestProto\x12\
    \x10\n\x03trg\x18\x01\x20\x02(\tR\x03trg\x12\x12\n\x04srcs\x18\x02\x20\
    \x03(\tR\x04srcs\"\x15\n\x13ConcatResponseProto\"f\n\x14TruncateRequestP\
    roto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x1c\n\tnewLength\
    \x18\x02\x20\x02(\x04R\tnewLength\x12\x1e\n\nclientName\x18\x03\x20\x02(\
    \tR\nclientName\"/\n\x15TruncateResponseProto\x12\x16\n\x06result\x18\
    \x01\x20\x02(\x08R\x06result\"8\n\x12RenameRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12\x10\n\x03dst\x18\x02\x20\x02(\tR\x03dst\
    \"-\n\x13RenameResponseProto\x12\x16\n\x06result\x18\x01\x20\x02(\x08R\
    \x06result\"\x81\x01\n\x13Rename2RequestProto\x12\x10\n\x03src\x18\x01\
    \x20\x02(\tR\x03src\x12\x10\n\x03dst\x18\x02\x20\x02(\tR\x03dst\x12$\n\r\
    overwriteDest\x18\x03\x20\x02(\x08R\roverwriteDest\x12\x20\n\x0bmoveToTr\
    ash\x18\x04\x20\x01(\x08R\x0bmoveToTrash\"\x16\n\x14Rename2ResponseProto\
    \"D\n\x12DeleteRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\
    \x12\x1c\n\trecursive\x18\x02\x20\x02(\x08R\trecursive\"-\n\x13DeleteRes\
    ponseProto\x12\x16\n\x06result\x18\x01\x20\x02(\x08R\x06result\"\xbe\x01\
    \n\x12MkdirsRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\
    6\n\x06masked\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\
    \x06masked\x12\"\n\x0ccreateParent\x18\x03\x20\x02(\x08R\x0ccreateParent\
    \x12:\n\x08unmasked\x18\x04\x20\x01(\x0b2\x1e.hadoop.hdfs.FsPermissionPr\
    otoR\x08unmasked\"-\n\x13MkdirsResponseProto\x12\x16\n\x06result\x18\x01\
    \x20\x02(\x08R\x06result\"n\n\x16GetListingRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nstartAfter\x18\x02\x20\x02(\x0cR\
    \nstartAfter\x12\"\n\x0cneedLocation\x18\x03\x20\x02(\x08R\x0cneedLocati\
    on\"W\n\x17GetListingResponseProto\x12<\n\x07dirList\x18\x01\x20\x01(\
    \x0b2\".hadoop.hdfs.DirectoryListingProtoR\x07dirList\"(\n&GetSnapshotta\
    bleDirListingRequestProto\"\x8e\x01\n'GetSnapshottableDirListingResponse\
    Proto\x12c\n\x14snapshottableDirList\x18\x01\x20\x01(\x0b2/.hadoop.hdfs.\
    SnapshottableDirectoryListingProtoR\x14snapshottableDirList\"\x8b\x01\n!\
    GetSnapshotDiffReportRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\
    \x02(\tR\x0csnapshotRoot\x12\"\n\x0cfromSnapshot\x18\x02\x20\x02(\tR\x0c\
    fromSnapshot\x12\x1e\n\ntoSnapshot\x18\x03\x20\x02(\tR\ntoSnapshot\"j\n\
    \"GetSnapshotDiffReportResponseProto\x12D\n\ndiffReport\x18\x01\x20\x02(\
    \x0b2$.hadoop.hdfs.SnapshotDiffReportProtoR\ndiffReport\"8\n\x16RenewLea\
    seRequestProto\x12\x1e\n\nclientName\x18\x01\x20\x02(\tR\nclientName\"\
    \x19\n\x17RenewLeaseResponseProto\"L\n\x18RecoverLeaseRequestProto\x12\
    \x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\x02\
    \x20\x02(\tR\nclientName\"3\n\x19RecoverLeaseResponseProto\x12\x16\n\x06\
    result\x18\x01\x20\x02(\x08R\x06result\"\x19\n\x17GetFsStatusRequestProt\
    o\"\xf9\x02\n\x17GetFsStatsResponseProto\x12\x1a\n\x08capacity\x18\x01\
    \x20\x02(\x04R\x08capacity\x12\x12\n\x04used\x18\x02\x20\x02(\x04R\x04us\
    ed\x12\x1c\n\tremaining\x18\x03\x20\x02(\x04R\tremaining\x12)\n\x10under\
    _replicated\x18\x04\x20\x02(\x04R\x0funderReplicated\x12%\n\x0ecorrupt_b\
    locks\x18\x05\x20\x02(\x04R\rcorruptBlocks\x12%\n\x0emissing_blocks\x18\
    \x06\x20\x02(\x04R\rmissingBlocks\x125\n\x17missing_repl_one_blocks\x18\
    \x07\x20\x01(\x04R\x14missingReplOneBlocks\x12(\n\x10blocks_in_future\
    \x18\x08\x20\x01(\x04R\x0eblocksInFuture\x126\n\x17pending_deletion_bloc\
    ks\x18\t\x20\x01(\x04R\x15pendingDeletionBlocks\"'\n%GetFsReplicatedBloc\
    kStatsRequestProto\"\xb6\x02\n&GetFsReplicatedBlockStatsResponseProto\
    \x12%\n\x0elow_redundancy\x18\x01\x20\x02(\x04R\rlowRedundancy\x12%\n\
    \x0ecorrupt_blocks\x18\x02\x20\x02(\x04R\rcorruptBlocks\x12%\n\x0emissin\
    g_blocks\x18\x03\x20\x02(\x04R\rmissingBlocks\x125\n\x17missing_repl_one\
    _blocks\x18\x04\x20\x02(\x04R\x14missingReplOneBlocks\x12(\n\x10blocks_i\
    n_future\x18\x05\x20\x02(\x04R\x0eblocksInFuture\x126\n\x17pending_delet\
    ion_blocks\x18\x06\x20\x02(\x04R\x15pendingDeletionBlocks\"$\n\"GetFsECB\
    lockGroupStatsRequestProto\"\xfc\x01\n#GetFsECBlockGroupStatsResponsePro\
    to\x12%\n\x0elow_redundancy\x18\x01\x20\x02(\x04R\rlowRedundancy\x12%\n\
    \x0ecorrupt_blocks\x18\x02\x20\x02(\x04R\rcorruptBlocks\x12%\n\x0emissin\
    g_blocks\x18\x03\x20\x02(\x04R\rmissingBlocks\x12(\n\x10blocks_in_future\
    \x18\x04\x20\x02(\x04R\x0eblocksInFuture\x126\n\x17pending_deletion_bloc\
    ks\x18\x05\x20\x02(\x04R\x15pendingDeletionBlocks\"Y\n\x1dGetDatanodeRep\
    ortRequestProto\x128\n\x04type\x18\x01\x20\x02(\x0e2$.hadoop.hdfs.Datano\
    deReportTypeProtoR\x04type\"P\n\x1eGetDatanodeReportResponseProto\x12.\n\
    \x02di\x18\x01\x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x02di\"`\
    \n$GetDatanodeStorageReportRequestProto\x128\n\x04type\x18\x01\x20\x02(\
    \x0e2$.hadoop.hdfs.DatanodeReportTypeProtoR\x04type\"\xa9\x01\n\x1aDatan\
    odeStorageReportProto\x12B\n\x0cdatanodeInfo\x18\x01\x20\x02(\x0b2\x1e.h\
    adoop.hdfs.DatanodeInfoProtoR\x0cdatanodeInfo\x12G\n\x0estorageReports\
    \x18\x02\x20\x03(\x0b2\x1f.hadoop.hdfs.StorageReportProtoR\x0estorageRep\
    orts\"\x88\x01\n%GetDatanodeStorageReportResponseProto\x12_\n\x16datanod\
    eStorageReports\x18\x01\x20\x03(\x0b2'.hadoop.hdfs.DatanodeStorageReport\
    ProtoR\x16datanodeStorageReports\"?\n!GetPreferredBlockSizeRequestProto\
    \x12\x1a\n\x08filename\x18\x01\x20\x02(\tR\x08filename\":\n\"GetPreferre\
    dBlockSizeResponseProto\x12\x14\n\x05bsize\x18\x01\x20\x02(\x04R\x05bsiz\
    e\"t\n\x17SetSafeModeRequestProto\x128\n\x06action\x18\x01\x20\x02(\x0e2\
    \x20.hadoop.hdfs.SafeModeActionProtoR\x06action\x12\x1f\n\x07checked\x18\
    \x02\x20\x01(\x08:\x05falseR\x07checked\"2\n\x18SetSafeModeResponseProto\
    \x12\x16\n\x06result\x18\x01\x20\x02(\x08R\x06result\"W\n\x19SaveNamespa\
    ceRequestProto\x12!\n\ntimeWindow\x18\x01\x20\x01(\x04:\x010R\ntimeWindo\
    w\x12\x17\n\x05txGap\x18\x02\x20\x01(\x04:\x010R\x05txGap\"8\n\x1aSaveNa\
    mespaceResponseProto\x12\x1a\n\x05saved\x18\x01\x20\x01(\x08:\x04trueR\
    \x05saved\"\x17\n\x15RollEditsRequestProto\"@\n\x16RollEditsResponseProt\
    o\x12&\n\x0enewSegmentTxId\x18\x01\x20\x02(\x04R\x0enewSegmentTxId\"4\n\
    \x20RestoreFailedStorageRequestProto\x12\x10\n\x03arg\x18\x01\x20\x02(\t\
    R\x03arg\";\n!RestoreFailedStorageResponseProto\x12\x16\n\x06result\x18\
    \x01\x20\x02(\x08R\x06result\"\x1a\n\x18RefreshNodesRequestProto\"\x1b\n\
    \x19RefreshNodesResponseProto\"\x1d\n\x1bFinalizeUpgradeRequestProto\"\
    \x1e\n\x1cFinalizeUpgradeResponseProto\"\\\n\x1aRollingUpgradeRequestPro\
    to\x12>\n\x06action\x18\x01\x20\x02(\x0e2&.hadoop.hdfs.RollingUpgradeAct\
    ionProtoR\x06action\"\xd1\x01\n\x17RollingUpgradeInfoProto\x12>\n\x06sta\
    tus\x18\x01\x20\x02(\x0b2&.hadoop.hdfs.RollingUpgradeStatusProtoR\x06sta\
    tus\x12\x1c\n\tstartTime\x18\x02\x20\x02(\x04R\tstartTime\x12\"\n\x0cfin\
    alizeTime\x18\x03\x20\x02(\x04R\x0cfinalizeTime\x124\n\x15createdRollbac\
    kImages\x18\x04\x20\x02(\x08R\x15createdRollbackImages\"s\n\x1bRollingUp\
    gradeResponseProto\x12T\n\x12rollingUpgradeInfo\x18\x01\x20\x01(\x0b2$.h\
    adoop.hdfs.RollingUpgradeInfoProtoR\x12rollingUpgradeInfo\"O\n!ListCorru\
    ptFileBlocksRequestProto\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\
    \x12\x16\n\x06cookie\x18\x02\x20\x01(\tR\x06cookie\"c\n\"ListCorruptFile\
    BlocksResponseProto\x12=\n\x07corrupt\x18\x01\x20\x02(\x0b2#.hadoop.hdfs\
    .CorruptFileBlocksProtoR\x07corrupt\"2\n\x14MetaSaveRequestProto\x12\x1a\
    \n\x08filename\x18\x01\x20\x02(\tR\x08filename\"\x17\n\x15MetaSaveRespon\
    seProto\"+\n\x17GetFileInfoRequestProto\x12\x10\n\x03src\x18\x01\x20\x02\
    (\tR\x03src\"L\n\x18GetFileInfoResponseProto\x120\n\x02fs\x18\x01\x20\
    \x01(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\x02fs\",\n\x18IsFileClos\
    edRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\"3\n\x19IsFil\
    eClosedResponseProto\x12\x16\n\x06result\x18\x01\x20\x02(\x08R\x06result\
    \"\xc3\x01\n\x17CacheDirectiveInfoProto\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \x03R\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x20\n\x0br\
    eplication\x18\x03\x20\x01(\rR\x0breplication\x12\x12\n\x04pool\x18\x04\
    \x20\x01(\tR\x04pool\x12N\n\nexpiration\x18\x05\x20\x01(\x0b2..hadoop.hd\
    fs.CacheDirectiveInfoExpirationProtoR\nexpiration\"[\n!CacheDirectiveInf\
    oExpirationProto\x12\x16\n\x06millis\x18\x01\x20\x02(\x03R\x06millis\x12\
    \x1e\n\nisRelative\x18\x02\x20\x02(\x08R\nisRelative\"\xc2\x01\n\x18Cach\
    eDirectiveStatsProto\x12\x20\n\x0bbytesNeeded\x18\x01\x20\x02(\x03R\x0bb\
    ytesNeeded\x12\x20\n\x0bbytesCached\x18\x02\x20\x02(\x03R\x0bbytesCached\
    \x12\x20\n\x0bfilesNeeded\x18\x03\x20\x02(\x03R\x0bfilesNeeded\x12\x20\n\
    \x0bfilesCached\x18\x04\x20\x02(\x03R\x0bfilesCached\x12\x1e\n\nhasExpir\
    ed\x18\x05\x20\x02(\x08R\nhasExpired\"y\n\x1dAddCacheDirectiveRequestPro\
    to\x128\n\x04info\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoP\
    rotoR\x04info\x12\x1e\n\ncacheFlags\x18\x02\x20\x01(\rR\ncacheFlags\"0\n\
    \x1eAddCacheDirectiveResponseProto\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\
    \x02id\"|\n\x20ModifyCacheDirectiveRequestProto\x128\n\x04info\x18\x01\
    \x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProtoR\x04info\x12\x1e\n\n\
    cacheFlags\x18\x02\x20\x01(\rR\ncacheFlags\"#\n!ModifyCacheDirectiveResp\
    onseProto\"2\n\x20RemoveCacheDirectiveRequestProto\x12\x0e\n\x02id\x18\
    \x01\x20\x02(\x03R\x02id\"#\n!RemoveCacheDirectiveResponseProto\"w\n\x1f\
    ListCacheDirectivesRequestProto\x12\x16\n\x06prevId\x18\x01\x20\x02(\x03\
    R\x06prevId\x12<\n\x06filter\x18\x02\x20\x02(\x0b2$.hadoop.hdfs.CacheDir\
    ectiveInfoProtoR\x06filter\"\x91\x01\n\x18CacheDirectiveEntryProto\x128\
    \n\x04info\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProtoR\
    \x04info\x12;\n\x05stats\x18\x02\x20\x02(\x0b2%.hadoop.hdfs.CacheDirecti\
    veStatsProtoR\x05stats\"\x7f\n\x20ListCacheDirectivesResponseProto\x12A\
    \n\x08elements\x18\x01\x20\x03(\x0b2%.hadoop.hdfs.CacheDirectiveEntryPro\
    toR\x08elements\x12\x18\n\x07hasMore\x18\x02\x20\x02(\x08R\x07hasMore\"\
    \xf7\x01\n\x12CachePoolInfoProto\x12\x1a\n\x08poolName\x18\x01\x20\x01(\
    \tR\x08poolName\x12\x1c\n\townerName\x18\x02\x20\x01(\tR\townerName\x12\
    \x1c\n\tgroupName\x18\x03\x20\x01(\tR\tgroupName\x12\x12\n\x04mode\x18\
    \x04\x20\x01(\x05R\x04mode\x12\x14\n\x05limit\x18\x05\x20\x01(\x03R\x05l\
    imit\x12,\n\x11maxRelativeExpiry\x18\x06\x20\x01(\x03R\x11maxRelativeExp\
    iry\x121\n\x12defaultReplication\x18\x07\x20\x01(\r:\x011R\x12defaultRep\
    lication\"\xc5\x01\n\x13CachePoolStatsProto\x12\x20\n\x0bbytesNeeded\x18\
    \x01\x20\x02(\x03R\x0bbytesNeeded\x12\x20\n\x0bbytesCached\x18\x02\x20\
    \x02(\x03R\x0bbytesCached\x12&\n\x0ebytesOverlimit\x18\x03\x20\x02(\x03R\
    \x0ebytesOverlimit\x12\x20\n\x0bfilesNeeded\x18\x04\x20\x02(\x03R\x0bfil\
    esNeeded\x12\x20\n\x0bfilesCached\x18\x05\x20\x02(\x03R\x0bfilesCached\"\
    O\n\x18AddCachePoolRequestProto\x123\n\x04info\x18\x01\x20\x02(\x0b2\x1f\
    .hadoop.hdfs.CachePoolInfoProtoR\x04info\"\x1b\n\x19AddCachePoolResponse\
    Proto\"R\n\x1bModifyCachePoolRequestProto\x123\n\x04info\x18\x01\x20\x02\
    (\x0b2\x1f.hadoop.hdfs.CachePoolInfoProtoR\x04info\"\x1e\n\x1cModifyCach\
    ePoolResponseProto\"9\n\x1bRemoveCachePoolRequestProto\x12\x1a\n\x08pool\
    Name\x18\x01\x20\x02(\tR\x08poolName\"\x1e\n\x1cRemoveCachePoolResponseP\
    roto\"@\n\x1aListCachePoolsRequestProto\x12\"\n\x0cprevPoolName\x18\x01\
    \x20\x02(\tR\x0cprevPoolName\"s\n\x1bListCachePoolsResponseProto\x12:\n\
    \x07entries\x18\x01\x20\x03(\x0b2\x20.hadoop.hdfs.CachePoolEntryProtoR\
    \x07entries\x12\x18\n\x07hasMore\x18\x02\x20\x02(\x08R\x07hasMore\"\x82\
    \x01\n\x13CachePoolEntryProto\x123\n\x04info\x18\x01\x20\x02(\x0b2\x1f.h\
    adoop.hdfs.CachePoolInfoProtoR\x04info\x126\n\x05stats\x18\x02\x20\x02(\
    \x0b2\x20.hadoop.hdfs.CachePoolStatsProtoR\x05stats\"/\n\x1bGetFileLinkI\
    nfoRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\"P\n\x1cGetF\
    ileLinkInfoResponseProto\x120\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.h\
    dfs.HdfsFileStatusProtoR\x02fs\"3\n\x1dGetContentSummaryRequestProto\x12\
    \x12\n\x04path\x18\x01\x20\x02(\tR\x04path\"\\\n\x1eGetContentSummaryRes\
    ponseProto\x12:\n\x07summary\x18\x01\x20\x02(\x0b2\x20.hadoop.hdfs.Conte\
    ntSummaryProtoR\x07summary\"/\n\x19GetQuotaUsageRequestProto\x12\x12\n\
    \x04path\x18\x01\x20\x02(\tR\x04path\"P\n\x1aGetQuotaUsageResponseProto\
    \x122\n\x05usage\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.QuotaUsageProtoR\
    \x05usage\"\xc1\x01\n\x14SetQuotaRequestProto\x12\x12\n\x04path\x18\x01\
    \x20\x02(\tR\x04path\x12&\n\x0enamespaceQuota\x18\x02\x20\x02(\x04R\x0en\
    amespaceQuota\x12,\n\x11storagespaceQuota\x18\x03\x20\x02(\x04R\x11stora\
    gespaceQuota\x12?\n\x0bstorageType\x18\x04\x20\x01(\x0e2\x1d.hadoop.hdfs\
    .StorageTypeProtoR\x0bstorageType\"\x17\n\x15SetQuotaResponseProto\"\x86\
    \x01\n\x11FsyncRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\
    \x12\x16\n\x06client\x18\x02\x20\x02(\tR\x06client\x12,\n\x0flastBlockLe\
    ngth\x18\x03\x20\x01(\x12:\x02-1R\x0flastBlockLength\x12\x19\n\x06fileId\
    \x18\x04\x20\x01(\x04:\x010R\x06fileId\"\x14\n\x12FsyncResponseProto\"T\
    \n\x14SetTimesRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\
    \x12\x14\n\x05mtime\x18\x02\x20\x02(\x04R\x05mtime\x12\x14\n\x05atime\
    \x18\x03\x20\x02(\x04R\x05atime\"\x17\n\x15SetTimesResponseProto\"\xa5\
    \x01\n\x19CreateSymlinkRequestProto\x12\x16\n\x06target\x18\x01\x20\x02(\
    \tR\x06target\x12\x12\n\x04link\x18\x02\x20\x02(\tR\x04link\x128\n\x07di\
    rPerm\x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\x07dirPer\
    m\x12\"\n\x0ccreateParent\x18\x04\x20\x02(\x08R\x0ccreateParent\"\x1c\n\
    \x1aCreateSymlinkResponseProto\"/\n\x19GetLinkTargetRequestProto\x12\x12\
    \n\x04path\x18\x01\x20\x02(\tR\x04path\"<\n\x1aGetLinkTargetResponseProt\
    o\x12\x1e\n\ntargetPath\x18\x01\x20\x01(\tR\ntargetPath\"{\n\"UpdateBloc\
    kForPipelineRequestProto\x125\n\x05block\x18\x01\x20\x02(\x0b2\x1f.hadoo\
    p.hdfs.ExtendedBlockProtoR\x05block\x12\x1e\n\nclientName\x18\x02\x20\
    \x02(\tR\nclientName\"[\n#UpdateBlockForPipelineResponseProto\x124\n\x05\
    block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProtoR\x05block\
    \"\x90\x02\n\x1aUpdatePipelineRequestProto\x12\x1e\n\nclientName\x18\x01\
    \x20\x02(\tR\nclientName\x12;\n\x08oldBlock\x18\x02\x20\x02(\x0b2\x1f.ha\
    doop.hdfs.ExtendedBlockProtoR\x08oldBlock\x12;\n\x08newBlock\x18\x03\x20\
    \x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProtoR\x08newBlock\x128\n\x08new\
    Nodes\x18\x04\x20\x03(\x0b2\x1c.hadoop.hdfs.DatanodeIDProtoR\x08newNodes\
    \x12\x1e\n\nstorageIDs\x18\x05\x20\x03(\tR\nstorageIDs\"\x1d\n\x1bUpdate\
    PipelineResponseProto\"@\n\x20SetBalancerBandwidthRequestProto\x12\x1c\n\
    \tbandwidth\x18\x01\x20\x02(\x03R\tbandwidth\"#\n!SetBalancerBandwidthRe\
    sponseProto\"\"\n\x20GetDataEncryptionKeyRequestProto\"v\n!GetDataEncryp\
    tionKeyResponseProto\x12Q\n\x11dataEncryptionKey\x18\x01\x20\x01(\x0b2#.\
    hadoop.hdfs.DataEncryptionKeyProtoR\x11dataEncryptionKey\"d\n\x1aCreateS\
    napshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02(\tR\x0csnaps\
    hotRoot\x12\"\n\x0csnapshotName\x18\x02\x20\x01(\tR\x0csnapshotName\"A\n\
    \x1bCreateSnapshotResponseProto\x12\"\n\x0csnapshotPath\x18\x01\x20\x02(\
    \tR\x0csnapshotPath\"\x94\x01\n\x1aRenameSnapshotRequestProto\x12\"\n\
    \x0csnapshotRoot\x18\x01\x20\x02(\tR\x0csnapshotRoot\x12(\n\x0fsnapshotO\
    ldName\x18\x02\x20\x02(\tR\x0fsnapshotOldName\x12(\n\x0fsnapshotNewName\
    \x18\x03\x20\x02(\tR\x0fsnapshotNewName\"\x1d\n\x1bRenameSnapshotRespons\
    eProto\"?\n\x19AllowSnapshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\
    \x20\x02(\tR\x0csnapshotRoot\"\x1c\n\x1aAllowSnapshotResponseProto\"B\n\
    \x1cDisallowSnapshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02\
    (\tR\x0csnapshotRoot\"\x1f\n\x1dDisallowSnapshotResponseProto\"d\n\x1aDe\
    leteSnapshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02(\tR\x0c\
    snapshotRoot\x12\"\n\x0csnapshotName\x18\x02\x20\x02(\tR\x0csnapshotName\
    \"\x1d\n\x1bDeleteSnapshotResponseProto\"k\n\x17CheckAccessRequestProto\
    \x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\x12<\n\x04mode\x18\x02\
    \x20\x02(\x0e2(.hadoop.hdfs.AclEntryProto.FsActionProtoR\x04mode\"\x1a\n\
    \x18CheckAccessResponseProto\"#\n!GetCurrentEditLogTxidRequestProto\"8\n\
    \"GetCurrentEditLogTxidResponseProto\x12\x12\n\x04txid\x18\x01\x20\x02(\
    \x03R\x04txid\"2\n\x1cGetEditsFromTxidRequestProto\x12\x12\n\x04txid\x18\
    \x01\x20\x02(\x03R\x04txid\"]\n\x1dGetEditsFromTxidResponseProto\x12<\n\
    \neventsList\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.EventsListProtoR\neve\
    ntsList\"+\n\x19ListOpenFilesRequestProto\x12\x0e\n\x02id\x18\x01\x20\
    \x02(\x03R\x02id\"\x87\x01\n\x1bOpenFilesBatchResponseProto\x12\x0e\n\
    \x02id\x18\x01\x20\x02(\x03R\x02id\x12\x12\n\x04path\x18\x02\x20\x02(\tR\
    \x04path\x12\x1e\n\nclientName\x18\x03\x20\x02(\tR\nclientName\x12$\n\rc\
    lientMachine\x18\x04\x20\x02(\tR\rclientMachine\"z\n\x1aListOpenFilesRes\
    ponseProto\x12B\n\x07entries\x18\x01\x20\x03(\x0b2(.hadoop.hdfs.OpenFile\
    sBatchResponseProtoR\x07entries\x12\x18\n\x07hasMore\x18\x02\x20\x02(\
    \x08R\x07hasMore*p\n\x0fCreateFlagProto\x12\n\n\x06CREATE\x10\x01\x12\r\
    \n\tOVERWRITE\x10\x02\x12\n\n\x06APPEND\x10\x04\x12\x10\n\x0cLAZY_PERSIS\
    T\x10\x10\x12\r\n\tNEW_BLOCK\x10\x20\x12\x15\n\x10SHOULD_REPLICATE\x10\
    \x80\x01*'\n\x11AddBlockFlagProto\x12\x12\n\x0eNO_LOCAL_WRITE\x10\x01*y\
    \n\x17DatanodeReportTypeProto\x12\x07\n\x03ALL\x10\x01\x12\x08\n\x04LIVE\
    \x10\x02\x12\x08\n\x04DEAD\x10\x03\x12\x13\n\x0fDECOMMISSIONING\x10\x04\
    \x12\x18\n\x14ENTERING_MAINTENANCE\x10\x05\x12\x12\n\x0eIN_MAINTENANCE\
    \x10\x06*h\n\x13SafeModeActionProto\x12\x12\n\x0eSAFEMODE_LEAVE\x10\x01\
    \x12\x12\n\x0eSAFEMODE_ENTER\x10\x02\x12\x10\n\x0cSAFEMODE_GET\x10\x03\
    \x12\x17\n\x13SAFEMODE_FORCE_EXIT\x10\x04*?\n\x19RollingUpgradeActionPro\
    to\x12\t\n\x05QUERY\x10\x01\x12\t\n\x05START\x10\x02\x12\x0c\n\x08FINALI\
    ZE\x10\x03*\x1b\n\x0eCacheFlagProto\x12\t\n\x05FORCE\x10\x012\xecQ\n\x16\
    ClientNamenodeProtocol\x12l\n\x11getBlockLocations\x12*.hadoop.hdfs.GetB\
    lockLocationsRequestProto\x1a+.hadoop.hdfs.GetBlockLocationsResponseProt\
    o\x12l\n\x11getServerDefaults\x12*.hadoop.hdfs.GetServerDefaultsRequestP\
    roto\x1a+.hadoop.hdfs.GetServerDefaultsResponseProto\x12K\n\x06create\
    \x12\x1f.hadoop.hdfs.CreateRequestProto\x1a\x20.hadoop.hdfs.CreateRespon\
    seProto\x12K\n\x06append\x12\x1f.hadoop.hdfs.AppendRequestProto\x1a\x20.\
    hadoop.hdfs.AppendResponseProto\x12c\n\x0esetReplication\x12'.hadoop.hdf\
    s.SetReplicationRequestProto\x1a(.hadoop.hdfs.SetReplicationResponseProt\
    o\x12i\n\x10setStoragePolicy\x12).hadoop.hdfs.SetStoragePolicyRequestPro\
    to\x1a*.hadoop.hdfs.SetStoragePolicyResponseProto\x12o\n\x12unsetStorage\
    Policy\x12+.hadoop.hdfs.UnsetStoragePolicyRequestProto\x1a,.hadoop.hdfs.\
    UnsetStoragePolicyResponseProto\x12i\n\x10getStoragePolicy\x12).hadoop.h\
    dfs.GetStoragePolicyRequestProto\x1a*.hadoop.hdfs.GetStoragePolicyRespon\
    seProto\x12o\n\x12getStoragePolicies\x12+.hadoop.hdfs.GetStoragePolicies\
    RequestProto\x1a,.hadoop.hdfs.GetStoragePoliciesResponseProto\x12`\n\rse\
    tPermission\x12&.hadoop.hdfs.SetPermissionRequestProto\x1a'.hadoop.hdfs.\
    SetPermissionResponseProto\x12Q\n\x08setOwner\x12!.hadoop.hdfs.SetOwnerR\
    equestProto\x1a\".hadoop.hdfs.SetOwnerResponseProto\x12]\n\x0cabandonBlo\
    ck\x12%.hadoop.hdfs.AbandonBlockRequestProto\x1a&.hadoop.hdfs.AbandonBlo\
    ckResponseProto\x12Q\n\x08addBlock\x12!.hadoop.hdfs.AddBlockRequestProto\
    \x1a\".hadoop.hdfs.AddBlockResponseProto\x12x\n\x15getAdditionalDatanode\
    \x12..hadoop.hdfs.GetAdditionalDatanodeRequestProto\x1a/.hadoop.hdfs.Get\
    AdditionalDatanodeResponseProto\x12Q\n\x08complete\x12!.hadoop.hdfs.Comp\
    leteRequestProto\x1a\".hadoop.hdfs.CompleteResponseProto\x12f\n\x0frepor\
    tBadBlocks\x12(.hadoop.hdfs.ReportBadBlocksRequestProto\x1a).hadoop.hdfs\
    .ReportBadBlocksResponseProto\x12K\n\x06concat\x12\x1f.hadoop.hdfs.Conca\
    tRequestProto\x1a\x20.hadoop.hdfs.ConcatResponseProto\x12Q\n\x08truncate\
    \x12!.hadoop.hdfs.TruncateRequestProto\x1a\".hadoop.hdfs.TruncateRespons\
    eProto\x12K\n\x06rename\x12\x1f.hadoop.hdfs.RenameRequestProto\x1a\x20.h\
    adoop.hdfs.RenameResponseProto\x12N\n\x07rename2\x12\x20.hadoop.hdfs.Ren\
    ame2RequestProto\x1a!.hadoop.hdfs.Rename2ResponseProto\x12K\n\x06delete\
    \x12\x1f.hadoop.hdfs.DeleteRequestProto\x1a\x20.hadoop.hdfs.DeleteRespon\
    seProto\x12K\n\x06mkdirs\x12\x1f.hadoop.hdfs.MkdirsRequestProto\x1a\x20.\
    hadoop.hdfs.MkdirsResponseProto\x12W\n\ngetListing\x12#.hadoop.hdfs.GetL\
    istingRequestProto\x1a$.hadoop.hdfs.GetListingResponseProto\x12W\n\nrene\
    wLease\x12#.hadoop.hdfs.RenewLeaseRequestProto\x1a$.hadoop.hdfs.RenewLea\
    seResponseProto\x12]\n\x0crecoverLease\x12%.hadoop.hdfs.RecoverLeaseRequ\
    estProto\x1a&.hadoop.hdfs.RecoverLeaseResponseProto\x12X\n\ngetFsStats\
    \x12$.hadoop.hdfs.GetFsStatusRequestProto\x1a$.hadoop.hdfs.GetFsStatsRes\
    ponseProto\x12\x84\x01\n\x19getFsReplicatedBlockStats\x122.hadoop.hdfs.G\
    etFsReplicatedBlockStatsRequestProto\x1a3.hadoop.hdfs.GetFsReplicatedBlo\
    ckStatsResponseProto\x12{\n\x16getFsECBlockGroupStats\x12/.hadoop.hdfs.G\
    etFsECBlockGroupStatsRequestProto\x1a0.hadoop.hdfs.GetFsECBlockGroupStat\
    sResponseProto\x12l\n\x11getDatanodeReport\x12*.hadoop.hdfs.GetDatanodeR\
    eportRequestProto\x1a+.hadoop.hdfs.GetDatanodeReportResponseProto\x12\
    \x81\x01\n\x18getDatanodeStorageReport\x121.hadoop.hdfs.GetDatanodeStora\
    geReportRequestProto\x1a2.hadoop.hdfs.GetDatanodeStorageReportResponsePr\
    oto\x12x\n\x15getPreferredBlockSize\x12..hadoop.hdfs.GetPreferredBlockSi\
    zeRequestProto\x1a/.hadoop.hdfs.GetPreferredBlockSizeResponseProto\x12Z\
    \n\x0bsetSafeMode\x12$.hadoop.hdfs.SetSafeModeRequestProto\x1a%.hadoop.h\
    dfs.SetSafeModeResponseProto\x12`\n\rsaveNamespace\x12&.hadoop.hdfs.Save\
    NamespaceRequestProto\x1a'.hadoop.hdfs.SaveNamespaceResponseProto\x12T\n\
    \trollEdits\x12\".hadoop.hdfs.RollEditsRequestProto\x1a#.hadoop.hdfs.Rol\
    lEditsResponseProto\x12u\n\x14restoreFailedStorage\x12-.hadoop.hdfs.Rest\
    oreFailedStorageRequestProto\x1a..hadoop.hdfs.RestoreFailedStorageRespon\
    seProto\x12]\n\x0crefreshNodes\x12%.hadoop.hdfs.RefreshNodesRequestProto\
    \x1a&.hadoop.hdfs.RefreshNodesResponseProto\x12f\n\x0ffinalizeUpgrade\
    \x12(.hadoop.hdfs.FinalizeUpgradeRequestProto\x1a).hadoop.hdfs.FinalizeU\
    pgradeResponseProto\x12c\n\x0erollingUpgrade\x12'.hadoop.hdfs.RollingUpg\
    radeRequestProto\x1a(.hadoop.hdfs.RollingUpgradeResponseProto\x12x\n\x15\
    listCorruptFileBlocks\x12..hadoop.hdfs.ListCorruptFileBlocksRequestProto\
    \x1a/.hadoop.hdfs.ListCorruptFileBlocksResponseProto\x12Q\n\x08metaSave\
    \x12!.hadoop.hdfs.MetaSaveRequestProto\x1a\".hadoop.hdfs.MetaSaveRespons\
    eProto\x12Z\n\x0bgetFileInfo\x12$.hadoop.hdfs.GetFileInfoRequestProto\
    \x1a%.hadoop.hdfs.GetFileInfoResponseProto\x12l\n\x11addCacheDirective\
    \x12*.hadoop.hdfs.AddCacheDirectiveRequestProto\x1a+.hadoop.hdfs.AddCach\
    eDirectiveResponseProto\x12u\n\x14modifyCacheDirective\x12-.hadoop.hdfs.\
    ModifyCacheDirectiveRequestProto\x1a..hadoop.hdfs.ModifyCacheDirectiveRe\
    sponseProto\x12u\n\x14removeCacheDirective\x12-.hadoop.hdfs.RemoveCacheD\
    irectiveRequestProto\x1a..hadoop.hdfs.RemoveCacheDirectiveResponseProto\
    \x12r\n\x13listCacheDirectives\x12,.hadoop.hdfs.ListCacheDirectivesReque\
    stProto\x1a-.hadoop.hdfs.ListCacheDirectivesResponseProto\x12]\n\x0caddC\
    achePool\x12%.hadoop.hdfs.AddCachePoolRequestProto\x1a&.hadoop.hdfs.AddC\
    achePoolResponseProto\x12f\n\x0fmodifyCachePool\x12(.hadoop.hdfs.ModifyC\
    achePoolRequestProto\x1a).hadoop.hdfs.ModifyCachePoolResponseProto\x12f\
    \n\x0fremoveCachePool\x12(.hadoop.hdfs.RemoveCachePoolRequestProto\x1a).\
    hadoop.hdfs.RemoveCachePoolResponseProto\x12c\n\x0elistCachePools\x12'.h\
    adoop.hdfs.ListCachePoolsRequestProto\x1a(.hadoop.hdfs.ListCachePoolsRes\
    ponseProto\x12f\n\x0fgetFileLinkInfo\x12(.hadoop.hdfs.GetFileLinkInfoReq\
    uestProto\x1a).hadoop.hdfs.GetFileLinkInfoResponseProto\x12l\n\x11getCon\
    tentSummary\x12*.hadoop.hdfs.GetContentSummaryRequestProto\x1a+.hadoop.h\
    dfs.GetContentSummaryResponseProto\x12Q\n\x08setQuota\x12!.hadoop.hdfs.S\
    etQuotaRequestProto\x1a\".hadoop.hdfs.SetQuotaResponseProto\x12H\n\x05fs\
    ync\x12\x1e.hadoop.hdfs.FsyncRequestProto\x1a\x1f.hadoop.hdfs.FsyncRespo\
    nseProto\x12Q\n\x08setTimes\x12!.hadoop.hdfs.SetTimesRequestProto\x1a\".\
    hadoop.hdfs.SetTimesResponseProto\x12`\n\rcreateSymlink\x12&.hadoop.hdfs\
    .CreateSymlinkRequestProto\x1a'.hadoop.hdfs.CreateSymlinkResponseProto\
    \x12`\n\rgetLinkTarget\x12&.hadoop.hdfs.GetLinkTargetRequestProto\x1a'.h\
    adoop.hdfs.GetLinkTargetResponseProto\x12{\n\x16updateBlockForPipeline\
    \x12/.hadoop.hdfs.UpdateBlockForPipelineRequestProto\x1a0.hadoop.hdfs.Up\
    dateBlockForPipelineResponseProto\x12c\n\x0eupdatePipeline\x12'.hadoop.h\
    dfs.UpdatePipelineRequestProto\x1a(.hadoop.hdfs.UpdatePipelineResponsePr\
    oto\x12s\n\x12getDelegationToken\x12-.hadoop.common.GetDelegationTokenRe\
    questProto\x1a..hadoop.common.GetDelegationTokenResponseProto\x12y\n\x14\
    renewDelegationToken\x12/.hadoop.common.RenewDelegationTokenRequestProto\
    \x1a0.hadoop.common.RenewDelegationTokenResponseProto\x12|\n\x15cancelDe\
    legationToken\x120.hadoop.common.CancelDelegationTokenRequestProto\x1a1.\
    hadoop.common.CancelDelegationTokenResponseProto\x12u\n\x14setBalancerBa\
    ndwidth\x12-.hadoop.hdfs.SetBalancerBandwidthRequestProto\x1a..hadoop.hd\
    fs.SetBalancerBandwidthResponseProto\x12u\n\x14getDataEncryptionKey\x12-\
    .hadoop.hdfs.GetDataEncryptionKeyRequestProto\x1a..hadoop.hdfs.GetDataEn\
    cryptionKeyResponseProto\x12c\n\x0ecreateSnapshot\x12'.hadoop.hdfs.Creat\
    eSnapshotRequestProto\x1a(.hadoop.hdfs.CreateSnapshotResponseProto\x12c\
    \n\x0erenameSnapshot\x12'.hadoop.hdfs.RenameSnapshotRequestProto\x1a(.ha\
    doop.hdfs.RenameSnapshotResponseProto\x12`\n\rallowSnapshot\x12&.hadoop.\
    hdfs.AllowSnapshotRequestProto\x1a'.hadoop.hdfs.AllowSnapshotResponsePro\
    to\x12i\n\x10disallowSnapshot\x12).hadoop.hdfs.DisallowSnapshotRequestPr\
    oto\x1a*.hadoop.hdfs.DisallowSnapshotResponseProto\x12\x87\x01\n\x1agetS\
    napshottableDirListing\x123.hadoop.hdfs.GetSnapshottableDirListingReques\
    tProto\x1a4.hadoop.hdfs.GetSnapshottableDirListingResponseProto\x12c\n\
    \x0edeleteSnapshot\x12'.hadoop.hdfs.DeleteSnapshotRequestProto\x1a(.hado\
    op.hdfs.DeleteSnapshotResponseProto\x12x\n\x15getSnapshotDiffReport\x12.\
    .hadoop.hdfs.GetSnapshotDiffReportRequestProto\x1a/.hadoop.hdfs.GetSnaps\
    hotDiffReportResponseProto\x12]\n\x0cisFileClosed\x12%.hadoop.hdfs.IsFil\
    eClosedRequestProto\x1a&.hadoop.hdfs.IsFileClosedResponseProto\x12i\n\
    \x10modifyAclEntries\x12).hadoop.hdfs.ModifyAclEntriesRequestProto\x1a*.\
    hadoop.hdfs.ModifyAclEntriesResponseProto\x12i\n\x10removeAclEntries\x12\
    ).hadoop.hdfs.RemoveAclEntriesRequestProto\x1a*.hadoop.hdfs.RemoveAclEnt\
    riesResponseProto\x12i\n\x10removeDefaultAcl\x12).hadoop.hdfs.RemoveDefa\
    ultAclRequestProto\x1a*.hadoop.hdfs.RemoveDefaultAclResponseProto\x12T\n\
    \tremoveAcl\x12\".hadoop.hdfs.RemoveAclRequestProto\x1a#.hadoop.hdfs.Rem\
    oveAclResponseProto\x12K\n\x06setAcl\x12\x1f.hadoop.hdfs.SetAclRequestPr\
    oto\x1a\x20.hadoop.hdfs.SetAclResponseProto\x12]\n\x0cgetAclStatus\x12%.\
    hadoop.hdfs.GetAclStatusRequestProto\x1a&.hadoop.hdfs.GetAclStatusRespon\
    seProto\x12Q\n\x08setXAttr\x12!.hadoop.hdfs.SetXAttrRequestProto\x1a\".h\
    adoop.hdfs.SetXAttrResponseProto\x12T\n\tgetXAttrs\x12\".hadoop.hdfs.Get\
    XAttrsRequestProto\x1a#.hadoop.hdfs.GetXAttrsResponseProto\x12W\n\nlistX\
    Attrs\x12#.hadoop.hdfs.ListXAttrsRequestProto\x1a$.hadoop.hdfs.ListXAttr\
    sResponseProto\x12Z\n\x0bremoveXAttr\x12$.hadoop.hdfs.RemoveXAttrRequest\
    Proto\x1a%.hadoop.hdfs.RemoveXAttrResponseProto\x12Z\n\x0bcheckAccess\
    \x12$.hadoop.hdfs.CheckAccessRequestProto\x1a%.hadoop.hdfs.CheckAccessRe\
    sponseProto\x12u\n\x14createEncryptionZone\x12-.hadoop.hdfs.CreateEncryp\
    tionZoneRequestProto\x1a..hadoop.hdfs.CreateEncryptionZoneResponseProto\
    \x12r\n\x13listEncryptionZones\x12,.hadoop.hdfs.ListEncryptionZonesReque\
    stProto\x1a-.hadoop.hdfs.ListEncryptionZonesResponseProto\x12~\n\x17reen\
    cryptEncryptionZone\x120.hadoop.hdfs.ReencryptEncryptionZoneRequestProto\
    \x1a1.hadoop.hdfs.ReencryptEncryptionZoneResponseProto\x12{\n\x16listRee\
    ncryptionStatus\x12/.hadoop.hdfs.ListReencryptionStatusRequestProto\x1a0\
    .hadoop.hdfs.ListReencryptionStatusResponseProto\x12]\n\x0cgetEZForPath\
    \x12%.hadoop.hdfs.GetEZForPathRequestProto\x1a&.hadoop.hdfs.GetEZForPath\
    ResponseProto\x12{\n\x16setErasureCodingPolicy\x12/.hadoop.hdfs.SetErasu\
    reCodingPolicyRequestProto\x1a0.hadoop.hdfs.SetErasureCodingPolicyRespon\
    seProto\x12\x81\x01\n\x18unsetErasureCodingPolicy\x121.hadoop.hdfs.Unset\
    ErasureCodingPolicyRequestProto\x1a2.hadoop.hdfs.UnsetErasureCodingPolic\
    yResponseProto\x12x\n\x15getCurrentEditLogTxid\x12..hadoop.hdfs.GetCurre\
    ntEditLogTxidRequestProto\x1a/.hadoop.hdfs.GetCurrentEditLogTxidResponse\
    Proto\x12i\n\x10getEditsFromTxid\x12).hadoop.hdfs.GetEditsFromTxidReques\
    tProto\x1a*.hadoop.hdfs.GetEditsFromTxidResponseProto\x12\x81\x01\n\x18g\
    etErasureCodingPolicies\x121.hadoop.hdfs.GetErasureCodingPoliciesRequest\
    Proto\x1a2.hadoop.hdfs.GetErasureCodingPoliciesResponseProto\x12\x81\x01\
    \n\x18addErasureCodingPolicies\x121.hadoop.hdfs.AddErasureCodingPolicies\
    RequestProto\x1a2.hadoop.hdfs.AddErasureCodingPoliciesResponseProto\x12\
    \x84\x01\n\x19removeErasureCodingPolicy\x122.hadoop.hdfs.RemoveErasureCo\
    dingPolicyRequestProto\x1a3.hadoop.hdfs.RemoveErasureCodingPolicyRespons\
    eProto\x12\x84\x01\n\x19enableErasureCodingPolicy\x122.hadoop.hdfs.Enabl\
    eErasureCodingPolicyRequestProto\x1a3.hadoop.hdfs.EnableErasureCodingPol\
    icyResponseProto\x12\x87\x01\n\x1adisableErasureCodingPolicy\x123.hadoop\
    .hdfs.DisableErasureCodingPolicyRequestProto\x1a4.hadoop.hdfs.DisableEra\
    sureCodingPolicyResponseProto\x12{\n\x16getErasureCodingPolicy\x12/.hado\
    op.hdfs.GetErasureCodingPolicyRequestProto\x1a0.hadoop.hdfs.GetErasureCo\
    dingPolicyResponseProto\x12{\n\x16getErasureCodingCodecs\x12/.hadoop.hdf\
    s.GetErasureCodingCodecsRequestProto\x1a0.hadoop.hdfs.GetErasureCodingCo\
    decsResponseProto\x12`\n\rgetQuotaUsage\x12&.hadoop.hdfs.GetQuotaUsageRe\
    questProto\x1a'.hadoop.hdfs.GetQuotaUsageResponseProto\x12`\n\rlistOpenF\
    iles\x12&.hadoop.hdfs.ListOpenFilesRequestProto\x1a'.hadoop.hdfs.ListOpe\
    nFilesResponseProtoBK\n%org.apache.hadoop.hdfs.protocol.protoB\x1cClient\
    NamenodeProtocolProtos\xa0\x01\x01\x88\x01\x01J\x87\x82\x02\n\x07\x12\
    \x05\x18\0\xcf\x07\x01\n\x08\n\x01\x08\x12\x03\x18\0>\n\xbe\x07\n\x04\
    \x08\xe7\x07\0\x12\x03\x18\0>2\x83\x06*\n\x20Licensed\x20to\x20the\x20Ap\
    ache\x20Software\x20Foundation\x20(ASF)\x20under\x20one\n\x20or\x20more\
    \x20contributor\x20license\x20agreements.\x20\x20See\x20the\x20NOTICE\
    \x20file\n\x20distributed\x20with\x20this\x20work\x20for\x20additional\
    \x20information\n\x20regarding\x20copyright\x20ownership.\x20\x20The\x20\
    ASF\x20licenses\x20this\x20file\n\x20to\x20you\x20under\x20the\x20Apache\
    \x20License,\x20Version\x202.0\x20(the\n\x20\"License\");\x20you\x20may\
    \x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\n\x20with\
    \x20the\x20License.\x20\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20th\
    e\x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses\
    /LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\
    \x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\
    \x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20B\
    ASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIN\
    D,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20\
    for\x20the\x20specific\x20language\x20governing\x20permissions\x20and\n\
    \x20limitations\x20under\x20the\x20License.\n2\xaa\x01*\n\x20These\x20.p\
    roto\x20interfaces\x20are\x20private\x20and\x20stable.\n\x20Please\x20se\
    e\x20http://wiki.apache.org/hadoop/Compatibility\n\x20for\x20what\x20cha\
    nges\x20are\x20allowed\x20for\x20a\x20*stable*\x20.proto\x20interface.\n\
    \n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x18\x07\x13\n\r\n\x06\x08\xe7\x07\
    \0\x02\0\x12\x03\x18\x07\x13\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\
    \x18\x07\x13\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x18\x16=\n\x08\n\x01\
    \x08\x12\x03\x19\0=\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x19\0=\n\x0c\n\
    \x05\x08\xe7\x07\x01\x02\x12\x03\x19\x07\x1b\n\r\n\x06\x08\xe7\x07\x01\
    \x02\0\x12\x03\x19\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\
    \x19\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x19\x1e<\n\x08\n\
    \x01\x08\x12\x03\x1a\0$\n\x0b\n\x04\x08\xe7\x07\x02\x12\x03\x1a\0$\n\x0c\
    \n\x05\x08\xe7\x07\x02\x02\x12\x03\x1a\x07\x1c\n\r\n\x06\x08\xe7\x07\x02\
    \x02\0\x12\x03\x1a\x07\x1c\n\x0e\n\x07\x08\xe7\x07\x02\x02\0\x01\x12\x03\
    \x1a\x07\x1c\n\x0c\n\x05\x08\xe7\x07\x02\x03\x12\x03\x1a\x1f#\n\x08\n\
    \x01\x08\x12\x03\x1b\0,\n\x0b\n\x04\x08\xe7\x07\x03\x12\x03\x1b\0,\n\x0c\
    \n\x05\x08\xe7\x07\x03\x02\x12\x03\x1b\x07$\n\r\n\x06\x08\xe7\x07\x03\
    \x02\0\x12\x03\x1b\x07$\n\x0e\n\x07\x08\xe7\x07\x03\x02\0\x01\x12\x03\
    \x1b\x07$\n\x0c\n\x05\x08\xe7\x07\x03\x03\x12\x03\x1b'+\n\x08\n\x01\x02\
    \x12\x03\x1c\x08\x13\n\t\n\x02\x03\0\x12\x03\x1e\x07\x17\n\t\n\x02\x03\
    \x01\x12\x03\x1f\x07\x13\n\t\n\x02\x03\x02\x12\x03\x20\x07\x12\n\t\n\x02\
    \x03\x03\x12\x03!\x07\x14\n\t\n\x02\x03\x04\x12\x03\"\x07\x19\n\t\n\x02\
    \x03\x05\x12\x03#\x07\x16\n\t\n\x02\x03\x06\x12\x03$\x07\x1c\n\xef\x02\n\
    \x02\x04\0\x12\x04/\03\x012\xe2\x02*\n\x20The\x20ClientNamenodeProtocol\
    \x20Service\x20defines\x20the\x20interface\x20between\x20a\x20client\x20\
    \n\x20(as\x20runnign\x20inside\x20a\x20MR\x20Task)\x20and\x20the\x20Name\
    node.\n\x20See\x20org.apache.hadoop.hdfs.protocol.ClientProtocol\x20for\
    \x20the\x20javadoc\x20\n\x20for\x20each\x20of\x20the\x20methods.\n\x20Th\
    e\x20exceptions\x20declared\x20in\x20the\x20above\x20class\x20also\x20ap\
    ply\x20to\x20this\x20protocol.\n\x20Exceptions\x20are\x20unwrapped\x20an\
    d\x20thrown\x20by\x20the\x20\x20PB\x20libraries.\n\n\n\n\x03\x04\0\x01\
    \x12\x03/\x08%\n\x18\n\x04\x04\0\x02\0\x12\x030\x02\x1a\"\x0b\x20file\
    \x20name\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x030\x02\n\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x030\x0b\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\x030\x12\x15\
    \n\x0c\n\x05\x04\0\x02\0\x03\x12\x030\x18\x19\n!\n\x04\x04\0\x02\x01\x12\
    \x031\x02\x1d\"\x14\x20range\x20start\x20offset\n\n\x0c\n\x05\x04\0\x02\
    \x01\x04\x12\x031\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x031\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x031\x12\x18\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x031\x1b\x1c\n\x1b\n\x04\x04\0\x02\x02\x12\x032\x02\x1d\"\x0e\
    \x20range\x20length\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x032\x02\n\n\x0c\
    \n\x05\x04\0\x02\x02\x05\x12\x032\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x032\x12\x18\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x032\x1b\x1c\n\n\n\
    \x02\x04\x01\x12\x045\07\x01\n\n\n\x03\x04\x01\x01\x12\x035\x08&\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x036\x02,\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x036\
    \x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x036\x0b\x1d\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x036\x1e'\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x036*+\n\
    \x1b\n\x02\x04\x02\x12\x049\0:\x01\"\x0f\x20No\x20parameters\n\n\n\n\x03\
    \x04\x02\x01\x12\x039\x08%\n\n\n\x02\x04\x03\x12\x04<\0>\x01\n\n\n\x03\
    \x04\x03\x01\x12\x03<\x08&\n\x0b\n\x04\x04\x03\x02\0\x12\x03=\x024\n\x0c\
    \n\x05\x04\x03\x02\0\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x03\x02\0\x06\
    \x12\x03=\x0b\x20\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03=!/\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03=23\n\n\n\x02\x05\0\x12\x04@\0G\x01\n\n\n\x03\
    \x05\0\x01\x12\x03@\x05\x14\n\x1c\n\x04\x05\0\x02\0\x12\x03A\x02\x10\"\
    \x0f\x20Create\x20a\x20file\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03A\x02\
    \x08\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03A\x0b\x0f\n?\n\x04\x05\0\x02\x01\
    \x12\x03B\x02\x13\"2\x20Truncate/overwrite\x20a\x20file.\x20Same\x20as\
    \x20POSIX\x20O_TRUNC\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03B\x02\x0b\n\
    \x0c\n\x05\x05\0\x02\x01\x02\x12\x03B\x0e\x12\n\x1f\n\x04\x05\0\x02\x02\
    \x12\x03C\x02\x10\"\x12\x20Append\x20to\x20a\x20file\n\n\x0c\n\x05\x05\0\
    \x02\x02\x01\x12\x03C\x02\x08\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03C\x0b\
    \x0f\n7\n\x04\x05\0\x02\x03\x12\x03D\x02\x16\"*\x20File\x20with\x20reduc\
    ed\x20durability\x20guarantees.\n\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03D\
    \x02\x0e\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03D\x11\x15\n7\n\x04\x05\0\
    \x02\x04\x12\x03E\x02\x13\"*\x20Write\x20data\x20to\x20a\x20new\x20block\
    \x20when\x20appending\n\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03E\x02\x0b\n\
    \x0c\n\x05\x05\0\x02\x04\x02\x12\x03E\x0e\x12\n1\n\x04\x05\0\x02\x05\x12\
    \x03F\x02\x1a\"$\x20Enforce\x20to\x20create\x20a\x20replicate\x20file\n\
    \n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03F\x02\x12\n\x0c\n\x05\x05\0\x02\
    \x05\x02\x12\x03F\x15\x19\n\n\n\x02\x04\x04\x12\x04I\0T\x01\n\n\n\x03\
    \x04\x04\x01\x12\x03I\x08\x1a\n\x0b\n\x04\x04\x04\x02\0\x12\x03J\x02\x1a\
    \n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03J\x0b\x11\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03J\x12\x15\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03J\x18\x19\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03K\x02(\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03K\x02\n\n\x0c\
    \n\x05\x04\x04\x02\x01\x06\x12\x03K\x0b\x1c\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x03K\x1d#\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03K&'\n\x0b\n\
    \x04\x04\x04\x02\x02\x12\x03L\x02!\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\
    \x03L\x02\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03L\x0b\x11\n\x0c\n\x05\
    \x04\x04\x02\x02\x01\x12\x03L\x12\x1c\n\x0c\n\x05\x04\x04\x02\x02\x03\
    \x12\x03L\x1f\x20\n(\n\x04\x04\x04\x02\x03\x12\x03M\x02!\"\x1b\x20bits\
    \x20set\x20using\x20CreateFlag\n\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03\
    M\x02\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03M\x0b\x11\n\x0c\n\x05\x04\
    \x04\x02\x03\x01\x12\x03M\x12\x1c\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\
    \x03M\x1f\x20\n\x0b\n\x04\x04\x04\x02\x04\x12\x03N\x02!\n\x0c\n\x05\x04\
    \x04\x02\x04\x04\x12\x03N\x02\n\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03N\
    \x0b\x0f\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03N\x10\x1c\n\x0c\n\x05\
    \x04\x04\x02\x04\x03\x12\x03N\x1f\x20\n'\n\x04\x04\x04\x02\x05\x12\x03O\
    \x02\"\"\x1a\x20Short:\x20Only\x2016\x20bits\x20used\n\n\x0c\n\x05\x04\
    \x04\x02\x05\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03O\
    \x0b\x11\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03O\x12\x1d\n\x0c\n\x05\
    \x04\x04\x02\x05\x03\x12\x03O\x20!\n\x0b\n\x04\x04\x04\x02\x06\x12\x03P\
    \x02\x20\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\
    \x04\x02\x06\x05\x12\x03P\x0b\x11\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\
    \x03P\x12\x1b\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03P\x1e\x1f\n\x0b\n\
    \x04\x04\x04\x02\x07\x12\x03Q\x02@\n\x0c\n\x05\x04\x04\x02\x07\x04\x12\
    \x03Q\x02\n\n\x0c\n\x05\x04\x04\x02\x07\x06\x12\x03Q\x0b%\n\x0c\n\x05\
    \x04\x04\x02\x07\x01\x12\x03Q&;\n\x0c\n\x05\x04\x04\x02\x07\x03\x12\x03Q\
    >?\n\x0b\n\x04\x04\x04\x02\x08\x12\x03R\x02*\n\x0c\n\x05\x04\x04\x02\x08\
    \x04\x12\x03R\x02\n\n\x0c\n\x05\x04\x04\x02\x08\x06\x12\x03R\x0b\x1c\n\
    \x0c\n\x05\x04\x04\x02\x08\x01\x12\x03R\x1d%\n\x0c\n\x05\x04\x04\x02\x08\
    \x03\x12\x03R()\n\x0b\n\x04\x04\x04\x02\t\x12\x03S\x02$\n\x0c\n\x05\x04\
    \x04\x02\t\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x04\x02\t\x05\x12\x03S\x0b\
    \x11\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03S\x12\x1e\n\x0c\n\x05\x04\x04\
    \x02\t\x03\x12\x03S!#\n\n\n\x02\x04\x05\x12\x04V\0X\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03V\x08\x1b\n\x0b\n\x04\x04\x05\x02\0\x12\x03W\x02&\n\x0c\
    \n\x05\x04\x05\x02\0\x04\x12\x03W\x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\
    \x12\x03W\x0b\x1e\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03W\x1f!\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03W$%\n\n\n\x02\x04\x06\x12\x04Z\0^\x01\n\n\
    \n\x03\x04\x06\x01\x12\x03Z\x08\x1a\n\x0b\n\x04\x04\x06\x02\0\x12\x03[\
    \x02\x1a\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03[\x02\n\n\x0c\n\x05\x04\
    \x06\x02\0\x05\x12\x03[\x0b\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03[\
    \x12\x15\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03[\x18\x19\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03\\\x02!\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03\\\
    \x02\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03\\\x0b\x11\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03\\\x12\x1c\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x03\\\x1f\x20\n(\n\x04\x04\x06\x02\x02\x12\x03]\x02\x1b\"\x1b\x20bits\
    \x20set\x20using\x20CreateFlag\n\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03\
    ]\x02\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03]\x0b\x11\n\x0c\n\x05\x04\
    \x06\x02\x02\x01\x12\x03]\x12\x16\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\
    \x03]\x19\x1a\n\n\n\x02\x04\x07\x12\x04`\0c\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03`\x08\x1b\n\x0b\n\x04\x04\x07\x02\0\x12\x03a\x02'\n\x0c\n\x05\
    \x04\x07\x02\0\x04\x12\x03a\x02\n\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03a\
    \x0b\x1c\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03a\x1d\"\n\x0c\n\x05\x04\
    \x07\x02\0\x03\x12\x03a%&\n\x0b\n\x04\x04\x07\x02\x01\x12\x03b\x02(\n\
    \x0c\n\x05\x04\x07\x02\x01\x04\x12\x03b\x02\n\n\x0c\n\x05\x04\x07\x02\
    \x01\x06\x12\x03b\x0b\x1e\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03b\x1f#\
    \n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03b&'\n\n\n\x02\x04\x08\x12\x04e\0\
    h\x01\n\n\n\x03\x04\x08\x01\x12\x03e\x08\"\n\x0b\n\x04\x04\x08\x02\0\x12\
    \x03f\x02\x1a\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03f\x02\n\n\x0c\n\x05\
    \x04\x08\x02\0\x05\x12\x03f\x0b\x11\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03f\x12\x15\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03f\x18\x19\n'\n\x04\
    \x04\x08\x02\x01\x12\x03g\x02\"\"\x1a\x20Short:\x20Only\x2016\x20bits\
    \x20used\n\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03g\x02\n\n\x0c\n\x05\
    \x04\x08\x02\x01\x05\x12\x03g\x0b\x11\n\x0c\n\x05\x04\x08\x02\x01\x01\
    \x12\x03g\x12\x1d\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03g\x20!\n\n\n\
    \x02\x04\t\x12\x04j\0l\x01\n\n\n\x03\x04\t\x01\x12\x03j\x08#\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03k\x02\x1b\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03k\x02\n\
    \n\x0c\n\x05\x04\t\x02\0\x05\x12\x03k\x0b\x0f\n\x0c\n\x05\x04\t\x02\0\
    \x01\x12\x03k\x10\x16\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03k\x19\x1a\n\n\n\
    \x02\x04\n\x12\x04n\0q\x01\n\n\n\x03\x04\n\x01\x12\x03n\x08$\n\x0b\n\x04\
    \x04\n\x02\0\x12\x03o\x02\x1a\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03o\x02\n\
    \n\x0c\n\x05\x04\n\x02\0\x05\x12\x03o\x0b\x11\n\x0c\n\x05\x04\n\x02\0\
    \x01\x12\x03o\x12\x15\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03o\x18\x19\n\x0b\
    \n\x04\x04\n\x02\x01\x12\x03p\x02!\n\x0c\n\x05\x04\n\x02\x01\x04\x12\x03\
    p\x02\n\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03p\x0b\x11\n\x0c\n\x05\x04\n\
    \x02\x01\x01\x12\x03p\x12\x1c\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03p\x1f\
    \x20\n\x1b\n\x02\x04\x0b\x12\x04s\0t\x01\"\x0f\x20void\x20response\n\n\n\
    \n\x03\x04\x0b\x01\x12\x03s\x08%\n\n\n\x02\x04\x0c\x12\x04v\0x\x01\n\n\n\
    \x03\x04\x0c\x01\x12\x03v\x08&\n\x0b\n\x04\x04\x0c\x02\0\x12\x03w\x02\
    \x1a\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03w\x02\n\n\x0c\n\x05\x04\x0c\
    \x02\0\x05\x12\x03w\x0b\x11\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03w\x12\
    \x15\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03w\x18\x19\n\n\n\x02\x04\r\x12\
    \x04z\0{\x01\n\n\n\x03\x04\r\x01\x12\x03z\x08'\n\n\n\x02\x04\x0e\x12\x04\
    }\0\x7f\x01\n\n\n\x03\x04\x0e\x01\x12\x03}\x08$\n\x0b\n\x04\x04\x0e\x02\
    \0\x12\x03~\x02\x1b\n\x0c\n\x05\x04\x0e\x02\0\x04\x12\x03~\x02\n\n\x0c\n\
    \x05\x04\x0e\x02\0\x05\x12\x03~\x0b\x11\n\x0c\n\x05\x04\x0e\x02\0\x01\
    \x12\x03~\x12\x16\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03~\x19\x1a\n\x0c\n\
    \x02\x04\x0f\x12\x06\x81\x01\0\x83\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\x81\x01\x08%\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x82\x01\x025\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04\x82\x01\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\
    \x12\x04\x82\x01\x0b\"\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x82\x01#0\n\r\
    \n\x05\x04\x0f\x02\0\x03\x12\x04\x82\x0134\n\x1c\n\x02\x04\x10\x12\x06\
    \x85\x01\0\x86\x01\x01\"\x0e\x20void\x20request\n\n\x0b\n\x03\x04\x10\
    \x01\x12\x04\x85\x01\x08&\n\x0c\n\x02\x04\x11\x12\x06\x88\x01\0\x8a\x01\
    \x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x88\x01\x08'\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\x89\x01\x020\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x89\x01\
    \x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x89\x01\x0b\"\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\x89\x01#+\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x89\
    \x01./\n\x0c\n\x02\x04\x12\x12\x06\x8c\x01\0\x8f\x01\x01\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\x8c\x01\x08!\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x8d\x01\
    \x02\x1a\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\x8d\x01\x02\n\n\r\n\x05\x04\
    \x12\x02\0\x05\x12\x04\x8d\x01\x0b\x11\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\x8d\x01\x12\x15\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x8d\x01\x18\x19\
    \n\x0c\n\x04\x04\x12\x02\x01\x12\x04\x8e\x01\x02,\n\r\n\x05\x04\x12\x02\
    \x01\x04\x12\x04\x8e\x01\x02\n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\x8e\
    \x01\x0b\x1c\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x8e\x01\x1d'\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\x8e\x01*+\n\x1d\n\x02\x04\x13\x12\x06\
    \x91\x01\0\x92\x01\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04\x13\
    \x01\x12\x04\x91\x01\x08\"\n\x0c\n\x02\x04\x14\x12\x06\x94\x01\0\x98\x01\
    \x01\n\x0b\n\x03\x04\x14\x01\x12\x04\x94\x01\x08\x1c\n\x0c\n\x04\x04\x14\
    \x02\0\x12\x04\x95\x01\x02\x1a\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x95\
    \x01\x02\n\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\x95\x01\x0b\x11\n\r\n\x05\
    \x04\x14\x02\0\x01\x12\x04\x95\x01\x12\x15\n\r\n\x05\x04\x14\x02\0\x03\
    \x12\x04\x95\x01\x18\x19\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\x96\x01\x02\
    \x1f\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x96\x01\x02\n\n\r\n\x05\x04\
    \x14\x02\x01\x05\x12\x04\x96\x01\x0b\x11\n\r\n\x05\x04\x14\x02\x01\x01\
    \x12\x04\x96\x01\x12\x1a\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x96\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\x97\x01\x02\x20\n\r\n\x05\
    \x04\x14\x02\x02\x04\x12\x04\x97\x01\x02\n\n\r\n\x05\x04\x14\x02\x02\x05\
    \x12\x04\x97\x01\x0b\x11\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\x97\x01\
    \x12\x1b\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x97\x01\x1e\x1f\n\x1d\n\
    \x02\x04\x15\x12\x06\x9a\x01\0\x9b\x01\x01\"\x0f\x20void\x20response\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\x9a\x01\x08\x1d\n\x0c\n\x02\x04\x16\x12\
    \x06\x9d\x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x9d\x01\x08\
    \x20\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x9e\x01\x02$\n\r\n\x05\x04\x16\
    \x02\0\x04\x12\x04\x9e\x01\x02\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\x9e\
    \x01\x0b\x1d\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x9e\x01\x1e\x1f\n\r\n\
    \x05\x04\x16\x02\0\x03\x12\x04\x9e\x01\"#\n\x0c\n\x04\x04\x16\x02\x01\
    \x12\x04\x9f\x01\x02\x1a\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\x9f\x01\
    \x02\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\x9f\x01\x0b\x11\n\r\n\x05\
    \x04\x16\x02\x01\x01\x12\x04\x9f\x01\x12\x15\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\x9f\x01\x18\x19\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xa0\x01\
    \x02\x1d\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xa0\x01\x02\n\n\r\n\x05\
    \x04\x16\x02\x02\x05\x12\x04\xa0\x01\x0b\x11\n\r\n\x05\x04\x16\x02\x02\
    \x01\x12\x04\xa0\x01\x12\x18\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xa0\
    \x01\x1b\x1c\n/\n\x04\x04\x16\x02\x03\x12\x04\xa1\x01\x02+\"!\x20default\
    \x20to\x20GRANDFATHER_INODE_ID\n\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\
    \xa1\x01\x02\n\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xa1\x01\x0b\x11\n\r\
    \n\x05\x04\x16\x02\x03\x01\x12\x04\xa1\x01\x12\x18\n\r\n\x05\x04\x16\x02\
    \x03\x03\x12\x04\xa1\x01\x1b\x1c\n\r\n\x05\x04\x16\x02\x03\x08\x12\x04\
    \xa1\x01\x1d*\n\r\n\x05\x04\x16\x02\x03\x07\x12\x04\xa1\x01()\n\x1d\n\
    \x02\x04\x17\x12\x06\xa4\x01\0\xa5\x01\x01\"\x0f\x20void\x20response\n\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\xa4\x01\x08!\n\x0c\n\x02\x05\x01\x12\x06\
    \xa7\x01\0\xa9\x01\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xa7\x01\x05\x16\n\
    ,\n\x04\x05\x01\x02\0\x12\x04\xa8\x01\x02\x15\"\x1e\x20avoid\x20writing\
    \x20to\x20local\x20node.\n\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xa8\x01\
    \x02\x10\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xa8\x01\x13\x14\n\x0c\n\x02\
    \x04\x18\x12\x06\xab\x01\0\xb3\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xab\x01\x08\x1c\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xac\x01\x02\x1a\n\r\n\
    \x05\x04\x18\x02\0\x04\x12\x04\xac\x01\x02\n\n\r\n\x05\x04\x18\x02\0\x05\
    \x12\x04\xac\x01\x0b\x11\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xac\x01\x12\
    \x15\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xac\x01\x18\x19\n\x0c\n\x04\x04\
    \x18\x02\x01\x12\x04\xad\x01\x02!\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\
    \xad\x01\x02\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xad\x01\x0b\x11\n\r\
    \n\x05\x04\x18\x02\x01\x01\x12\x04\xad\x01\x12\x1c\n\r\n\x05\x04\x18\x02\
    \x01\x03\x12\x04\xad\x01\x1f\x20\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xae\
    \x01\x02+\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xae\x01\x02\n\n\r\n\x05\
    \x04\x18\x02\x02\x06\x12\x04\xae\x01\x0b\x1d\n\r\n\x05\x04\x18\x02\x02\
    \x01\x12\x04\xae\x01\x1e&\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xae\x01)\
    *\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xaf\x01\x02.\n\r\n\x05\x04\x18\x02\
    \x03\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\x18\x02\x03\x06\x12\x04\xaf\
    \x01\x0b\x1c\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xaf\x01\x1d)\n\r\n\
    \x05\x04\x18\x02\x03\x03\x12\x04\xaf\x01,-\n%\n\x04\x04\x18\x02\x04\x12\
    \x04\xb0\x01\x02+\"\x17\x20default\x20as\x20a\x20bogus\x20id\n\n\r\n\x05\
    \x04\x18\x02\x04\x04\x12\x04\xb0\x01\x02\n\n\r\n\x05\x04\x18\x02\x04\x05\
    \x12\x04\xb0\x01\x0b\x11\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xb0\x01\
    \x12\x18\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xb0\x01\x1b\x1c\n\r\n\x05\
    \x04\x18\x02\x04\x08\x12\x04\xb0\x01\x1d*\n\r\n\x05\x04\x18\x02\x04\x07\
    \x12\x04\xb0\x01()\n8\n\x04\x04\x18\x02\x05\x12\x04\xb1\x01\x02#\"*the\
    \x20set\x20of\x20datanodes\x20to\x20use\x20for\x20the\x20block\n\n\r\n\
    \x05\x04\x18\x02\x05\x04\x12\x04\xb1\x01\x02\n\n\r\n\x05\x04\x18\x02\x05\
    \x05\x12\x04\xb1\x01\x0b\x11\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xb1\
    \x01\x12\x1e\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\xb1\x01!\"\n!\n\x04\
    \x04\x18\x02\x06\x12\x04\xb2\x01\x02'\"\x13\x20default\x20to\x20empty.\n\
    \n\r\n\x05\x04\x18\x02\x06\x04\x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x18\
    \x02\x06\x06\x12\x04\xb2\x01\x0b\x1c\n\r\n\x05\x04\x18\x02\x06\x01\x12\
    \x04\xb2\x01\x1d\"\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\xb2\x01%&\n\x0c\
    \n\x02\x04\x19\x12\x06\xb5\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\
    \x04\xb5\x01\x08\x1d\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xb6\x01\x02'\n\r\
    \n\x05\x04\x19\x02\0\x04\x12\x04\xb6\x01\x02\n\n\r\n\x05\x04\x19\x02\0\
    \x06\x12\x04\xb6\x01\x0b\x1c\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xb6\x01\
    \x1d\"\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xb6\x01%&\n\x0c\n\x02\x04\x1a\
    \x12\x06\xb9\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xb9\x01\
    \x08)\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xba\x01\x02\x1a\n\r\n\x05\x04\
    \x1a\x02\0\x04\x12\x04\xba\x01\x02\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\
    \xba\x01\x0b\x11\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xba\x01\x12\x15\n\r\
    \n\x05\x04\x1a\x02\0\x03\x12\x04\xba\x01\x18\x19\n\x0c\n\x04\x04\x1a\x02\
    \x01\x12\x04\xbb\x01\x02&\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xbb\x01\
    \x02\n\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xbb\x01\x0b\x1d\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\xbb\x01\x1e!\n\r\n\x05\x04\x1a\x02\x01\x03\
    \x12\x04\xbb\x01$%\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xbc\x01\x02+\n\r\
    \n\x05\x04\x1a\x02\x02\x04\x12\x04\xbc\x01\x02\n\n\r\n\x05\x04\x1a\x02\
    \x02\x06\x12\x04\xbc\x01\x0b\x1c\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\
    \xbc\x01\x1d&\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xbc\x01)*\n\x0c\n\
    \x04\x04\x1a\x02\x03\x12\x04\xbd\x01\x02*\n\r\n\x05\x04\x1a\x02\x03\x04\
    \x12\x04\xbd\x01\x02\n\n\r\n\x05\x04\x1a\x02\x03\x06\x12\x04\xbd\x01\x0b\
    \x1c\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xbd\x01\x1d%\n\r\n\x05\x04\
    \x1a\x02\x03\x03\x12\x04\xbd\x01()\n\x0c\n\x04\x04\x1a\x02\x04\x12\x04\
    \xbe\x01\x02)\n\r\n\x05\x04\x1a\x02\x04\x04\x12\x04\xbe\x01\x02\n\n\r\n\
    \x05\x04\x1a\x02\x04\x05\x12\x04\xbe\x01\x0b\x11\n\r\n\x05\x04\x1a\x02\
    \x04\x01\x12\x04\xbe\x01\x12$\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xbe\
    \x01'(\n\x0c\n\x04\x04\x1a\x02\x05\x12\x04\xbf\x01\x02!\n\r\n\x05\x04\
    \x1a\x02\x05\x04\x12\x04\xbf\x01\x02\n\n\r\n\x05\x04\x1a\x02\x05\x05\x12\
    \x04\xbf\x01\x0b\x11\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xbf\x01\x12\
    \x1c\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\xbf\x01\x1f\x20\n\x0c\n\x04\
    \x04\x1a\x02\x06\x12\x04\xc0\x01\x02+\n\r\n\x05\x04\x1a\x02\x06\x04\x12\
    \x04\xc0\x01\x02\n\n\r\n\x05\x04\x1a\x02\x06\x05\x12\x04\xc0\x01\x0b\x11\
    \n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xc0\x01\x12&\n\r\n\x05\x04\x1a\
    \x02\x06\x03\x12\x04\xc0\x01)*\n/\n\x04\x04\x1a\x02\x07\x12\x04\xc1\x01\
    \x02+\"!\x20default\x20to\x20GRANDFATHER_INODE_ID\n\n\r\n\x05\x04\x1a\
    \x02\x07\x04\x12\x04\xc1\x01\x02\n\n\r\n\x05\x04\x1a\x02\x07\x05\x12\x04\
    \xc1\x01\x0b\x11\n\r\n\x05\x04\x1a\x02\x07\x01\x12\x04\xc1\x01\x12\x18\n\
    \r\n\x05\x04\x1a\x02\x07\x03\x12\x04\xc1\x01\x1b\x1c\n\r\n\x05\x04\x1a\
    \x02\x07\x08\x12\x04\xc1\x01\x1d*\n\r\n\x05\x04\x1a\x02\x07\x07\x12\x04\
    \xc1\x01()\n\x0c\n\x02\x04\x1b\x12\x06\xc4\x01\0\xc6\x01\x01\n\x0b\n\x03\
    \x04\x1b\x01\x12\x04\xc4\x01\x08*\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xc5\
    \x01\x02'\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xc5\x01\x02\n\n\r\n\x05\
    \x04\x1b\x02\0\x06\x12\x04\xc5\x01\x0b\x1c\n\r\n\x05\x04\x1b\x02\0\x01\
    \x12\x04\xc5\x01\x1d\"\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xc5\x01%&\n\
    \x0c\n\x02\x04\x1c\x12\x06\xc8\x01\0\xcd\x01\x01\n\x0b\n\x03\x04\x1c\x01\
    \x12\x04\xc8\x01\x08\x1c\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xc9\x01\x02\
    \x1a\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xc9\x01\x02\n\n\r\n\x05\x04\x1c\
    \x02\0\x05\x12\x04\xc9\x01\x0b\x11\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xc9\x01\x12\x15\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xc9\x01\x18\x19\n\
    \x0c\n\x04\x04\x1c\x02\x01\x12\x04\xca\x01\x02!\n\r\n\x05\x04\x1c\x02\
    \x01\x04\x12\x04\xca\x01\x02\n\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xca\
    \x01\x0b\x11\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xca\x01\x12\x1c\n\r\n\
    \x05\x04\x1c\x02\x01\x03\x12\x04\xca\x01\x1f\x20\n\x0c\n\x04\x04\x1c\x02\
    \x02\x12\x04\xcb\x01\x02'\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xcb\x01\
    \x02\n\n\r\n\x05\x04\x1c\x02\x02\x06\x12\x04\xcb\x01\x0b\x1d\n\r\n\x05\
    \x04\x1c\x02\x02\x01\x12\x04\xcb\x01\x1e\"\n\r\n\x05\x04\x1c\x02\x02\x03\
    \x12\x04\xcb\x01%&\n/\n\x04\x04\x1c\x02\x03\x12\x04\xcc\x01\x02+\"!\x20d\
    efault\x20to\x20GRANDFATHER_INODE_ID\n\n\r\n\x05\x04\x1c\x02\x03\x04\x12\
    \x04\xcc\x01\x02\n\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xcc\x01\x0b\x11\
    \n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xcc\x01\x12\x18\n\r\n\x05\x04\x1c\
    \x02\x03\x03\x12\x04\xcc\x01\x1b\x1c\n\r\n\x05\x04\x1c\x02\x03\x08\x12\
    \x04\xcc\x01\x1d*\n\r\n\x05\x04\x1c\x02\x03\x07\x12\x04\xcc\x01()\n\x0c\
    \n\x02\x04\x1d\x12\x06\xcf\x01\0\xd1\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\
    \x04\xcf\x01\x08\x1d\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xd0\x01\x02\x1b\n\
    \r\n\x05\x04\x1d\x02\0\x04\x12\x04\xd0\x01\x02\n\n\r\n\x05\x04\x1d\x02\0\
    \x05\x12\x04\xd0\x01\x0b\x0f\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xd0\x01\
    \x10\x16\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xd0\x01\x19\x1a\n\x0c\n\x02\
    \x04\x1e\x12\x06\xd3\x01\0\xd5\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \xd3\x01\x08#\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xd4\x01\x02(\n\r\n\x05\
    \x04\x1e\x02\0\x04\x12\x04\xd4\x01\x02\n\n\r\n\x05\x04\x1e\x02\0\x06\x12\
    \x04\xd4\x01\x0b\x1c\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xd4\x01\x1d#\n\
    \r\n\x05\x04\x1e\x02\0\x03\x12\x04\xd4\x01&'\n\x1d\n\x02\x04\x1f\x12\x06\
    \xd7\x01\0\xd8\x01\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\xd7\x01\x08$\n\x0c\n\x02\x04\x20\x12\x06\xda\x01\0\xdd\x01\
    \x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xda\x01\x08\x1a\n\x0c\n\x04\x04\x20\
    \x02\0\x12\x04\xdb\x01\x02\x1a\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xdb\
    \x01\x02\n\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xdb\x01\x0b\x11\n\r\n\x05\
    \x04\x20\x02\0\x01\x12\x04\xdb\x01\x12\x15\n\r\n\x05\x04\x20\x02\0\x03\
    \x12\x04\xdb\x01\x18\x19\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xdc\x01\x02\
    \x1b\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\xdc\x01\x02\n\n\r\n\x05\x04\
    \x20\x02\x01\x05\x12\x04\xdc\x01\x0b\x11\n\r\n\x05\x04\x20\x02\x01\x01\
    \x12\x04\xdc\x01\x12\x16\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xdc\x01\
    \x19\x1a\n\x1d\n\x02\x04!\x12\x06\xdf\x01\0\xe0\x01\x01\"\x0f\x20void\
    \x20response\n\n\x0b\n\x03\x04!\x01\x12\x04\xdf\x01\x08\x1b\n\x0c\n\x02\
    \x04\"\x12\x06\xe2\x01\0\xe6\x01\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xe2\
    \x01\x08\x1c\n\x0c\n\x04\x04\"\x02\0\x12\x04\xe3\x01\x02\x1a\n\r\n\x05\
    \x04\"\x02\0\x04\x12\x04\xe3\x01\x02\n\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xe3\x01\x0b\x11\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xe3\x01\x12\x15\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xe3\x01\x18\x19\n\x0c\n\x04\x04\"\x02\x01\
    \x12\x04\xe4\x01\x02\x20\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xe4\x01\x02\
    \n\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xe4\x01\x0b\x11\n\r\n\x05\x04\"\
    \x02\x01\x01\x12\x04\xe4\x01\x12\x1b\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\
    \xe4\x01\x1e\x1f\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xe5\x01\x02!\n\r\n\
    \x05\x04\"\x02\x02\x04\x12\x04\xe5\x01\x02\n\n\r\n\x05\x04\"\x02\x02\x05\
    \x12\x04\xe5\x01\x0b\x11\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xe5\x01\x12\
    \x1c\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xe5\x01\x1f\x20\n\x0c\n\x02\x04\
    #\x12\x06\xe8\x01\0\xea\x01\x01\n\x0b\n\x03\x04#\x01\x12\x04\xe8\x01\x08\
    \x1d\n\x0c\n\x04\x04#\x02\0\x12\x04\xe9\x01\x02\x1b\n\r\n\x05\x04#\x02\0\
    \x04\x12\x04\xe9\x01\x02\n\n\r\n\x05\x04#\x02\0\x05\x12\x04\xe9\x01\x0b\
    \x0f\n\r\n\x05\x04#\x02\0\x01\x12\x04\xe9\x01\x10\x16\n\r\n\x05\x04#\x02\
    \0\x03\x12\x04\xe9\x01\x19\x1a\n\x0c\n\x02\x04$\x12\x06\xec\x01\0\xef\
    \x01\x01\n\x0b\n\x03\x04$\x01\x12\x04\xec\x01\x08\x1a\n\x0c\n\x04\x04$\
    \x02\0\x12\x04\xed\x01\x02\x1a\n\r\n\x05\x04$\x02\0\x04\x12\x04\xed\x01\
    \x02\n\n\r\n\x05\x04$\x02\0\x05\x12\x04\xed\x01\x0b\x11\n\r\n\x05\x04$\
    \x02\0\x01\x12\x04\xed\x01\x12\x15\n\r\n\x05\x04$\x02\0\x03\x12\x04\xed\
    \x01\x18\x19\n\x0c\n\x04\x04$\x02\x01\x12\x04\xee\x01\x02\x1a\n\r\n\x05\
    \x04$\x02\x01\x04\x12\x04\xee\x01\x02\n\n\r\n\x05\x04$\x02\x01\x05\x12\
    \x04\xee\x01\x0b\x11\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xee\x01\x12\x15\
    \n\r\n\x05\x04$\x02\x01\x03\x12\x04\xee\x01\x18\x19\n\x0c\n\x02\x04%\x12\
    \x06\xf1\x01\0\xf3\x01\x01\n\x0b\n\x03\x04%\x01\x12\x04\xf1\x01\x08\x1b\
    \n\x0c\n\x04\x04%\x02\0\x12\x04\xf2\x01\x02\x1b\n\r\n\x05\x04%\x02\0\x04\
    \x12\x04\xf2\x01\x02\n\n\r\n\x05\x04%\x02\0\x05\x12\x04\xf2\x01\x0b\x0f\
    \n\r\n\x05\x04%\x02\0\x01\x12\x04\xf2\x01\x10\x16\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\xf2\x01\x19\x1a\n\x0c\n\x02\x04&\x12\x06\xf6\x01\0\xfb\x01\
    \x01\n\x0b\n\x03\x04&\x01\x12\x04\xf6\x01\x08\x1b\n\x0c\n\x04\x04&\x02\0\
    \x12\x04\xf7\x01\x02\x1a\n\r\n\x05\x04&\x02\0\x04\x12\x04\xf7\x01\x02\n\
    \n\r\n\x05\x04&\x02\0\x05\x12\x04\xf7\x01\x0b\x11\n\r\n\x05\x04&\x02\0\
    \x01\x12\x04\xf7\x01\x12\x15\n\r\n\x05\x04&\x02\0\x03\x12\x04\xf7\x01\
    \x18\x19\n\x0c\n\x04\x04&\x02\x01\x12\x04\xf8\x01\x02\x1a\n\r\n\x05\x04&\
    \x02\x01\x04\x12\x04\xf8\x01\x02\n\n\r\n\x05\x04&\x02\x01\x05\x12\x04\
    \xf8\x01\x0b\x11\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xf8\x01\x12\x15\n\r\
    \n\x05\x04&\x02\x01\x03\x12\x04\xf8\x01\x18\x19\n\x0c\n\x04\x04&\x02\x02\
    \x12\x04\xf9\x01\x02\"\n\r\n\x05\x04&\x02\x02\x04\x12\x04\xf9\x01\x02\n\
    \n\r\n\x05\x04&\x02\x02\x05\x12\x04\xf9\x01\x0b\x0f\n\r\n\x05\x04&\x02\
    \x02\x01\x12\x04\xf9\x01\x10\x1d\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xf9\
    \x01\x20!\n\x0c\n\x04\x04&\x02\x03\x12\x04\xfa\x01\x02\x20\n\r\n\x05\x04\
    &\x02\x03\x04\x12\x04\xfa\x01\x02\n\n\r\n\x05\x04&\x02\x03\x05\x12\x04\
    \xfa\x01\x0b\x0f\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xfa\x01\x10\x1b\n\r\
    \n\x05\x04&\x02\x03\x03\x12\x04\xfa\x01\x1e\x1f\n\x1d\n\x02\x04'\x12\x06\
    \xfd\x01\0\xfe\x01\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04'\x01\
    \x12\x04\xfd\x01\x08\x1c\n\x0c\n\x02\x04(\x12\x06\x80\x02\0\x83\x02\x01\
    \n\x0b\n\x03\x04(\x01\x12\x04\x80\x02\x08\x1a\n\x0c\n\x04\x04(\x02\0\x12\
    \x04\x81\x02\x02\x1a\n\r\n\x05\x04(\x02\0\x04\x12\x04\x81\x02\x02\n\n\r\
    \n\x05\x04(\x02\0\x05\x12\x04\x81\x02\x0b\x11\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\x81\x02\x12\x15\n\r\n\x05\x04(\x02\0\x03\x12\x04\x81\x02\x18\
    \x19\n\x0c\n\x04\x04(\x02\x01\x12\x04\x82\x02\x02\x1e\n\r\n\x05\x04(\x02\
    \x01\x04\x12\x04\x82\x02\x02\n\n\r\n\x05\x04(\x02\x01\x05\x12\x04\x82\
    \x02\x0b\x0f\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x82\x02\x10\x19\n\r\n\
    \x05\x04(\x02\x01\x03\x12\x04\x82\x02\x1c\x1d\n\x0c\n\x02\x04)\x12\x06\
    \x85\x02\0\x87\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\x85\x02\x08\x1b\n\
    \x0c\n\x04\x04)\x02\0\x12\x04\x86\x02\x04\x1d\n\r\n\x05\x04)\x02\0\x04\
    \x12\x04\x86\x02\x04\x0c\n\r\n\x05\x04)\x02\0\x05\x12\x04\x86\x02\r\x11\
    \n\r\n\x05\x04)\x02\0\x01\x12\x04\x86\x02\x12\x18\n\r\n\x05\x04)\x02\0\
    \x03\x12\x04\x86\x02\x1b\x1c\n\x0c\n\x02\x04*\x12\x06\x89\x02\0\x8e\x02\
    \x01\n\x0b\n\x03\x04*\x01\x12\x04\x89\x02\x08\x1a\n\x0c\n\x04\x04*\x02\0\
    \x12\x04\x8a\x02\x02\x1a\n\r\n\x05\x04*\x02\0\x04\x12\x04\x8a\x02\x02\n\
    \n\r\n\x05\x04*\x02\0\x05\x12\x04\x8a\x02\x0b\x11\n\r\n\x05\x04*\x02\0\
    \x01\x12\x04\x8a\x02\x12\x15\n\r\n\x05\x04*\x02\0\x03\x12\x04\x8a\x02\
    \x18\x19\n\x0c\n\x04\x04*\x02\x01\x12\x04\x8b\x02\x02(\n\r\n\x05\x04*\
    \x02\x01\x04\x12\x04\x8b\x02\x02\n\n\r\n\x05\x04*\x02\x01\x06\x12\x04\
    \x8b\x02\x0b\x1c\n\r\n\x05\x04*\x02\x01\x01\x12\x04\x8b\x02\x1d#\n\r\n\
    \x05\x04*\x02\x01\x03\x12\x04\x8b\x02&'\n\x0c\n\x04\x04*\x02\x02\x12\x04\
    \x8c\x02\x02!\n\r\n\x05\x04*\x02\x02\x04\x12\x04\x8c\x02\x02\n\n\r\n\x05\
    \x04*\x02\x02\x05\x12\x04\x8c\x02\x0b\x0f\n\r\n\x05\x04*\x02\x02\x01\x12\
    \x04\x8c\x02\x10\x1c\n\r\n\x05\x04*\x02\x02\x03\x12\x04\x8c\x02\x1f\x20\
    \n\x0c\n\x04\x04*\x02\x03\x12\x04\x8d\x02\x02*\n\r\n\x05\x04*\x02\x03\
    \x04\x12\x04\x8d\x02\x02\n\n\r\n\x05\x04*\x02\x03\x06\x12\x04\x8d\x02\
    \x0b\x1c\n\r\n\x05\x04*\x02\x03\x01\x12\x04\x8d\x02\x1d%\n\r\n\x05\x04*\
    \x02\x03\x03\x12\x04\x8d\x02()\n\x0c\n\x02\x04+\x12\x06\x8f\x02\0\x91\
    \x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\x8f\x02\x08\x1b\n\x0c\n\x04\x04+\
    \x02\0\x12\x04\x90\x02\x04\x1d\n\r\n\x05\x04+\x02\0\x04\x12\x04\x90\x02\
    \x04\x0c\n\r\n\x05\x04+\x02\0\x05\x12\x04\x90\x02\r\x11\n\r\n\x05\x04+\
    \x02\0\x01\x12\x04\x90\x02\x12\x18\n\r\n\x05\x04+\x02\0\x03\x12\x04\x90\
    \x02\x1b\x1c\n\x0c\n\x02\x04,\x12\x06\x93\x02\0\x97\x02\x01\n\x0b\n\x03\
    \x04,\x01\x12\x04\x93\x02\x08\x1e\n\x0c\n\x04\x04,\x02\0\x12\x04\x94\x02\
    \x02\x1a\n\r\n\x05\x04,\x02\0\x04\x12\x04\x94\x02\x02\n\n\r\n\x05\x04,\
    \x02\0\x05\x12\x04\x94\x02\x0b\x11\n\r\n\x05\x04,\x02\0\x01\x12\x04\x94\
    \x02\x12\x15\n\r\n\x05\x04,\x02\0\x03\x12\x04\x94\x02\x18\x19\n\x0c\n\
    \x04\x04,\x02\x01\x12\x04\x95\x02\x02\x20\n\r\n\x05\x04,\x02\x01\x04\x12\
    \x04\x95\x02\x02\n\n\r\n\x05\x04,\x02\x01\x05\x12\x04\x95\x02\x0b\x10\n\
    \r\n\x05\x04,\x02\x01\x01\x12\x04\x95\x02\x11\x1b\n\r\n\x05\x04,\x02\x01\
    \x03\x12\x04\x95\x02\x1e\x1f\n\x0c\n\x04\x04,\x02\x02\x12\x04\x96\x02\
    \x02!\n\r\n\x05\x04,\x02\x02\x04\x12\x04\x96\x02\x02\n\n\r\n\x05\x04,\
    \x02\x02\x05\x12\x04\x96\x02\x0b\x0f\n\r\n\x05\x04,\x02\x02\x01\x12\x04\
    \x96\x02\x10\x1c\n\r\n\x05\x04,\x02\x02\x03\x12\x04\x96\x02\x1f\x20\n\
    \x0c\n\x02\x04-\x12\x06\x98\x02\0\x9a\x02\x01\n\x0b\n\x03\x04-\x01\x12\
    \x04\x98\x02\x08\x1f\n\x0c\n\x04\x04-\x02\0\x12\x04\x99\x02\x02-\n\r\n\
    \x05\x04-\x02\0\x04\x12\x04\x99\x02\x02\n\n\r\n\x05\x04-\x02\0\x06\x12\
    \x04\x99\x02\x0b\x20\n\r\n\x05\x04-\x02\0\x01\x12\x04\x99\x02!(\n\r\n\
    \x05\x04-\x02\0\x03\x12\x04\x99\x02+,\n#\n\x02\x04.\x12\x06\x9c\x02\0\
    \x9d\x02\x01\"\x15\x20no\x20input\x20parameters\n\n\x0b\n\x03\x04.\x01\
    \x12\x04\x9c\x02\x08.\n\x0c\n\x02\x04/\x12\x06\x9e\x02\0\xa0\x02\x01\n\
    \x0b\n\x03\x04/\x01\x12\x04\x9e\x02\x08/\n\x0c\n\x04\x04/\x02\0\x12\x04\
    \x9f\x02\x02G\n\r\n\x05\x04/\x02\0\x04\x12\x04\x9f\x02\x02\n\n\r\n\x05\
    \x04/\x02\0\x06\x12\x04\x9f\x02\x0b-\n\r\n\x05\x04/\x02\0\x01\x12\x04\
    \x9f\x02.B\n\r\n\x05\x04/\x02\0\x03\x12\x04\x9f\x02EF\n\x0c\n\x02\x040\
    \x12\x06\xa2\x02\0\xa6\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xa2\x02\x08)\
    \n\x0c\n\x04\x040\x02\0\x12\x04\xa3\x02\x02#\n\r\n\x05\x040\x02\0\x04\
    \x12\x04\xa3\x02\x02\n\n\r\n\x05\x040\x02\0\x05\x12\x04\xa3\x02\x0b\x11\
    \n\r\n\x05\x040\x02\0\x01\x12\x04\xa3\x02\x12\x1e\n\r\n\x05\x040\x02\0\
    \x03\x12\x04\xa3\x02!\"\n\x0c\n\x04\x040\x02\x01\x12\x04\xa4\x02\x02#\n\
    \r\n\x05\x040\x02\x01\x04\x12\x04\xa4\x02\x02\n\n\r\n\x05\x040\x02\x01\
    \x05\x12\x04\xa4\x02\x0b\x11\n\r\n\x05\x040\x02\x01\x01\x12\x04\xa4\x02\
    \x12\x1e\n\r\n\x05\x040\x02\x01\x03\x12\x04\xa4\x02!\"\n\x0c\n\x04\x040\
    \x02\x02\x12\x04\xa5\x02\x02!\n\r\n\x05\x040\x02\x02\x04\x12\x04\xa5\x02\
    \x02\n\n\r\n\x05\x040\x02\x02\x05\x12\x04\xa5\x02\x0b\x11\n\r\n\x05\x040\
    \x02\x02\x01\x12\x04\xa5\x02\x12\x1c\n\r\n\x05\x040\x02\x02\x03\x12\x04\
    \xa5\x02\x1f\x20\n\x0c\n\x02\x041\x12\x06\xa7\x02\0\xa9\x02\x01\n\x0b\n\
    \x03\x041\x01\x12\x04\xa7\x02\x08*\n\x0c\n\x04\x041\x02\0\x12\x04\xa8\
    \x02\x022\n\r\n\x05\x041\x02\0\x04\x12\x04\xa8\x02\x02\n\n\r\n\x05\x041\
    \x02\0\x06\x12\x04\xa8\x02\x0b\"\n\r\n\x05\x041\x02\0\x01\x12\x04\xa8\
    \x02#-\n\r\n\x05\x041\x02\0\x03\x12\x04\xa8\x0201\n\x0c\n\x02\x042\x12\
    \x06\xab\x02\0\xad\x02\x01\n\x0b\n\x03\x042\x01\x12\x04\xab\x02\x08\x1e\
    \n\x0c\n\x04\x042\x02\0\x12\x04\xac\x02\x02!\n\r\n\x05\x042\x02\0\x04\
    \x12\x04\xac\x02\x02\n\n\r\n\x05\x042\x02\0\x05\x12\x04\xac\x02\x0b\x11\
    \n\r\n\x05\x042\x02\0\x01\x12\x04\xac\x02\x12\x1c\n\r\n\x05\x042\x02\0\
    \x03\x12\x04\xac\x02\x1f\x20\n\x1c\n\x02\x043\x12\x06\xaf\x02\0\xb0\x02\
    \x01\"\x0evoid\x20response\n\n\x0b\n\x03\x043\x01\x12\x04\xaf\x02\x08\
    \x1f\n\x0c\n\x02\x044\x12\x06\xb2\x02\0\xb5\x02\x01\n\x0b\n\x03\x044\x01\
    \x12\x04\xb2\x02\x08\x20\n\x0c\n\x04\x044\x02\0\x12\x04\xb3\x02\x02\x1a\
    \n\r\n\x05\x044\x02\0\x04\x12\x04\xb3\x02\x02\n\n\r\n\x05\x044\x02\0\x05\
    \x12\x04\xb3\x02\x0b\x11\n\r\n\x05\x044\x02\0\x01\x12\x04\xb3\x02\x12\
    \x15\n\r\n\x05\x044\x02\0\x03\x12\x04\xb3\x02\x18\x19\n\x0c\n\x04\x044\
    \x02\x01\x12\x04\xb4\x02\x02!\n\r\n\x05\x044\x02\x01\x04\x12\x04\xb4\x02\
    \x02\n\n\r\n\x05\x044\x02\x01\x05\x12\x04\xb4\x02\x0b\x11\n\r\n\x05\x044\
    \x02\x01\x01\x12\x04\xb4\x02\x12\x1c\n\r\n\x05\x044\x02\x01\x03\x12\x04\
    \xb4\x02\x1f\x20\n\x0c\n\x02\x045\x12\x06\xb6\x02\0\xb8\x02\x01\n\x0b\n\
    \x03\x045\x01\x12\x04\xb6\x02\x08!\n\x0c\n\x04\x045\x02\0\x12\x04\xb7\
    \x02\x02\x1b\n\r\n\x05\x045\x02\0\x04\x12\x04\xb7\x02\x02\n\n\r\n\x05\
    \x045\x02\0\x05\x12\x04\xb7\x02\x0b\x0f\n\r\n\x05\x045\x02\0\x01\x12\x04\
    \xb7\x02\x10\x16\n\r\n\x05\x045\x02\0\x03\x12\x04\xb7\x02\x19\x1a\n\"\n\
    \x02\x046\x12\x06\xba\x02\0\xbb\x02\x01\"\x14\x20no\x20input\x20paramter\
    s\n\n\x0b\n\x03\x046\x01\x12\x04\xba\x02\x08\x1f\n\x0c\n\x02\x047\x12\
    \x06\xbd\x02\0\xc7\x02\x01\n\x0b\n\x03\x047\x01\x12\x04\xbd\x02\x08\x1f\
    \n\x0c\n\x04\x047\x02\0\x12\x04\xbe\x02\x02\x1f\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\xbe\x02\x02\n\n\r\n\x05\x047\x02\0\x05\x12\x04\xbe\x02\x0b\x11\
    \n\r\n\x05\x047\x02\0\x01\x12\x04\xbe\x02\x12\x1a\n\r\n\x05\x047\x02\0\
    \x03\x12\x04\xbe\x02\x1d\x1e\n\x0c\n\x04\x047\x02\x01\x12\x04\xbf\x02\
    \x02\x1b\n\r\n\x05\x047\x02\x01\x04\x12\x04\xbf\x02\x02\n\n\r\n\x05\x047\
    \x02\x01\x05\x12\x04\xbf\x02\x0b\x11\n\r\n\x05\x047\x02\x01\x01\x12\x04\
    \xbf\x02\x12\x16\n\r\n\x05\x047\x02\x01\x03\x12\x04\xbf\x02\x19\x1a\n\
    \x0c\n\x04\x047\x02\x02\x12\x04\xc0\x02\x02\x20\n\r\n\x05\x047\x02\x02\
    \x04\x12\x04\xc0\x02\x02\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xc0\x02\
    \x0b\x11\n\r\n\x05\x047\x02\x02\x01\x12\x04\xc0\x02\x12\x1b\n\r\n\x05\
    \x047\x02\x02\x03\x12\x04\xc0\x02\x1e\x1f\n\x0c\n\x04\x047\x02\x03\x12\
    \x04\xc1\x02\x02'\n\r\n\x05\x047\x02\x03\x04\x12\x04\xc1\x02\x02\n\n\r\n\
    \x05\x047\x02\x03\x05\x12\x04\xc1\x02\x0b\x11\n\r\n\x05\x047\x02\x03\x01\
    \x12\x04\xc1\x02\x12\"\n\r\n\x05\x047\x02\x03\x03\x12\x04\xc1\x02%&\n\
    \x0c\n\x04\x047\x02\x04\x12\x04\xc2\x02\x02%\n\r\n\x05\x047\x02\x04\x04\
    \x12\x04\xc2\x02\x02\n\n\r\n\x05\x047\x02\x04\x05\x12\x04\xc2\x02\x0b\
    \x11\n\r\n\x05\x047\x02\x04\x01\x12\x04\xc2\x02\x12\x20\n\r\n\x05\x047\
    \x02\x04\x03\x12\x04\xc2\x02#$\n\x0c\n\x04\x047\x02\x05\x12\x04\xc3\x02\
    \x02%\n\r\n\x05\x047\x02\x05\x04\x12\x04\xc3\x02\x02\n\n\r\n\x05\x047\
    \x02\x05\x05\x12\x04\xc3\x02\x0b\x11\n\r\n\x05\x047\x02\x05\x01\x12\x04\
    \xc3\x02\x12\x20\n\r\n\x05\x047\x02\x05\x03\x12\x04\xc3\x02#$\n\x0c\n\
    \x04\x047\x02\x06\x12\x04\xc4\x02\x02.\n\r\n\x05\x047\x02\x06\x04\x12\
    \x04\xc4\x02\x02\n\n\r\n\x05\x047\x02\x06\x05\x12\x04\xc4\x02\x0b\x11\n\
    \r\n\x05\x047\x02\x06\x01\x12\x04\xc4\x02\x12)\n\r\n\x05\x047\x02\x06\
    \x03\x12\x04\xc4\x02,-\n\x0c\n\x04\x047\x02\x07\x12\x04\xc5\x02\x02'\n\r\
    \n\x05\x047\x02\x07\x04\x12\x04\xc5\x02\x02\n\n\r\n\x05\x047\x02\x07\x05\
    \x12\x04\xc5\x02\x0b\x11\n\r\n\x05\x047\x02\x07\x01\x12\x04\xc5\x02\x12\
    \"\n\r\n\x05\x047\x02\x07\x03\x12\x04\xc5\x02%&\n\x0c\n\x04\x047\x02\x08\
    \x12\x04\xc6\x02\x02.\n\r\n\x05\x047\x02\x08\x04\x12\x04\xc6\x02\x02\n\n\
    \r\n\x05\x047\x02\x08\x05\x12\x04\xc6\x02\x0b\x11\n\r\n\x05\x047\x02\x08\
    \x01\x12\x04\xc6\x02\x12)\n\r\n\x05\x047\x02\x08\x03\x12\x04\xc6\x02,-\n\
    \"\n\x02\x048\x12\x06\xc9\x02\0\xca\x02\x01\"\x14\x20no\x20input\x20para\
    mters\n\n\x0b\n\x03\x048\x01\x12\x04\xc9\x02\x08-\n\x0c\n\x02\x049\x12\
    \x06\xcc\x02\0\xd3\x02\x01\n\x0b\n\x03\x049\x01\x12\x04\xcc\x02\x08.\n\
    \x0c\n\x04\x049\x02\0\x12\x04\xcd\x02\x02%\n\r\n\x05\x049\x02\0\x04\x12\
    \x04\xcd\x02\x02\n\n\r\n\x05\x049\x02\0\x05\x12\x04\xcd\x02\x0b\x11\n\r\
    \n\x05\x049\x02\0\x01\x12\x04\xcd\x02\x12\x20\n\r\n\x05\x049\x02\0\x03\
    \x12\x04\xcd\x02#$\n\x0c\n\x04\x049\x02\x01\x12\x04\xce\x02\x02%\n\r\n\
    \x05\x049\x02\x01\x04\x12\x04\xce\x02\x02\n\n\r\n\x05\x049\x02\x01\x05\
    \x12\x04\xce\x02\x0b\x11\n\r\n\x05\x049\x02\x01\x01\x12\x04\xce\x02\x12\
    \x20\n\r\n\x05\x049\x02\x01\x03\x12\x04\xce\x02#$\n\x0c\n\x04\x049\x02\
    \x02\x12\x04\xcf\x02\x02%\n\r\n\x05\x049\x02\x02\x04\x12\x04\xcf\x02\x02\
    \n\n\r\n\x05\x049\x02\x02\x05\x12\x04\xcf\x02\x0b\x11\n\r\n\x05\x049\x02\
    \x02\x01\x12\x04\xcf\x02\x12\x20\n\r\n\x05\x049\x02\x02\x03\x12\x04\xcf\
    \x02#$\n\x0c\n\x04\x049\x02\x03\x12\x04\xd0\x02\x02.\n\r\n\x05\x049\x02\
    \x03\x04\x12\x04\xd0\x02\x02\n\n\r\n\x05\x049\x02\x03\x05\x12\x04\xd0\
    \x02\x0b\x11\n\r\n\x05\x049\x02\x03\x01\x12\x04\xd0\x02\x12)\n\r\n\x05\
    \x049\x02\x03\x03\x12\x04\xd0\x02,-\n\x0c\n\x04\x049\x02\x04\x12\x04\xd1\
    \x02\x02'\n\r\n\x05\x049\x02\x04\x04\x12\x04\xd1\x02\x02\n\n\r\n\x05\x04\
    9\x02\x04\x05\x12\x04\xd1\x02\x0b\x11\n\r\n\x05\x049\x02\x04\x01\x12\x04\
    \xd1\x02\x12\"\n\r\n\x05\x049\x02\x04\x03\x12\x04\xd1\x02%&\n\x0c\n\x04\
    \x049\x02\x05\x12\x04\xd2\x02\x02.\n\r\n\x05\x049\x02\x05\x04\x12\x04\
    \xd2\x02\x02\n\n\r\n\x05\x049\x02\x05\x05\x12\x04\xd2\x02\x0b\x11\n\r\n\
    \x05\x049\x02\x05\x01\x12\x04\xd2\x02\x12)\n\r\n\x05\x049\x02\x05\x03\
    \x12\x04\xd2\x02,-\n\"\n\x02\x04:\x12\x06\xd5\x02\0\xd6\x02\x01\"\x14\
    \x20no\x20input\x20paramters\n\n\x0b\n\x03\x04:\x01\x12\x04\xd5\x02\x08*\
    \n\x0c\n\x02\x04;\x12\x06\xd8\x02\0\xde\x02\x01\n\x0b\n\x03\x04;\x01\x12\
    \x04\xd8\x02\x08+\n\x0c\n\x04\x04;\x02\0\x12\x04\xd9\x02\x02%\n\r\n\x05\
    \x04;\x02\0\x04\x12\x04\xd9\x02\x02\n\n\r\n\x05\x04;\x02\0\x05\x12\x04\
    \xd9\x02\x0b\x11\n\r\n\x05\x04;\x02\0\x01\x12\x04\xd9\x02\x12\x20\n\r\n\
    \x05\x04;\x02\0\x03\x12\x04\xd9\x02#$\n\x0c\n\x04\x04;\x02\x01\x12\x04\
    \xda\x02\x02%\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xda\x02\x02\n\n\r\n\x05\
    \x04;\x02\x01\x05\x12\x04\xda\x02\x0b\x11\n\r\n\x05\x04;\x02\x01\x01\x12\
    \x04\xda\x02\x12\x20\n\r\n\x05\x04;\x02\x01\x03\x12\x04\xda\x02#$\n\x0c\
    \n\x04\x04;\x02\x02\x12\x04\xdb\x02\x02%\n\r\n\x05\x04;\x02\x02\x04\x12\
    \x04\xdb\x02\x02\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xdb\x02\x0b\x11\n\
    \r\n\x05\x04;\x02\x02\x01\x12\x04\xdb\x02\x12\x20\n\r\n\x05\x04;\x02\x02\
    \x03\x12\x04\xdb\x02#$\n\x0c\n\x04\x04;\x02\x03\x12\x04\xdc\x02\x02'\n\r\
    \n\x05\x04;\x02\x03\x04\x12\x04\xdc\x02\x02\n\n\r\n\x05\x04;\x02\x03\x05\
    \x12\x04\xdc\x02\x0b\x11\n\r\n\x05\x04;\x02\x03\x01\x12\x04\xdc\x02\x12\
    \"\n\r\n\x05\x04;\x02\x03\x03\x12\x04\xdc\x02%&\n\x0c\n\x04\x04;\x02\x04\
    \x12\x04\xdd\x02\x02.\n\r\n\x05\x04;\x02\x04\x04\x12\x04\xdd\x02\x02\n\n\
    \r\n\x05\x04;\x02\x04\x05\x12\x04\xdd\x02\x0b\x11\n\r\n\x05\x04;\x02\x04\
    \x01\x12\x04\xdd\x02\x12)\n\r\n\x05\x04;\x02\x04\x03\x12\x04\xdd\x02,-\n\
    +\n\x02\x05\x02\x12\x06\xe0\x02\0\xe7\x02\x01\"\x1d\x20type\x20of\x20the\
    \x20datanode\x20report\n\n\x0b\n\x03\x05\x02\x01\x12\x04\xe0\x02\x05\x1c\
    \n\x0c\n\x04\x05\x02\x02\0\x12\x04\xe1\x02\x02\n\n\r\n\x05\x05\x02\x02\0\
    \x01\x12\x04\xe1\x02\x02\x05\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\xe1\x02\
    \x08\t\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xe2\x02\x02\x0b\n\r\n\x05\x05\
    \x02\x02\x01\x01\x12\x04\xe2\x02\x02\x06\n\r\n\x05\x05\x02\x02\x01\x02\
    \x12\x04\xe2\x02\t\n\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\xe3\x02\x02\x0b\
    \n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xe3\x02\x02\x06\n\r\n\x05\x05\x02\
    \x02\x02\x02\x12\x04\xe3\x02\t\n\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\xe4\
    \x02\x02\x16\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\xe4\x02\x02\x11\n\r\n\
    \x05\x05\x02\x02\x03\x02\x12\x04\xe4\x02\x14\x15\n\x0c\n\x04\x05\x02\x02\
    \x04\x12\x04\xe5\x02\x02\x1b\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\xe5\
    \x02\x02\x16\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xe5\x02\x19\x1a\n\x0c\
    \n\x04\x05\x02\x02\x05\x12\x04\xe6\x02\x02\x15\n\r\n\x05\x05\x02\x02\x05\
    \x01\x12\x04\xe6\x02\x02\x10\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\xe6\
    \x02\x13\x14\n\x0c\n\x02\x04<\x12\x06\xe9\x02\0\xeb\x02\x01\n\x0b\n\x03\
    \x04<\x01\x12\x04\xe9\x02\x08%\n\x0c\n\x04\x04<\x02\0\x12\x04\xea\x02\
    \x02,\n\r\n\x05\x04<\x02\0\x04\x12\x04\xea\x02\x02\n\n\r\n\x05\x04<\x02\
    \0\x06\x12\x04\xea\x02\x0b\"\n\r\n\x05\x04<\x02\0\x01\x12\x04\xea\x02#'\
    \n\r\n\x05\x04<\x02\0\x03\x12\x04\xea\x02*+\n\x0c\n\x02\x04=\x12\x06\xed\
    \x02\0\xef\x02\x01\n\x0b\n\x03\x04=\x01\x12\x04\xed\x02\x08&\n\x0c\n\x04\
    \x04=\x02\0\x12\x04\xee\x02\x02$\n\r\n\x05\x04=\x02\0\x04\x12\x04\xee\
    \x02\x02\n\n\r\n\x05\x04=\x02\0\x06\x12\x04\xee\x02\x0b\x1c\n\r\n\x05\
    \x04=\x02\0\x01\x12\x04\xee\x02\x1d\x1f\n\r\n\x05\x04=\x02\0\x03\x12\x04\
    \xee\x02\"#\n\x0c\n\x02\x04>\x12\x06\xf1\x02\0\xf3\x02\x01\n\x0b\n\x03\
    \x04>\x01\x12\x04\xf1\x02\x08,\n\x0c\n\x04\x04>\x02\0\x12\x04\xf2\x02\
    \x02,\n\r\n\x05\x04>\x02\0\x04\x12\x04\xf2\x02\x02\n\n\r\n\x05\x04>\x02\
    \0\x06\x12\x04\xf2\x02\x0b\"\n\r\n\x05\x04>\x02\0\x01\x12\x04\xf2\x02#'\
    \n\r\n\x05\x04>\x02\0\x03\x12\x04\xf2\x02*+\n\x0c\n\x02\x04?\x12\x06\xf5\
    \x02\0\xf8\x02\x01\n\x0b\n\x03\x04?\x01\x12\x04\xf5\x02\x08\"\n\x0c\n\
    \x04\x04?\x02\0\x12\x04\xf6\x02\x02.\n\r\n\x05\x04?\x02\0\x04\x12\x04\
    \xf6\x02\x02\n\n\r\n\x05\x04?\x02\0\x06\x12\x04\xf6\x02\x0b\x1c\n\r\n\
    \x05\x04?\x02\0\x01\x12\x04\xf6\x02\x1d)\n\r\n\x05\x04?\x02\0\x03\x12\
    \x04\xf6\x02,-\n\x0c\n\x04\x04?\x02\x01\x12\x04\xf7\x02\x021\n\r\n\x05\
    \x04?\x02\x01\x04\x12\x04\xf7\x02\x02\n\n\r\n\x05\x04?\x02\x01\x06\x12\
    \x04\xf7\x02\x0b\x1d\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xf7\x02\x1e,\n\r\
    \n\x05\x04?\x02\x01\x03\x12\x04\xf7\x02/0\n\x0c\n\x02\x04@\x12\x06\xfa\
    \x02\0\xfc\x02\x01\n\x0b\n\x03\x04@\x01\x12\x04\xfa\x02\x08-\n\x0c\n\x04\
    \x04@\x02\0\x12\x04\xfb\x02\x02A\n\r\n\x05\x04@\x02\0\x04\x12\x04\xfb\
    \x02\x02\n\n\r\n\x05\x04@\x02\0\x06\x12\x04\xfb\x02\x0b%\n\r\n\x05\x04@\
    \x02\0\x01\x12\x04\xfb\x02&<\n\r\n\x05\x04@\x02\0\x03\x12\x04\xfb\x02?@\
    \n\x0c\n\x02\x04A\x12\x06\xfe\x02\0\x80\x03\x01\n\x0b\n\x03\x04A\x01\x12\
    \x04\xfe\x02\x08)\n\x0c\n\x04\x04A\x02\0\x12\x04\xff\x02\x02\x1f\n\r\n\
    \x05\x04A\x02\0\x04\x12\x04\xff\x02\x02\n\n\r\n\x05\x04A\x02\0\x05\x12\
    \x04\xff\x02\x0b\x11\n\r\n\x05\x04A\x02\0\x01\x12\x04\xff\x02\x12\x1a\n\
    \r\n\x05\x04A\x02\0\x03\x12\x04\xff\x02\x1d\x1e\n\x0c\n\x02\x04B\x12\x06\
    \x82\x03\0\x84\x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\x82\x03\x08*\n\x0c\n\
    \x04\x04B\x02\0\x12\x04\x83\x03\x02\x1c\n\r\n\x05\x04B\x02\0\x04\x12\x04\
    \x83\x03\x02\n\n\r\n\x05\x04B\x02\0\x05\x12\x04\x83\x03\x0b\x11\n\r\n\
    \x05\x04B\x02\0\x01\x12\x04\x83\x03\x12\x17\n\r\n\x05\x04B\x02\0\x03\x12\
    \x04\x83\x03\x1a\x1b\n\x0c\n\x02\x05\x03\x12\x06\x86\x03\0\x8b\x03\x01\n\
    \x0b\n\x03\x05\x03\x01\x12\x04\x86\x03\x05\x18\n\x0c\n\x04\x05\x03\x02\0\
    \x12\x04\x87\x03\x02\x15\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x87\x03\x02\
    \x10\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x87\x03\x13\x14\n\x0c\n\x04\x05\
    \x03\x02\x01\x12\x04\x88\x03\x02\x15\n\r\n\x05\x05\x03\x02\x01\x01\x12\
    \x04\x88\x03\x02\x10\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\x88\x03\x13\
    \x14\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\x89\x03\x02\x13\n\r\n\x05\x05\
    \x03\x02\x02\x01\x12\x04\x89\x03\x02\x0e\n\r\n\x05\x05\x03\x02\x02\x02\
    \x12\x04\x89\x03\x11\x12\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\x8a\x03\x02\
    \x1a\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\x8a\x03\x02\x15\n\r\n\x05\x05\
    \x03\x02\x03\x02\x12\x04\x8a\x03\x18\x19\n\x0c\n\x02\x04C\x12\x06\x8d\
    \x03\0\x90\x03\x01\n\x0b\n\x03\x04C\x01\x12\x04\x8d\x03\x08\x1f\n\x0c\n\
    \x04\x04C\x02\0\x12\x04\x8e\x03\x02*\n\r\n\x05\x04C\x02\0\x04\x12\x04\
    \x8e\x03\x02\n\n\r\n\x05\x04C\x02\0\x06\x12\x04\x8e\x03\x0b\x1e\n\r\n\
    \x05\x04C\x02\0\x01\x12\x04\x8e\x03\x1f%\n\r\n\x05\x04C\x02\0\x03\x12\
    \x04\x8e\x03()\n\x0c\n\x04\x04C\x02\x01\x12\x04\x8f\x03\x02.\n\r\n\x05\
    \x04C\x02\x01\x04\x12\x04\x8f\x03\x02\n\n\r\n\x05\x04C\x02\x01\x05\x12\
    \x04\x8f\x03\x0b\x0f\n\r\n\x05\x04C\x02\x01\x01\x12\x04\x8f\x03\x10\x17\
    \n\r\n\x05\x04C\x02\x01\x03\x12\x04\x8f\x03\x1a\x1b\n\r\n\x05\x04C\x02\
    \x01\x08\x12\x04\x8f\x03\x1c-\n\r\n\x05\x04C\x02\x01\x07\x12\x04\x8f\x03\
    ',\n\x0c\n\x02\x04D\x12\x06\x92\x03\0\x94\x03\x01\n\x0b\n\x03\x04D\x01\
    \x12\x04\x92\x03\x08\x20\n\x0c\n\x04\x04D\x02\0\x12\x04\x93\x03\x02\x1b\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\x93\x03\x02\n\n\r\n\x05\x04D\x02\0\x05\
    \x12\x04\x93\x03\x0b\x0f\n\r\n\x05\x04D\x02\0\x01\x12\x04\x93\x03\x10\
    \x16\n\r\n\x05\x04D\x02\0\x03\x12\x04\x93\x03\x19\x1a\n\x0c\n\x02\x04E\
    \x12\x06\x96\x03\0\x99\x03\x01\n\x0b\n\x03\x04E\x01\x12\x04\x96\x03\x08!\
    \n\x0c\n\x04\x04E\x02\0\x12\x04\x97\x03\x02/\n\r\n\x05\x04E\x02\0\x04\
    \x12\x04\x97\x03\x02\n\n\r\n\x05\x04E\x02\0\x05\x12\x04\x97\x03\x0b\x11\
    \n\r\n\x05\x04E\x02\0\x01\x12\x04\x97\x03\x12\x1c\n\r\n\x05\x04E\x02\0\
    \x03\x12\x04\x97\x03\x1f\x20\n\r\n\x05\x04E\x02\0\x08\x12\x04\x97\x03!.\
    \n\r\n\x05\x04E\x02\0\x07\x12\x04\x97\x03,-\n\x0c\n\x04\x04E\x02\x01\x12\
    \x04\x98\x03\x02*\n\r\n\x05\x04E\x02\x01\x04\x12\x04\x98\x03\x02\n\n\r\n\
    \x05\x04E\x02\x01\x05\x12\x04\x98\x03\x0b\x11\n\r\n\x05\x04E\x02\x01\x01\
    \x12\x04\x98\x03\x12\x17\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x98\x03\x1a\
    \x1b\n\r\n\x05\x04E\x02\x01\x08\x12\x04\x98\x03\x1c)\n\r\n\x05\x04E\x02\
    \x01\x07\x12\x04\x98\x03'(\n\x1d\n\x02\x04F\x12\x06\x9b\x03\0\x9d\x03\
    \x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04F\x01\x12\x04\x9b\x03\
    \x08\"\n\x0c\n\x04\x04F\x02\0\x12\x04\x9c\x03\x02+\n\r\n\x05\x04F\x02\0\
    \x04\x12\x04\x9c\x03\x02\n\n\r\n\x05\x04F\x02\0\x05\x12\x04\x9c\x03\x0b\
    \x0f\n\r\n\x05\x04F\x02\0\x01\x12\x04\x9c\x03\x10\x15\n\r\n\x05\x04F\x02\
    \0\x03\x12\x04\x9c\x03\x18\x19\n\r\n\x05\x04F\x02\0\x08\x12\x04\x9c\x03\
    \x1a*\n\r\n\x05\x04F\x02\0\x07\x12\x04\x9c\x03%)\n\x1d\n\x02\x04G\x12\
    \x06\x9f\x03\0\xa0\x03\x01\"\x0f\x20no\x20parameters\n\n\x0b\n\x03\x04G\
    \x01\x12\x04\x9f\x03\x08\x1d\n\x18\n\x02\x04H\x12\x06\xa2\x03\0\xa4\x03\
    \x01\"\n\x20response\n\n\x0b\n\x03\x04H\x01\x12\x04\xa2\x03\x08\x1e\n\
    \x0c\n\x04\x04H\x02\0\x12\x04\xa3\x03\x02%\n\r\n\x05\x04H\x02\0\x04\x12\
    \x04\xa3\x03\x02\n\n\r\n\x05\x04H\x02\0\x05\x12\x04\xa3\x03\x0b\x11\n\r\
    \n\x05\x04H\x02\0\x01\x12\x04\xa3\x03\x12\x20\n\r\n\x05\x04H\x02\0\x03\
    \x12\x04\xa3\x03#$\n\x0c\n\x02\x04I\x12\x06\xa6\x03\0\xa8\x03\x01\n\x0b\
    \n\x03\x04I\x01\x12\x04\xa6\x03\x08(\n\x0c\n\x04\x04I\x02\0\x12\x04\xa7\
    \x03\x02\x1a\n\r\n\x05\x04I\x02\0\x04\x12\x04\xa7\x03\x02\n\n\r\n\x05\
    \x04I\x02\0\x05\x12\x04\xa7\x03\x0b\x11\n\r\n\x05\x04I\x02\0\x01\x12\x04\
    \xa7\x03\x12\x15\n\r\n\x05\x04I\x02\0\x03\x12\x04\xa7\x03\x18\x19\n\x0c\
    \n\x02\x04J\x12\x06\xaa\x03\0\xac\x03\x01\n\x0b\n\x03\x04J\x01\x12\x04\
    \xaa\x03\x08)\n\x0c\n\x04\x04J\x02\0\x12\x04\xab\x03\x04\x1d\n\r\n\x05\
    \x04J\x02\0\x04\x12\x04\xab\x03\x04\x0c\n\r\n\x05\x04J\x02\0\x05\x12\x04\
    \xab\x03\r\x11\n\r\n\x05\x04J\x02\0\x01\x12\x04\xab\x03\x12\x18\n\r\n\
    \x05\x04J\x02\0\x03\x12\x04\xab\x03\x1b\x1c\n\x1d\n\x02\x04K\x12\x06\xae\
    \x03\0\xaf\x03\x01\"\x0f\x20no\x20parameters\n\n\x0b\n\x03\x04K\x01\x12\
    \x04\xae\x03\x08\x20\n\x1d\n\x02\x04L\x12\x06\xb1\x03\0\xb2\x03\x01\"\
    \x0f\x20void\x20response\n\n\x0b\n\x03\x04L\x01\x12\x04\xb1\x03\x08!\n\
    \x1d\n\x02\x04M\x12\x06\xb4\x03\0\xb5\x03\x01\"\x0f\x20no\x20parameters\
    \n\n\x0b\n\x03\x04M\x01\x12\x04\xb4\x03\x08#\n\x1d\n\x02\x04N\x12\x06\
    \xb7\x03\0\xb8\x03\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04N\x01\
    \x12\x04\xb7\x03\x08$\n\x0c\n\x02\x05\x04\x12\x06\xba\x03\0\xbe\x03\x01\
    \n\x0b\n\x03\x05\x04\x01\x12\x04\xba\x03\x05\x1e\n\x0c\n\x04\x05\x04\x02\
    \0\x12\x04\xbb\x03\x02\x0c\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xbb\x03\
    \x02\x07\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xbb\x03\n\x0b\n\x0c\n\x04\
    \x05\x04\x02\x01\x12\x04\xbc\x03\x02\x0c\n\r\n\x05\x05\x04\x02\x01\x01\
    \x12\x04\xbc\x03\x02\x07\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xbc\x03\n\
    \x0b\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xbd\x03\x02\x0f\n\r\n\x05\x05\
    \x04\x02\x02\x01\x12\x04\xbd\x03\x02\n\n\r\n\x05\x05\x04\x02\x02\x02\x12\
    \x04\xbd\x03\r\x0e\n\x0c\n\x02\x04O\x12\x06\xc0\x03\0\xc2\x03\x01\n\x0b\
    \n\x03\x04O\x01\x12\x04\xc0\x03\x08\"\n\x0c\n\x04\x04O\x02\0\x12\x04\xc1\
    \x03\x020\n\r\n\x05\x04O\x02\0\x04\x12\x04\xc1\x03\x02\n\n\r\n\x05\x04O\
    \x02\0\x06\x12\x04\xc1\x03\x0b$\n\r\n\x05\x04O\x02\0\x01\x12\x04\xc1\x03\
    %+\n\r\n\x05\x04O\x02\0\x03\x12\x04\xc1\x03./\n\x0c\n\x02\x04P\x12\x06\
    \xc4\x03\0\xc9\x03\x01\n\x0b\n\x03\x04P\x01\x12\x04\xc4\x03\x08\x1f\n\
    \x0c\n\x04\x04P\x02\0\x12\x04\xc5\x03\x020\n\r\n\x05\x04P\x02\0\x04\x12\
    \x04\xc5\x03\x02\n\n\r\n\x05\x04P\x02\0\x06\x12\x04\xc5\x03\x0b$\n\r\n\
    \x05\x04P\x02\0\x01\x12\x04\xc5\x03%+\n\r\n\x05\x04P\x02\0\x03\x12\x04\
    \xc5\x03./\n\x0c\n\x04\x04P\x02\x01\x12\x04\xc6\x03\x02\x20\n\r\n\x05\
    \x04P\x02\x01\x04\x12\x04\xc6\x03\x02\n\n\r\n\x05\x04P\x02\x01\x05\x12\
    \x04\xc6\x03\x0b\x11\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xc6\x03\x12\x1b\
    \n\r\n\x05\x04P\x02\x01\x03\x12\x04\xc6\x03\x1e\x1f\n\x0c\n\x04\x04P\x02\
    \x02\x12\x04\xc7\x03\x02#\n\r\n\x05\x04P\x02\x02\x04\x12\x04\xc7\x03\x02\
    \n\n\r\n\x05\x04P\x02\x02\x05\x12\x04\xc7\x03\x0b\x11\n\r\n\x05\x04P\x02\
    \x02\x01\x12\x04\xc7\x03\x12\x1e\n\r\n\x05\x04P\x02\x02\x03\x12\x04\xc7\
    \x03!\"\n\x0c\n\x04\x04P\x02\x03\x12\x04\xc8\x03\x02*\n\r\n\x05\x04P\x02\
    \x03\x04\x12\x04\xc8\x03\x02\n\n\r\n\x05\x04P\x02\x03\x05\x12\x04\xc8\
    \x03\x0b\x0f\n\r\n\x05\x04P\x02\x03\x01\x12\x04\xc8\x03\x10%\n\r\n\x05\
    \x04P\x02\x03\x03\x12\x04\xc8\x03()\n\x0c\n\x02\x04Q\x12\x06\xcb\x03\0\
    \xcd\x03\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xcb\x03\x08#\n\x0c\n\x04\x04Q\
    \x02\0\x12\x04\xcc\x03\x029\n\r\n\x05\x04Q\x02\0\x04\x12\x04\xcc\x03\x02\
    \n\n\r\n\x05\x04Q\x02\0\x06\x12\x04\xcc\x03\x0b\"\n\r\n\x05\x04Q\x02\0\
    \x01\x12\x04\xcc\x03#5\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xcc\x0378\n\x0c\
    \n\x02\x04R\x12\x06\xcf\x03\0\xd2\x03\x01\n\x0b\n\x03\x04R\x01\x12\x04\
    \xcf\x03\x08)\n\x0c\n\x04\x04R\x02\0\x12\x04\xd0\x03\x02\x1b\n\r\n\x05\
    \x04R\x02\0\x04\x12\x04\xd0\x03\x02\n\n\r\n\x05\x04R\x02\0\x05\x12\x04\
    \xd0\x03\x0b\x11\n\r\n\x05\x04R\x02\0\x01\x12\x04\xd0\x03\x12\x16\n\r\n\
    \x05\x04R\x02\0\x03\x12\x04\xd0\x03\x19\x1a\n\x0c\n\x04\x04R\x02\x01\x12\
    \x04\xd1\x03\x02\x1d\n\r\n\x05\x04R\x02\x01\x04\x12\x04\xd1\x03\x02\n\n\
    \r\n\x05\x04R\x02\x01\x05\x12\x04\xd1\x03\x0b\x11\n\r\n\x05\x04R\x02\x01\
    \x01\x12\x04\xd1\x03\x12\x18\n\r\n\x05\x04R\x02\x01\x03\x12\x04\xd1\x03\
    \x1b\x1c\n\x0c\n\x02\x04S\x12\x06\xd4\x03\0\xd6\x03\x01\n\x0b\n\x03\x04S\
    \x01\x12\x04\xd4\x03\x08*\n\x0c\n\x04\x04S\x02\0\x12\x04\xd5\x03\x02.\n\
    \r\n\x05\x04S\x02\0\x04\x12\x04\xd5\x03\x02\n\n\r\n\x05\x04S\x02\0\x06\
    \x12\x04\xd5\x03\x0b!\n\r\n\x05\x04S\x02\0\x01\x12\x04\xd5\x03\")\n\r\n\
    \x05\x04S\x02\0\x03\x12\x04\xd5\x03,-\n\x0c\n\x02\x04T\x12\x06\xd8\x03\0\
    \xda\x03\x01\n\x0b\n\x03\x04T\x01\x12\x04\xd8\x03\x08\x1c\n\x0c\n\x04\
    \x04T\x02\0\x12\x04\xd9\x03\x02\x1f\n\r\n\x05\x04T\x02\0\x04\x12\x04\xd9\
    \x03\x02\n\n\r\n\x05\x04T\x02\0\x05\x12\x04\xd9\x03\x0b\x11\n\r\n\x05\
    \x04T\x02\0\x01\x12\x04\xd9\x03\x12\x1a\n\r\n\x05\x04T\x02\0\x03\x12\x04\
    \xd9\x03\x1d\x1e\n\x1d\n\x02\x04U\x12\x06\xdc\x03\0\xdd\x03\x01\"\x0f\
    \x20void\x20response\n\n\x0b\n\x03\x04U\x01\x12\x04\xdc\x03\x08\x1d\n\
    \x0c\n\x02\x04V\x12\x06\xdf\x03\0\xe1\x03\x01\n\x0b\n\x03\x04V\x01\x12\
    \x04\xdf\x03\x08\x1f\n\x0c\n\x04\x04V\x02\0\x12\x04\xe0\x03\x02\x1a\n\r\
    \n\x05\x04V\x02\0\x04\x12\x04\xe0\x03\x02\n\n\r\n\x05\x04V\x02\0\x05\x12\
    \x04\xe0\x03\x0b\x11\n\r\n\x05\x04V\x02\0\x01\x12\x04\xe0\x03\x12\x15\n\
    \r\n\x05\x04V\x02\0\x03\x12\x04\xe0\x03\x18\x19\n\x0c\n\x02\x04W\x12\x06\
    \xe3\x03\0\xe5\x03\x01\n\x0b\n\x03\x04W\x01\x12\x04\xe3\x03\x08\x20\n\
    \x0c\n\x04\x04W\x02\0\x12\x04\xe4\x03\x02&\n\r\n\x05\x04W\x02\0\x04\x12\
    \x04\xe4\x03\x02\n\n\r\n\x05\x04W\x02\0\x06\x12\x04\xe4\x03\x0b\x1e\n\r\
    \n\x05\x04W\x02\0\x01\x12\x04\xe4\x03\x1f!\n\r\n\x05\x04W\x02\0\x03\x12\
    \x04\xe4\x03$%\n\x0c\n\x02\x04X\x12\x06\xe7\x03\0\xe9\x03\x01\n\x0b\n\
    \x03\x04X\x01\x12\x04\xe7\x03\x08\x20\n\x0c\n\x04\x04X\x02\0\x12\x04\xe8\
    \x03\x02\x1a\n\r\n\x05\x04X\x02\0\x04\x12\x04\xe8\x03\x02\n\n\r\n\x05\
    \x04X\x02\0\x05\x12\x04\xe8\x03\x0b\x11\n\r\n\x05\x04X\x02\0\x01\x12\x04\
    \xe8\x03\x12\x15\n\r\n\x05\x04X\x02\0\x03\x12\x04\xe8\x03\x18\x19\n\x0c\
    \n\x02\x04Y\x12\x06\xeb\x03\0\xed\x03\x01\n\x0b\n\x03\x04Y\x01\x12\x04\
    \xeb\x03\x08!\n\x0c\n\x04\x04Y\x02\0\x12\x04\xec\x03\x02\x1b\n\r\n\x05\
    \x04Y\x02\0\x04\x12\x04\xec\x03\x02\n\n\r\n\x05\x04Y\x02\0\x05\x12\x04\
    \xec\x03\x0b\x0f\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xec\x03\x10\x16\n\r\n\
    \x05\x04Y\x02\0\x03\x12\x04\xec\x03\x19\x1a\n\x0c\n\x02\x04Z\x12\x06\xef\
    \x03\0\xf5\x03\x01\n\x0b\n\x03\x04Z\x01\x12\x04\xef\x03\x08\x1f\n\x0c\n\
    \x04\x04Z\x02\0\x12\x04\xf0\x03\x02\x18\n\r\n\x05\x04Z\x02\0\x04\x12\x04\
    \xf0\x03\x02\n\n\r\n\x05\x04Z\x02\0\x05\x12\x04\xf0\x03\x0b\x10\n\r\n\
    \x05\x04Z\x02\0\x01\x12\x04\xf0\x03\x11\x13\n\r\n\x05\x04Z\x02\0\x03\x12\
    \x04\xf0\x03\x16\x17\n\x0c\n\x04\x04Z\x02\x01\x12\x04\xf1\x03\x02\x1b\n\
    \r\n\x05\x04Z\x02\x01\x04\x12\x04\xf1\x03\x02\n\n\r\n\x05\x04Z\x02\x01\
    \x05\x12\x04\xf1\x03\x0b\x11\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\xf1\x03\
    \x12\x16\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xf1\x03\x19\x1a\n\x0c\n\x04\
    \x04Z\x02\x02\x12\x04\xf2\x03\x02\"\n\r\n\x05\x04Z\x02\x02\x04\x12\x04\
    \xf2\x03\x02\n\n\r\n\x05\x04Z\x02\x02\x05\x12\x04\xf2\x03\x0b\x11\n\r\n\
    \x05\x04Z\x02\x02\x01\x12\x04\xf2\x03\x12\x1d\n\r\n\x05\x04Z\x02\x02\x03\
    \x12\x04\xf2\x03\x20!\n\x0c\n\x04\x04Z\x02\x03\x12\x04\xf3\x03\x02\x1b\n\
    \r\n\x05\x04Z\x02\x03\x04\x12\x04\xf3\x03\x02\n\n\r\n\x05\x04Z\x02\x03\
    \x05\x12\x04\xf3\x03\x0b\x11\n\r\n\x05\x04Z\x02\x03\x01\x12\x04\xf3\x03\
    \x12\x16\n\r\n\x05\x04Z\x02\x03\x03\x12\x04\xf3\x03\x19\x1a\n\x0c\n\x04\
    \x04Z\x02\x04\x12\x04\xf4\x03\x02<\n\r\n\x05\x04Z\x02\x04\x04\x12\x04\
    \xf4\x03\x02\n\n\r\n\x05\x04Z\x02\x04\x06\x12\x04\xf4\x03\x0b,\n\r\n\x05\
    \x04Z\x02\x04\x01\x12\x04\xf4\x03-7\n\r\n\x05\x04Z\x02\x04\x03\x12\x04\
    \xf4\x03:;\n\x0c\n\x02\x04[\x12\x06\xf7\x03\0\xfa\x03\x01\n\x0b\n\x03\
    \x04[\x01\x12\x04\xf7\x03\x08)\n\x0c\n\x04\x04[\x02\0\x12\x04\xf8\x03\
    \x02\x1c\n\r\n\x05\x04[\x02\0\x04\x12\x04\xf8\x03\x02\n\n\r\n\x05\x04[\
    \x02\0\x05\x12\x04\xf8\x03\x0b\x10\n\r\n\x05\x04[\x02\0\x01\x12\x04\xf8\
    \x03\x11\x17\n\r\n\x05\x04[\x02\0\x03\x12\x04\xf8\x03\x1a\x1b\n\x0c\n\
    \x04\x04[\x02\x01\x12\x04\xf9\x03\x02\x1f\n\r\n\x05\x04[\x02\x01\x04\x12\
    \x04\xf9\x03\x02\n\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xf9\x03\x0b\x0f\n\
    \r\n\x05\x04[\x02\x01\x01\x12\x04\xf9\x03\x10\x1a\n\r\n\x05\x04[\x02\x01\
    \x03\x12\x04\xf9\x03\x1d\x1e\n\x0c\n\x02\x04\\\x12\x06\xfc\x03\0\x82\x04\
    \x01\n\x0b\n\x03\x04\\\x01\x12\x04\xfc\x03\x08\x20\n\x0c\n\x04\x04\\\x02\
    \0\x12\x04\xfd\x03\x02!\n\r\n\x05\x04\\\x02\0\x04\x12\x04\xfd\x03\x02\n\
    \n\r\n\x05\x04\\\x02\0\x05\x12\x04\xfd\x03\x0b\x10\n\r\n\x05\x04\\\x02\0\
    \x01\x12\x04\xfd\x03\x11\x1c\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xfd\x03\
    \x1f\x20\n\x0c\n\x04\x04\\\x02\x01\x12\x04\xfe\x03\x02!\n\r\n\x05\x04\\\
    \x02\x01\x04\x12\x04\xfe\x03\x02\n\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\
    \xfe\x03\x0b\x10\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\xfe\x03\x11\x1c\n\r\
    \n\x05\x04\\\x02\x01\x03\x12\x04\xfe\x03\x1f\x20\n\x0c\n\x04\x04\\\x02\
    \x02\x12\x04\xff\x03\x02!\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\xff\x03\
    \x02\n\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\xff\x03\x0b\x10\n\r\n\x05\x04\
    \\\x02\x02\x01\x12\x04\xff\x03\x11\x1c\n\r\n\x05\x04\\\x02\x02\x03\x12\
    \x04\xff\x03\x1f\x20\n\x0c\n\x04\x04\\\x02\x03\x12\x04\x80\x04\x02!\n\r\
    \n\x05\x04\\\x02\x03\x04\x12\x04\x80\x04\x02\n\n\r\n\x05\x04\\\x02\x03\
    \x05\x12\x04\x80\x04\x0b\x10\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\x80\x04\
    \x11\x1c\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\x80\x04\x1f\x20\n\x0c\n\x04\
    \x04\\\x02\x04\x12\x04\x81\x04\x02\x1f\n\r\n\x05\x04\\\x02\x04\x04\x12\
    \x04\x81\x04\x02\n\n\r\n\x05\x04\\\x02\x04\x05\x12\x04\x81\x04\x0b\x0f\n\
    \r\n\x05\x04\\\x02\x04\x01\x12\x04\x81\x04\x10\x1a\n\r\n\x05\x04\\\x02\
    \x04\x03\x12\x04\x81\x04\x1d\x1e\n\x0c\n\x02\x05\x05\x12\x06\x84\x04\0\
    \x86\x04\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\x84\x04\x05\x13\n+\n\x04\
    \x05\x05\x02\0\x12\x04\x85\x04\x02\x0f\"\x1d\x20Ignore\x20pool\x20resour\
    ce\x20limits\n\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\x85\x04\x02\x07\n\r\n\
    \x05\x05\x05\x02\0\x02\x12\x04\x85\x04\n\x0e\n\x0c\n\x02\x04]\x12\x06\
    \x88\x04\0\x8b\x04\x01\n\x0b\n\x03\x04]\x01\x12\x04\x88\x04\x08%\n\x0c\n\
    \x04\x04]\x02\0\x12\x04\x89\x04\x02,\n\r\n\x05\x04]\x02\0\x04\x12\x04\
    \x89\x04\x02\n\n\r\n\x05\x04]\x02\0\x06\x12\x04\x89\x04\x0b\"\n\r\n\x05\
    \x04]\x02\0\x01\x12\x04\x89\x04#'\n\r\n\x05\x04]\x02\0\x03\x12\x04\x89\
    \x04*+\n(\n\x04\x04]\x02\x01\x12\x04\x8a\x04\x02!\"\x1a\x20bits\x20set\
    \x20using\x20CacheFlag\n\n\r\n\x05\x04]\x02\x01\x04\x12\x04\x8a\x04\x02\
    \n\n\r\n\x05\x04]\x02\x01\x05\x12\x04\x8a\x04\x0b\x11\n\r\n\x05\x04]\x02\
    \x01\x01\x12\x04\x8a\x04\x12\x1c\n\r\n\x05\x04]\x02\x01\x03\x12\x04\x8a\
    \x04\x1f\x20\n\x0c\n\x02\x04^\x12\x06\x8d\x04\0\x8f\x04\x01\n\x0b\n\x03\
    \x04^\x01\x12\x04\x8d\x04\x08&\n\x0c\n\x04\x04^\x02\0\x12\x04\x8e\x04\
    \x02\x18\n\r\n\x05\x04^\x02\0\x04\x12\x04\x8e\x04\x02\n\n\r\n\x05\x04^\
    \x02\0\x05\x12\x04\x8e\x04\x0b\x10\n\r\n\x05\x04^\x02\0\x01\x12\x04\x8e\
    \x04\x11\x13\n\r\n\x05\x04^\x02\0\x03\x12\x04\x8e\x04\x16\x17\n\x0c\n\
    \x02\x04_\x12\x06\x91\x04\0\x94\x04\x01\n\x0b\n\x03\x04_\x01\x12\x04\x91\
    \x04\x08(\n\x0c\n\x04\x04_\x02\0\x12\x04\x92\x04\x02,\n\r\n\x05\x04_\x02\
    \0\x04\x12\x04\x92\x04\x02\n\n\r\n\x05\x04_\x02\0\x06\x12\x04\x92\x04\
    \x0b\"\n\r\n\x05\x04_\x02\0\x01\x12\x04\x92\x04#'\n\r\n\x05\x04_\x02\0\
    \x03\x12\x04\x92\x04*+\n(\n\x04\x04_\x02\x01\x12\x04\x93\x04\x02!\"\x1a\
    \x20bits\x20set\x20using\x20CacheFlag\n\n\r\n\x05\x04_\x02\x01\x04\x12\
    \x04\x93\x04\x02\n\n\r\n\x05\x04_\x02\x01\x05\x12\x04\x93\x04\x0b\x11\n\
    \r\n\x05\x04_\x02\x01\x01\x12\x04\x93\x04\x12\x1c\n\r\n\x05\x04_\x02\x01\
    \x03\x12\x04\x93\x04\x1f\x20\n\x0c\n\x02\x04`\x12\x06\x96\x04\0\x97\x04\
    \x01\n\x0b\n\x03\x04`\x01\x12\x04\x96\x04\x08)\n\x0c\n\x02\x04a\x12\x06\
    \x99\x04\0\x9b\x04\x01\n\x0b\n\x03\x04a\x01\x12\x04\x99\x04\x08(\n\x0c\n\
    \x04\x04a\x02\0\x12\x04\x9a\x04\x02\x18\n\r\n\x05\x04a\x02\0\x04\x12\x04\
    \x9a\x04\x02\n\n\r\n\x05\x04a\x02\0\x05\x12\x04\x9a\x04\x0b\x10\n\r\n\
    \x05\x04a\x02\0\x01\x12\x04\x9a\x04\x11\x13\n\r\n\x05\x04a\x02\0\x03\x12\
    \x04\x9a\x04\x16\x17\n\x0c\n\x02\x04b\x12\x06\x9d\x04\0\x9e\x04\x01\n\
    \x0b\n\x03\x04b\x01\x12\x04\x9d\x04\x08)\n\x0c\n\x02\x04c\x12\x06\xa0\
    \x04\0\xa3\x04\x01\n\x0b\n\x03\x04c\x01\x12\x04\xa0\x04\x08'\n\x0c\n\x04\
    \x04c\x02\0\x12\x04\xa1\x04\x02\x1c\n\r\n\x05\x04c\x02\0\x04\x12\x04\xa1\
    \x04\x02\n\n\r\n\x05\x04c\x02\0\x05\x12\x04\xa1\x04\x0b\x10\n\r\n\x05\
    \x04c\x02\0\x01\x12\x04\xa1\x04\x11\x17\n\r\n\x05\x04c\x02\0\x03\x12\x04\
    \xa1\x04\x1a\x1b\n\x0c\n\x04\x04c\x02\x01\x12\x04\xa2\x04\x02.\n\r\n\x05\
    \x04c\x02\x01\x04\x12\x04\xa2\x04\x02\n\n\r\n\x05\x04c\x02\x01\x06\x12\
    \x04\xa2\x04\x0b\"\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xa2\x04#)\n\r\n\
    \x05\x04c\x02\x01\x03\x12\x04\xa2\x04,-\n\x0c\n\x02\x04d\x12\x06\xa5\x04\
    \0\xa8\x04\x01\n\x0b\n\x03\x04d\x01\x12\x04\xa5\x04\x08\x20\n\x0c\n\x04\
    \x04d\x02\0\x12\x04\xa6\x04\x02,\n\r\n\x05\x04d\x02\0\x04\x12\x04\xa6\
    \x04\x02\n\n\r\n\x05\x04d\x02\0\x06\x12\x04\xa6\x04\x0b\"\n\r\n\x05\x04d\
    \x02\0\x01\x12\x04\xa6\x04#'\n\r\n\x05\x04d\x02\0\x03\x12\x04\xa6\x04*+\
    \n\x0c\n\x04\x04d\x02\x01\x12\x04\xa7\x04\x02.\n\r\n\x05\x04d\x02\x01\
    \x04\x12\x04\xa7\x04\x02\n\n\r\n\x05\x04d\x02\x01\x06\x12\x04\xa7\x04\
    \x0b#\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xa7\x04$)\n\r\n\x05\x04d\x02\
    \x01\x03\x12\x04\xa7\x04,-\n\x0c\n\x02\x04e\x12\x06\xaa\x04\0\xad\x04\
    \x01\n\x0b\n\x03\x04e\x01\x12\x04\xaa\x04\x08(\n\x0c\n\x04\x04e\x02\0\
    \x12\x04\xab\x04\x021\n\r\n\x05\x04e\x02\0\x04\x12\x04\xab\x04\x02\n\n\r\
    \n\x05\x04e\x02\0\x06\x12\x04\xab\x04\x0b#\n\r\n\x05\x04e\x02\0\x01\x12\
    \x04\xab\x04$,\n\r\n\x05\x04e\x02\0\x03\x12\x04\xab\x04/0\n\x0c\n\x04\
    \x04e\x02\x01\x12\x04\xac\x04\x02\x1c\n\r\n\x05\x04e\x02\x01\x04\x12\x04\
    \xac\x04\x02\n\n\r\n\x05\x04e\x02\x01\x05\x12\x04\xac\x04\x0b\x0f\n\r\n\
    \x05\x04e\x02\x01\x01\x12\x04\xac\x04\x10\x17\n\r\n\x05\x04e\x02\x01\x03\
    \x12\x04\xac\x04\x1a\x1b\n\x0c\n\x02\x04f\x12\x06\xaf\x04\0\xb7\x04\x01\
    \n\x0b\n\x03\x04f\x01\x12\x04\xaf\x04\x08\x1a\n\x0c\n\x04\x04f\x02\0\x12\
    \x04\xb0\x04\x02\x1f\n\r\n\x05\x04f\x02\0\x04\x12\x04\xb0\x04\x02\n\n\r\
    \n\x05\x04f\x02\0\x05\x12\x04\xb0\x04\x0b\x11\n\r\n\x05\x04f\x02\0\x01\
    \x12\x04\xb0\x04\x12\x1a\n\r\n\x05\x04f\x02\0\x03\x12\x04\xb0\x04\x1d\
    \x1e\n\x0c\n\x04\x04f\x02\x01\x12\x04\xb1\x04\x02\x20\n\r\n\x05\x04f\x02\
    \x01\x04\x12\x04\xb1\x04\x02\n\n\r\n\x05\x04f\x02\x01\x05\x12\x04\xb1\
    \x04\x0b\x11\n\r\n\x05\x04f\x02\x01\x01\x12\x04\xb1\x04\x12\x1b\n\r\n\
    \x05\x04f\x02\x01\x03\x12\x04\xb1\x04\x1e\x1f\n\x0c\n\x04\x04f\x02\x02\
    \x12\x04\xb2\x04\x02\x20\n\r\n\x05\x04f\x02\x02\x04\x12\x04\xb2\x04\x02\
    \n\n\r\n\x05\x04f\x02\x02\x05\x12\x04\xb2\x04\x0b\x11\n\r\n\x05\x04f\x02\
    \x02\x01\x12\x04\xb2\x04\x12\x1b\n\r\n\x05\x04f\x02\x02\x03\x12\x04\xb2\
    \x04\x1e\x1f\n\x0c\n\x04\x04f\x02\x03\x12\x04\xb3\x04\x02\x1a\n\r\n\x05\
    \x04f\x02\x03\x04\x12\x04\xb3\x04\x02\n\n\r\n\x05\x04f\x02\x03\x05\x12\
    \x04\xb3\x04\x0b\x10\n\r\n\x05\x04f\x02\x03\x01\x12\x04\xb3\x04\x11\x15\
    \n\r\n\x05\x04f\x02\x03\x03\x12\x04\xb3\x04\x18\x19\n\x0c\n\x04\x04f\x02\
    \x04\x12\x04\xb4\x04\x02\x1b\n\r\n\x05\x04f\x02\x04\x04\x12\x04\xb4\x04\
    \x02\n\n\r\n\x05\x04f\x02\x04\x05\x12\x04\xb4\x04\x0b\x10\n\r\n\x05\x04f\
    \x02\x04\x01\x12\x04\xb4\x04\x11\x16\n\r\n\x05\x04f\x02\x04\x03\x12\x04\
    \xb4\x04\x19\x1a\n\x0c\n\x04\x04f\x02\x05\x12\x04\xb5\x04\x02'\n\r\n\x05\
    \x04f\x02\x05\x04\x12\x04\xb5\x04\x02\n\n\r\n\x05\x04f\x02\x05\x05\x12\
    \x04\xb5\x04\x0b\x10\n\r\n\x05\x04f\x02\x05\x01\x12\x04\xb5\x04\x11\"\n\
    \r\n\x05\x04f\x02\x05\x03\x12\x04\xb5\x04%&\n\x0c\n\x04\x04f\x02\x06\x12\
    \x04\xb6\x04\x025\n\r\n\x05\x04f\x02\x06\x04\x12\x04\xb6\x04\x02\n\n\r\n\
    \x05\x04f\x02\x06\x05\x12\x04\xb6\x04\x0b\x11\n\r\n\x05\x04f\x02\x06\x01\
    \x12\x04\xb6\x04\x12$\n\r\n\x05\x04f\x02\x06\x03\x12\x04\xb6\x04'(\n\r\n\
    \x05\x04f\x02\x06\x08\x12\x04\xb6\x04)4\n\r\n\x05\x04f\x02\x06\x07\x12\
    \x04\xb6\x0423\n\x0c\n\x02\x04g\x12\x06\xb9\x04\0\xbf\x04\x01\n\x0b\n\
    \x03\x04g\x01\x12\x04\xb9\x04\x08\x1b\n\x0c\n\x04\x04g\x02\0\x12\x04\xba\
    \x04\x02!\n\r\n\x05\x04g\x02\0\x04\x12\x04\xba\x04\x02\n\n\r\n\x05\x04g\
    \x02\0\x05\x12\x04\xba\x04\x0b\x10\n\r\n\x05\x04g\x02\0\x01\x12\x04\xba\
    \x04\x11\x1c\n\r\n\x05\x04g\x02\0\x03\x12\x04\xba\x04\x1f\x20\n\x0c\n\
    \x04\x04g\x02\x01\x12\x04\xbb\x04\x02!\n\r\n\x05\x04g\x02\x01\x04\x12\
    \x04\xbb\x04\x02\n\n\r\n\x05\x04g\x02\x01\x05\x12\x04\xbb\x04\x0b\x10\n\
    \r\n\x05\x04g\x02\x01\x01\x12\x04\xbb\x04\x11\x1c\n\r\n\x05\x04g\x02\x01\
    \x03\x12\x04\xbb\x04\x1f\x20\n\x0c\n\x04\x04g\x02\x02\x12\x04\xbc\x04\
    \x02$\n\r\n\x05\x04g\x02\x02\x04\x12\x04\xbc\x04\x02\n\n\r\n\x05\x04g\
    \x02\x02\x05\x12\x04\xbc\x04\x0b\x10\n\r\n\x05\x04g\x02\x02\x01\x12\x04\
    \xbc\x04\x11\x1f\n\r\n\x05\x04g\x02\x02\x03\x12\x04\xbc\x04\"#\n\x0c\n\
    \x04\x04g\x02\x03\x12\x04\xbd\x04\x02!\n\r\n\x05\x04g\x02\x03\x04\x12\
    \x04\xbd\x04\x02\n\n\r\n\x05\x04g\x02\x03\x05\x12\x04\xbd\x04\x0b\x10\n\
    \r\n\x05\x04g\x02\x03\x01\x12\x04\xbd\x04\x11\x1c\n\r\n\x05\x04g\x02\x03\
    \x03\x12\x04\xbd\x04\x1f\x20\n\x0c\n\x04\x04g\x02\x04\x12\x04\xbe\x04\
    \x02!\n\r\n\x05\x04g\x02\x04\x04\x12\x04\xbe\x04\x02\n\n\r\n\x05\x04g\
    \x02\x04\x05\x12\x04\xbe\x04\x0b\x10\n\r\n\x05\x04g\x02\x04\x01\x12\x04\
    \xbe\x04\x11\x1c\n\r\n\x05\x04g\x02\x04\x03\x12\x04\xbe\x04\x1f\x20\n\
    \x0c\n\x02\x04h\x12\x06\xc1\x04\0\xc3\x04\x01\n\x0b\n\x03\x04h\x01\x12\
    \x04\xc1\x04\x08\x20\n\x0c\n\x04\x04h\x02\0\x12\x04\xc2\x04\x02'\n\r\n\
    \x05\x04h\x02\0\x04\x12\x04\xc2\x04\x02\n\n\r\n\x05\x04h\x02\0\x06\x12\
    \x04\xc2\x04\x0b\x1d\n\r\n\x05\x04h\x02\0\x01\x12\x04\xc2\x04\x1e\"\n\r\
    \n\x05\x04h\x02\0\x03\x12\x04\xc2\x04%&\n\x1d\n\x02\x04i\x12\x06\xc5\x04\
    \0\xc6\x04\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04i\x01\x12\x04\
    \xc5\x04\x08!\n\x0c\n\x02\x04j\x12\x06\xc8\x04\0\xca\x04\x01\n\x0b\n\x03\
    \x04j\x01\x12\x04\xc8\x04\x08#\n\x0c\n\x04\x04j\x02\0\x12\x04\xc9\x04\
    \x02'\n\r\n\x05\x04j\x02\0\x04\x12\x04\xc9\x04\x02\n\n\r\n\x05\x04j\x02\
    \0\x06\x12\x04\xc9\x04\x0b\x1d\n\r\n\x05\x04j\x02\0\x01\x12\x04\xc9\x04\
    \x1e\"\n\r\n\x05\x04j\x02\0\x03\x12\x04\xc9\x04%&\n\x1d\n\x02\x04k\x12\
    \x06\xcc\x04\0\xcd\x04\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04k\
    \x01\x12\x04\xcc\x04\x08$\n\x0c\n\x02\x04l\x12\x06\xcf\x04\0\xd1\x04\x01\
    \n\x0b\n\x03\x04l\x01\x12\x04\xcf\x04\x08#\n\x0c\n\x04\x04l\x02\0\x12\
    \x04\xd0\x04\x02\x1f\n\r\n\x05\x04l\x02\0\x04\x12\x04\xd0\x04\x02\n\n\r\
    \n\x05\x04l\x02\0\x05\x12\x04\xd0\x04\x0b\x11\n\r\n\x05\x04l\x02\0\x01\
    \x12\x04\xd0\x04\x12\x1a\n\r\n\x05\x04l\x02\0\x03\x12\x04\xd0\x04\x1d\
    \x1e\n\x1d\n\x02\x04m\x12\x06\xd3\x04\0\xd4\x04\x01\"\x0f\x20void\x20res\
    ponse\n\n\x0b\n\x03\x04m\x01\x12\x04\xd3\x04\x08$\n\x0c\n\x02\x04n\x12\
    \x06\xd6\x04\0\xd8\x04\x01\n\x0b\n\x03\x04n\x01\x12\x04\xd6\x04\x08\"\n\
    \x0c\n\x04\x04n\x02\0\x12\x04\xd7\x04\x02#\n\r\n\x05\x04n\x02\0\x04\x12\
    \x04\xd7\x04\x02\n\n\r\n\x05\x04n\x02\0\x05\x12\x04\xd7\x04\x0b\x11\n\r\
    \n\x05\x04n\x02\0\x01\x12\x04\xd7\x04\x12\x1e\n\r\n\x05\x04n\x02\0\x03\
    \x12\x04\xd7\x04!\"\n\x0c\n\x02\x04o\x12\x06\xda\x04\0\xdd\x04\x01\n\x0b\
    \n\x03\x04o\x01\x12\x04\xda\x04\x08#\n\x0c\n\x04\x04o\x02\0\x12\x04\xdb\
    \x04\x02+\n\r\n\x05\x04o\x02\0\x04\x12\x04\xdb\x04\x02\n\n\r\n\x05\x04o\
    \x02\0\x06\x12\x04\xdb\x04\x0b\x1e\n\r\n\x05\x04o\x02\0\x01\x12\x04\xdb\
    \x04\x1f&\n\r\n\x05\x04o\x02\0\x03\x12\x04\xdb\x04)*\n\x0c\n\x04\x04o\
    \x02\x01\x12\x04\xdc\x04\x02\x1c\n\r\n\x05\x04o\x02\x01\x04\x12\x04\xdc\
    \x04\x02\n\n\r\n\x05\x04o\x02\x01\x05\x12\x04\xdc\x04\x0b\x0f\n\r\n\x05\
    \x04o\x02\x01\x01\x12\x04\xdc\x04\x10\x17\n\r\n\x05\x04o\x02\x01\x03\x12\
    \x04\xdc\x04\x1a\x1b\n\x0c\n\x02\x04p\x12\x06\xdf\x04\0\xe2\x04\x01\n\
    \x0b\n\x03\x04p\x01\x12\x04\xdf\x04\x08\x1b\n\x0c\n\x04\x04p\x02\0\x12\
    \x04\xe0\x04\x02'\n\r\n\x05\x04p\x02\0\x04\x12\x04\xe0\x04\x02\n\n\r\n\
    \x05\x04p\x02\0\x06\x12\x04\xe0\x04\x0b\x1d\n\r\n\x05\x04p\x02\0\x01\x12\
    \x04\xe0\x04\x1e\"\n\r\n\x05\x04p\x02\0\x03\x12\x04\xe0\x04%&\n\x0c\n\
    \x04\x04p\x02\x01\x12\x04\xe1\x04\x02)\n\r\n\x05\x04p\x02\x01\x04\x12\
    \x04\xe1\x04\x02\n\n\r\n\x05\x04p\x02\x01\x06\x12\x04\xe1\x04\x0b\x1e\n\
    \r\n\x05\x04p\x02\x01\x01\x12\x04\xe1\x04\x1f$\n\r\n\x05\x04p\x02\x01\
    \x03\x12\x04\xe1\x04'(\n\x0c\n\x02\x04q\x12\x06\xe4\x04\0\xe6\x04\x01\n\
    \x0b\n\x03\x04q\x01\x12\x04\xe4\x04\x08#\n\x0c\n\x04\x04q\x02\0\x12\x04\
    \xe5\x04\x02\x1a\n\r\n\x05\x04q\x02\0\x04\x12\x04\xe5\x04\x02\n\n\r\n\
    \x05\x04q\x02\0\x05\x12\x04\xe5\x04\x0b\x11\n\r\n\x05\x04q\x02\0\x01\x12\
    \x04\xe5\x04\x12\x15\n\r\n\x05\x04q\x02\0\x03\x12\x04\xe5\x04\x18\x19\n\
    \x0c\n\x02\x04r\x12\x06\xe8\x04\0\xea\x04\x01\n\x0b\n\x03\x04r\x01\x12\
    \x04\xe8\x04\x08$\n\x0c\n\x04\x04r\x02\0\x12\x04\xe9\x04\x02&\n\r\n\x05\
    \x04r\x02\0\x04\x12\x04\xe9\x04\x02\n\n\r\n\x05\x04r\x02\0\x06\x12\x04\
    \xe9\x04\x0b\x1e\n\r\n\x05\x04r\x02\0\x01\x12\x04\xe9\x04\x1f!\n\r\n\x05\
    \x04r\x02\0\x03\x12\x04\xe9\x04$%\n\x0c\n\x02\x04s\x12\x06\xec\x04\0\xee\
    \x04\x01\n\x0b\n\x03\x04s\x01\x12\x04\xec\x04\x08%\n\x0c\n\x04\x04s\x02\
    \0\x12\x04\xed\x04\x02\x1b\n\r\n\x05\x04s\x02\0\x04\x12\x04\xed\x04\x02\
    \n\n\r\n\x05\x04s\x02\0\x05\x12\x04\xed\x04\x0b\x11\n\r\n\x05\x04s\x02\0\
    \x01\x12\x04\xed\x04\x12\x16\n\r\n\x05\x04s\x02\0\x03\x12\x04\xed\x04\
    \x19\x1a\n\x0c\n\x02\x04t\x12\x06\xf0\x04\0\xf2\x04\x01\n\x0b\n\x03\x04t\
    \x01\x12\x04\xf0\x04\x08&\n\x0c\n\x04\x04t\x02\0\x12\x04\xf1\x04\x02+\n\
    \r\n\x05\x04t\x02\0\x04\x12\x04\xf1\x04\x02\n\n\r\n\x05\x04t\x02\0\x06\
    \x12\x04\xf1\x04\x0b\x1e\n\r\n\x05\x04t\x02\0\x01\x12\x04\xf1\x04\x1f&\n\
    \r\n\x05\x04t\x02\0\x03\x12\x04\xf1\x04)*\n\x0c\n\x02\x04u\x12\x06\xf4\
    \x04\0\xf6\x04\x01\n\x0b\n\x03\x04u\x01\x12\x04\xf4\x04\x08!\n\x0c\n\x04\
    \x04u\x02\0\x12\x04\xf5\x04\x02\x1b\n\r\n\x05\x04u\x02\0\x04\x12\x04\xf5\
    \x04\x02\n\n\r\n\x05\x04u\x02\0\x05\x12\x04\xf5\x04\x0b\x11\n\r\n\x05\
    \x04u\x02\0\x01\x12\x04\xf5\x04\x12\x16\n\r\n\x05\x04u\x02\0\x03\x12\x04\
    \xf5\x04\x19\x1a\n\x0c\n\x02\x04v\x12\x06\xf8\x04\0\xfa\x04\x01\n\x0b\n\
    \x03\x04v\x01\x12\x04\xf8\x04\x08\"\n\x0c\n\x04\x04v\x02\0\x12\x04\xf9\
    \x04\x02%\n\r\n\x05\x04v\x02\0\x04\x12\x04\xf9\x04\x02\n\n\r\n\x05\x04v\
    \x02\0\x06\x12\x04\xf9\x04\x0b\x1a\n\r\n\x05\x04v\x02\0\x01\x12\x04\xf9\
    \x04\x1b\x20\n\r\n\x05\x04v\x02\0\x03\x12\x04\xf9\x04#$\n\x0c\n\x02\x04w\
    \x12\x06\xfc\x04\0\x81\x05\x01\n\x0b\n\x03\x04w\x01\x12\x04\xfc\x04\x08\
    \x1c\n\x0c\n\x04\x04w\x02\0\x12\x04\xfd\x04\x02\x1b\n\r\n\x05\x04w\x02\0\
    \x04\x12\x04\xfd\x04\x02\n\n\r\n\x05\x04w\x02\0\x05\x12\x04\xfd\x04\x0b\
    \x11\n\r\n\x05\x04w\x02\0\x01\x12\x04\xfd\x04\x12\x16\n\r\n\x05\x04w\x02\
    \0\x03\x12\x04\xfd\x04\x19\x1a\n\x0c\n\x04\x04w\x02\x01\x12\x04\xfe\x04\
    \x02%\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xfe\x04\x02\n\n\r\n\x05\x04w\
    \x02\x01\x05\x12\x04\xfe\x04\x0b\x11\n\r\n\x05\x04w\x02\x01\x01\x12\x04\
    \xfe\x04\x12\x20\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xfe\x04#$\n\x0c\n\
    \x04\x04w\x02\x02\x12\x04\xff\x04\x02(\n\r\n\x05\x04w\x02\x02\x04\x12\
    \x04\xff\x04\x02\n\n\r\n\x05\x04w\x02\x02\x05\x12\x04\xff\x04\x0b\x11\n\
    \r\n\x05\x04w\x02\x02\x01\x12\x04\xff\x04\x12#\n\r\n\x05\x04w\x02\x02\
    \x03\x12\x04\xff\x04&'\n\x0c\n\x04\x04w\x02\x03\x12\x04\x80\x05\x02,\n\r\
    \n\x05\x04w\x02\x03\x04\x12\x04\x80\x05\x02\n\n\r\n\x05\x04w\x02\x03\x06\
    \x12\x04\x80\x05\x0b\x1b\n\r\n\x05\x04w\x02\x03\x01\x12\x04\x80\x05\x1c'\
    \n\r\n\x05\x04w\x02\x03\x03\x12\x04\x80\x05*+\n\x1d\n\x02\x04x\x12\x06\
    \x83\x05\0\x84\x05\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04x\x01\
    \x12\x04\x83\x05\x08\x1d\n\x0c\n\x02\x04y\x12\x06\x86\x05\0\x8b\x05\x01\
    \n\x0b\n\x03\x04y\x01\x12\x04\x86\x05\x08\x19\n\x0c\n\x04\x04y\x02\0\x12\
    \x04\x87\x05\x02\x1a\n\r\n\x05\x04y\x02\0\x04\x12\x04\x87\x05\x02\n\n\r\
    \n\x05\x04y\x02\0\x05\x12\x04\x87\x05\x0b\x11\n\r\n\x05\x04y\x02\0\x01\
    \x12\x04\x87\x05\x12\x15\n\r\n\x05\x04y\x02\0\x03\x12\x04\x87\x05\x18\
    \x19\n\x0c\n\x04\x04y\x02\x01\x12\x04\x88\x05\x02\x1d\n\r\n\x05\x04y\x02\
    \x01\x04\x12\x04\x88\x05\x02\n\n\r\n\x05\x04y\x02\x01\x05\x12\x04\x88\
    \x05\x0b\x11\n\r\n\x05\x04y\x02\x01\x01\x12\x04\x88\x05\x12\x18\n\r\n\
    \x05\x04y\x02\x01\x03\x12\x04\x88\x05\x1b\x1c\n\x0c\n\x04\x04y\x02\x02\
    \x12\x04\x89\x05\x025\n\r\n\x05\x04y\x02\x02\x04\x12\x04\x89\x05\x02\n\n\
    \r\n\x05\x04y\x02\x02\x05\x12\x04\x89\x05\x0b\x11\n\r\n\x05\x04y\x02\x02\
    \x01\x12\x04\x89\x05\x12!\n\r\n\x05\x04y\x02\x02\x03\x12\x04\x89\x05$%\n\
    \r\n\x05\x04y\x02\x02\x08\x12\x04\x89\x05&4\n\r\n\x05\x04y\x02\x02\x07\
    \x12\x04\x89\x0513\n/\n\x04\x04y\x02\x03\x12\x04\x8a\x05\x02+\"!\x20defa\
    ult\x20to\x20GRANDFATHER_INODE_ID\n\n\r\n\x05\x04y\x02\x03\x04\x12\x04\
    \x8a\x05\x02\n\n\r\n\x05\x04y\x02\x03\x05\x12\x04\x8a\x05\x0b\x11\n\r\n\
    \x05\x04y\x02\x03\x01\x12\x04\x8a\x05\x12\x18\n\r\n\x05\x04y\x02\x03\x03\
    \x12\x04\x8a\x05\x1b\x1c\n\r\n\x05\x04y\x02\x03\x08\x12\x04\x8a\x05\x1d*\
    \n\r\n\x05\x04y\x02\x03\x07\x12\x04\x8a\x05()\n\x1d\n\x02\x04z\x12\x06\
    \x8d\x05\0\x8e\x05\x01\"\x0f\x20void\x20response\n\n\x0b\n\x03\x04z\x01\
    \x12\x04\x8d\x05\x08\x1a\n\x0c\n\x02\x04{\x12\x06\x90\x05\0\x94\x05\x01\
    \n\x0b\n\x03\x04{\x01\x12\x04\x90\x05\x08\x1c\n\x0c\n\x04\x04{\x02\0\x12\
    \x04\x91\x05\x02\x1a\n\r\n\x05\x04{\x02\0\x04\x12\x04\x91\x05\x02\n\n\r\
    \n\x05\x04{\x02\0\x05\x12\x04\x91\x05\x0b\x11\n\r\n\x05\x04{\x02\0\x01\
    \x12\x04\x91\x05\x12\x15\n\r\n\x05\x04{\x02\0\x03\x12\x04\x91\x05\x18\
    \x19\n\x0c\n\x04\x04{\x02\x01\x12\x04\x92\x05\x02\x1c\n\r\n\x05\x04{\x02\
    \x01\x04\x12\x04\x92\x05\x02\n\n\r\n\x05\x04{\x02\x01\x05\x12\x04\x92\
    \x05\x0b\x11\n\r\n\x05\x04{\x02\x01\x01\x12\x04\x92\x05\x12\x17\n\r\n\
    \x05\x04{\x02\x01\x03\x12\x04\x92\x05\x1a\x1b\n\x0c\n\x04\x04{\x02\x02\
    \x12\x04\x93\x05\x02\x1c\n\r\n\x05\x04{\x02\x02\x04\x12\x04\x93\x05\x02\
    \n\n\r\n\x05\x04{\x02\x02\x05\x12\x04\x93\x05\x0b\x11\n\r\n\x05\x04{\x02\
    \x02\x01\x12\x04\x93\x05\x12\x17\n\r\n\x05\x04{\x02\x02\x03\x12\x04\x93\
    \x05\x1a\x1b\n\x1d\n\x02\x04|\x12\x06\x96\x05\0\x97\x05\x01\"\x0f\x20voi\
    d\x20response\n\n\x0b\n\x03\x04|\x01\x12\x04\x96\x05\x08\x1d\n\x0c\n\x02\
    \x04}\x12\x06\x99\x05\0\x9e\x05\x01\n\x0b\n\x03\x04}\x01\x12\x04\x99\x05\
    \x08!\n\x0c\n\x04\x04}\x02\0\x12\x04\x9a\x05\x02\x1d\n\r\n\x05\x04}\x02\
    \0\x04\x12\x04\x9a\x05\x02\n\n\r\n\x05\x04}\x02\0\x05\x12\x04\x9a\x05\
    \x0b\x11\n\r\n\x05\x04}\x02\0\x01\x12\x04\x9a\x05\x12\x18\n\r\n\x05\x04}\
    \x02\0\x03\x12\x04\x9a\x05\x1b\x1c\n\x0c\n\x04\x04}\x02\x01\x12\x04\x9b\
    \x05\x02\x1b\n\r\n\x05\x04}\x02\x01\x04\x12\x04\x9b\x05\x02\n\n\r\n\x05\
    \x04}\x02\x01\x05\x12\x04\x9b\x05\x0b\x11\n\r\n\x05\x04}\x02\x01\x01\x12\
    \x04\x9b\x05\x12\x16\n\r\n\x05\x04}\x02\x01\x03\x12\x04\x9b\x05\x19\x1a\
    \n\x0c\n\x04\x04}\x02\x02\x12\x04\x9c\x05\x02)\n\r\n\x05\x04}\x02\x02\
    \x04\x12\x04\x9c\x05\x02\n\n\r\n\x05\x04}\x02\x02\x06\x12\x04\x9c\x05\
    \x0b\x1c\n\r\n\x05\x04}\x02\x02\x01\x12\x04\x9c\x05\x1d$\n\r\n\x05\x04}\
    \x02\x02\x03\x12\x04\x9c\x05'(\n\x0c\n\x04\x04}\x02\x03\x12\x04\x9d\x05\
    \x02!\n\r\n\x05\x04}\x02\x03\x04\x12\x04\x9d\x05\x02\n\n\r\n\x05\x04}\
    \x02\x03\x05\x12\x04\x9d\x05\x0b\x0f\n\r\n\x05\x04}\x02\x03\x01\x12\x04\
    \x9d\x05\x10\x1c\n\r\n\x05\x04}\x02\x03\x03\x12\x04\x9d\x05\x1f\x20\n\
    \x1d\n\x02\x04~\x12\x06\xa0\x05\0\xa1\x05\x01\"\x0f\x20void\x20response\
    \n\n\x0b\n\x03\x04~\x01\x12\x04\xa0\x05\x08\"\n\x0c\n\x02\x04\x7f\x12\
    \x06\xa3\x05\0\xa5\x05\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xa3\x05\x08!\
    \n\x0c\n\x04\x04\x7f\x02\0\x12\x04\xa4\x05\x02\x1b\n\r\n\x05\x04\x7f\x02\
    \0\x04\x12\x04\xa4\x05\x02\n\n\r\n\x05\x04\x7f\x02\0\x05\x12\x04\xa4\x05\
    \x0b\x11\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xa4\x05\x12\x16\n\r\n\x05\
    \x04\x7f\x02\0\x03\x12\x04\xa4\x05\x19\x1a\n\r\n\x03\x04\x80\x01\x12\x06\
    \xa6\x05\0\xa8\x05\x01\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xa6\x05\x08\"\
    \n\r\n\x05\x04\x80\x01\x02\0\x12\x04\xa7\x05\x02!\n\x0e\n\x06\x04\x80\
    \x01\x02\0\x04\x12\x04\xa7\x05\x02\n\n\x0e\n\x06\x04\x80\x01\x02\0\x05\
    \x12\x04\xa7\x05\x0b\x11\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xa7\
    \x05\x12\x1c\n\x0e\n\x06\x04\x80\x01\x02\0\x03\x12\x04\xa7\x05\x1f\x20\n\
    \r\n\x03\x04\x81\x01\x12\x06\xaa\x05\0\xad\x05\x01\n\x0c\n\x04\x04\x81\
    \x01\x01\x12\x04\xaa\x05\x08*\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xab\
    \x05\x02(\n\x0e\n\x06\x04\x81\x01\x02\0\x04\x12\x04\xab\x05\x02\n\n\x0e\
    \n\x06\x04\x81\x01\x02\0\x06\x12\x04\xab\x05\x0b\x1d\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x01\x12\x04\xab\x05\x1e#\n\x0e\n\x06\x04\x81\x01\x02\0\x03\
    \x12\x04\xab\x05&'\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\xac\x05\x02!\n\
    \x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\xac\x05\x02\n\n\x0e\n\x06\x04\
    \x81\x01\x02\x01\x05\x12\x04\xac\x05\x0b\x11\n\x0e\n\x06\x04\x81\x01\x02\
    \x01\x01\x12\x04\xac\x05\x12\x1c\n\x0e\n\x06\x04\x81\x01\x02\x01\x03\x12\
    \x04\xac\x05\x1f\x20\n\r\n\x03\x04\x82\x01\x12\x06\xaf\x05\0\xb1\x05\x01\
    \n\x0c\n\x04\x04\x82\x01\x01\x12\x04\xaf\x05\x08+\n\r\n\x05\x04\x82\x01\
    \x02\0\x12\x04\xb0\x05\x02'\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\
    \xb0\x05\x02\n\n\x0e\n\x06\x04\x82\x01\x02\0\x06\x12\x04\xb0\x05\x0b\x1c\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\xb0\x05\x1d\"\n\x0e\n\x06\x04\
    \x82\x01\x02\0\x03\x12\x04\xb0\x05%&\n\r\n\x03\x04\x83\x01\x12\x06\xb3\
    \x05\0\xb9\x05\x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\xb3\x05\x08\"\n\r\
    \n\x05\x04\x83\x01\x02\0\x12\x04\xb4\x05\x02!\n\x0e\n\x06\x04\x83\x01\
    \x02\0\x04\x12\x04\xb4\x05\x02\n\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\
    \x04\xb4\x05\x0b\x11\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xb4\x05\
    \x12\x1c\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xb4\x05\x1f\x20\n\r\n\
    \x05\x04\x83\x01\x02\x01\x12\x04\xb5\x05\x02+\n\x0e\n\x06\x04\x83\x01\
    \x02\x01\x04\x12\x04\xb5\x05\x02\n\n\x0e\n\x06\x04\x83\x01\x02\x01\x06\
    \x12\x04\xb5\x05\x0b\x1d\n\x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xb5\
    \x05\x1e&\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xb5\x05)*\n\r\n\
    \x05\x04\x83\x01\x02\x02\x12\x04\xb6\x05\x02+\n\x0e\n\x06\x04\x83\x01\
    \x02\x02\x04\x12\x04\xb6\x05\x02\n\n\x0e\n\x06\x04\x83\x01\x02\x02\x06\
    \x12\x04\xb6\x05\x0b\x1d\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\xb6\
    \x05\x1e&\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\x12\x04\xb6\x05)*\n\r\n\
    \x05\x04\x83\x01\x02\x03\x12\x04\xb7\x05\x02(\n\x0e\n\x06\x04\x83\x01\
    \x02\x03\x04\x12\x04\xb7\x05\x02\n\n\x0e\n\x06\x04\x83\x01\x02\x03\x06\
    \x12\x04\xb7\x05\x0b\x1a\n\x0e\n\x06\x04\x83\x01\x02\x03\x01\x12\x04\xb7\
    \x05\x1b#\n\x0e\n\x06\x04\x83\x01\x02\x03\x03\x12\x04\xb7\x05&'\n\r\n\
    \x05\x04\x83\x01\x02\x04\x12\x04\xb8\x05\x02!\n\x0e\n\x06\x04\x83\x01\
    \x02\x04\x04\x12\x04\xb8\x05\x02\n\n\x0e\n\x06\x04\x83\x01\x02\x04\x05\
    \x12\x04\xb8\x05\x0b\x11\n\x0e\n\x06\x04\x83\x01\x02\x04\x01\x12\x04\xb8\
    \x05\x12\x1c\n\x0e\n\x06\x04\x83\x01\x02\x04\x03\x12\x04\xb8\x05\x1f\x20\
    \n\x1e\n\x03\x04\x84\x01\x12\x06\xbb\x05\0\xbc\x05\x01\"\x0f\x20void\x20\
    response\n\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\xbb\x05\x08#\n\r\n\x03\
    \x04\x85\x01\x12\x06\xbe\x05\0\xc0\x05\x01\n\x0c\n\x04\x04\x85\x01\x01\
    \x12\x04\xbe\x05\x08(\n\r\n\x05\x04\x85\x01\x02\0\x12\x04\xbf\x05\x02\
    \x1f\n\x0e\n\x06\x04\x85\x01\x02\0\x04\x12\x04\xbf\x05\x02\n\n\x0e\n\x06\
    \x04\x85\x01\x02\0\x05\x12\x04\xbf\x05\x0b\x10\n\x0e\n\x06\x04\x85\x01\
    \x02\0\x01\x12\x04\xbf\x05\x11\x1a\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\
    \x04\xbf\x05\x1d\x1e\n\x1e\n\x03\x04\x86\x01\x12\x06\xc2\x05\0\xc3\x05\
    \x01\"\x0f\x20void\x20response\n\n\x0c\n\x04\x04\x86\x01\x01\x12\x04\xc2\
    \x05\x08)\n\x1e\n\x03\x04\x87\x01\x12\x06\xc5\x05\0\xc6\x05\x01\"\x0f\
    \x20no\x20parameters\n\n\x0c\n\x04\x04\x87\x01\x01\x12\x04\xc5\x05\x08(\
    \n\r\n\x03\x04\x88\x01\x12\x06\xc8\x05\0\xca\x05\x01\n\x0c\n\x04\x04\x88\
    \x01\x01\x12\x04\xc8\x05\x08)\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\xc9\
    \x05\x028\n\x0e\n\x06\x04\x88\x01\x02\0\x04\x12\x04\xc9\x05\x02\n\n\x0e\
    \n\x06\x04\x88\x01\x02\0\x06\x12\x04\xc9\x05\x0b!\n\x0e\n\x06\x04\x88\
    \x01\x02\0\x01\x12\x04\xc9\x05\"3\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\
    \x04\xc9\x0567\n\r\n\x03\x04\x89\x01\x12\x06\xcc\x05\0\xcf\x05\x01\n\x0c\
    \n\x04\x04\x89\x01\x01\x12\x04\xcc\x05\x08\"\n\r\n\x05\x04\x89\x01\x02\0\
    \x12\x04\xcd\x05\x02#\n\x0e\n\x06\x04\x89\x01\x02\0\x04\x12\x04\xcd\x05\
    \x02\n\n\x0e\n\x06\x04\x89\x01\x02\0\x05\x12\x04\xcd\x05\x0b\x11\n\x0e\n\
    \x06\x04\x89\x01\x02\0\x01\x12\x04\xcd\x05\x12\x1e\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x03\x12\x04\xcd\x05!\"\n\r\n\x05\x04\x89\x01\x02\x01\x12\x04\
    \xce\x05\x02#\n\x0e\n\x06\x04\x89\x01\x02\x01\x04\x12\x04\xce\x05\x02\n\
    \n\x0e\n\x06\x04\x89\x01\x02\x01\x05\x12\x04\xce\x05\x0b\x11\n\x0e\n\x06\
    \x04\x89\x01\x02\x01\x01\x12\x04\xce\x05\x12\x1e\n\x0e\n\x06\x04\x89\x01\
    \x02\x01\x03\x12\x04\xce\x05!\"\n\r\n\x03\x04\x8a\x01\x12\x06\xd1\x05\0\
    \xd3\x05\x01\n\x0c\n\x04\x04\x8a\x01\x01\x12\x04\xd1\x05\x08#\n\r\n\x05\
    \x04\x8a\x01\x02\0\x12\x04\xd2\x05\x02#\n\x0e\n\x06\x04\x8a\x01\x02\0\
    \x04\x12\x04\xd2\x05\x02\n\n\x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\xd2\
    \x05\x0b\x11\n\x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\xd2\x05\x12\x1e\n\
    \x0e\n\x06\x04\x8a\x01\x02\0\x03\x12\x04\xd2\x05!\"\n\r\n\x03\x04\x8b\
    \x01\x12\x06\xd5\x05\0\xd9\x05\x01\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\
    \xd5\x05\x08\"\n\r\n\x05\x04\x8b\x01\x02\0\x12\x04\xd6\x05\x02#\n\x0e\n\
    \x06\x04\x8b\x01\x02\0\x04\x12\x04\xd6\x05\x02\n\n\x0e\n\x06\x04\x8b\x01\
    \x02\0\x05\x12\x04\xd6\x05\x0b\x11\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\
    \x04\xd6\x05\x12\x1e\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\xd6\x05!\
    \"\n\r\n\x05\x04\x8b\x01\x02\x01\x12\x04\xd7\x05\x02&\n\x0e\n\x06\x04\
    \x8b\x01\x02\x01\x04\x12\x04\xd7\x05\x02\n\n\x0e\n\x06\x04\x8b\x01\x02\
    \x01\x05\x12\x04\xd7\x05\x0b\x11\n\x0e\n\x06\x04\x8b\x01\x02\x01\x01\x12\
    \x04\xd7\x05\x12!\n\x0e\n\x06\x04\x8b\x01\x02\x01\x03\x12\x04\xd7\x05$%\
    \n\r\n\x05\x04\x8b\x01\x02\x02\x12\x04\xd8\x05\x02&\n\x0e\n\x06\x04\x8b\
    \x01\x02\x02\x04\x12\x04\xd8\x05\x02\n\n\x0e\n\x06\x04\x8b\x01\x02\x02\
    \x05\x12\x04\xd8\x05\x0b\x11\n\x0e\n\x06\x04\x8b\x01\x02\x02\x01\x12\x04\
    \xd8\x05\x12!\n\x0e\n\x06\x04\x8b\x01\x02\x02\x03\x12\x04\xd8\x05$%\n\
    \x1e\n\x03\x04\x8c\x01\x12\x06\xdb\x05\0\xdc\x05\x01\"\x0f\x20void\x20re\
    sponse\n\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xdb\x05\x08#\n\r\n\x03\x04\
    \x8d\x01\x12\x06\xde\x05\0\xe0\x05\x01\n\x0c\n\x04\x04\x8d\x01\x01\x12\
    \x04\xde\x05\x08!\n\r\n\x05\x04\x8d\x01\x02\0\x12\x04\xdf\x05\x02#\n\x0e\
    \n\x06\x04\x8d\x01\x02\0\x04\x12\x04\xdf\x05\x02\n\n\x0e\n\x06\x04\x8d\
    \x01\x02\0\x05\x12\x04\xdf\x05\x0b\x11\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\
    \x12\x04\xdf\x05\x12\x1e\n\x0e\n\x06\x04\x8d\x01\x02\0\x03\x12\x04\xdf\
    \x05!\"\n\r\n\x03\x04\x8e\x01\x12\x06\xe2\x05\0\xe3\x05\x01\n\x0c\n\x04\
    \x04\x8e\x01\x01\x12\x04\xe2\x05\x08\"\n\r\n\x03\x04\x8f\x01\x12\x06\xe5\
    \x05\0\xe7\x05\x01\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xe5\x05\x08$\n\r\
    \n\x05\x04\x8f\x01\x02\0\x12\x04\xe6\x05\x02#\n\x0e\n\x06\x04\x8f\x01\
    \x02\0\x04\x12\x04\xe6\x05\x02\n\n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\
    \x04\xe6\x05\x0b\x11\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\xe6\x05\
    \x12\x1e\n\x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xe6\x05!\"\n\r\n\x03\
    \x04\x90\x01\x12\x06\xe9\x05\0\xea\x05\x01\n\x0c\n\x04\x04\x90\x01\x01\
    \x12\x04\xe9\x05\x08%\n\r\n\x03\x04\x91\x01\x12\x06\xec\x05\0\xef\x05\
    \x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xec\x05\x08\"\n\r\n\x05\x04\x91\
    \x01\x02\0\x12\x04\xed\x05\x02#\n\x0e\n\x06\x04\x91\x01\x02\0\x04\x12\
    \x04\xed\x05\x02\n\n\x0e\n\x06\x04\x91\x01\x02\0\x05\x12\x04\xed\x05\x0b\
    \x11\n\x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xed\x05\x12\x1e\n\x0e\n\
    \x06\x04\x91\x01\x02\0\x03\x12\x04\xed\x05!\"\n\r\n\x05\x04\x91\x01\x02\
    \x01\x12\x04\xee\x05\x02#\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\x04\
    \xee\x05\x02\n\n\x0e\n\x06\x04\x91\x01\x02\x01\x05\x12\x04\xee\x05\x0b\
    \x11\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\xee\x05\x12\x1e\n\x0e\n\
    \x06\x04\x91\x01\x02\x01\x03\x12\x04\xee\x05!\"\n\x1e\n\x03\x04\x92\x01\
    \x12\x06\xf1\x05\0\xf2\x05\x01\"\x0f\x20void\x20response\n\n\x0c\n\x04\
    \x04\x92\x01\x01\x12\x04\xf1\x05\x08#\n\r\n\x03\x04\x93\x01\x12\x06\xf4\
    \x05\0\xf7\x05\x01\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\xf4\x05\x08\x1f\n\
    \r\n\x05\x04\x93\x01\x02\0\x12\x04\xf5\x05\x02\x1b\n\x0e\n\x06\x04\x93\
    \x01\x02\0\x04\x12\x04\xf5\x05\x02\n\n\x0e\n\x06\x04\x93\x01\x02\0\x05\
    \x12\x04\xf5\x05\x0b\x11\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xf5\
    \x05\x12\x16\n\x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\xf5\x05\x19\x1a\n\
    \r\n\x05\x04\x93\x01\x02\x01\x12\x04\xf6\x05\x020\n\x0e\n\x06\x04\x93\
    \x01\x02\x01\x04\x12\x04\xf6\x05\x02\n\n\x0e\n\x06\x04\x93\x01\x02\x01\
    \x06\x12\x04\xf6\x05\x0b&\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\
    \xf6\x05'+\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\xf6\x05./\n\x1e\n\
    \x03\x04\x94\x01\x12\x06\xf9\x05\0\xfa\x05\x01\"\x0f\x20void\x20response\
    \n\n\x0c\n\x04\x04\x94\x01\x01\x12\x04\xf9\x05\x08\x20\n\r\n\x03\x04\x95\
    \x01\x12\x06\xfc\x05\0\xfd\x05\x01\n\x0c\n\x04\x04\x95\x01\x01\x12\x04\
    \xfc\x05\x08)\n\r\n\x03\x04\x96\x01\x12\x06\xff\x05\0\x81\x06\x01\n\x0c\
    \n\x04\x04\x96\x01\x01\x12\x04\xff\x05\x08*\n\r\n\x05\x04\x96\x01\x02\0\
    \x12\x04\x80\x06\x02\x1a\n\x0e\n\x06\x04\x96\x01\x02\0\x04\x12\x04\x80\
    \x06\x02\n\n\x0e\n\x06\x04\x96\x01\x02\0\x05\x12\x04\x80\x06\x0b\x10\n\
    \x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\x80\x06\x11\x15\n\x0e\n\x06\x04\
    \x96\x01\x02\0\x03\x12\x04\x80\x06\x18\x19\n\r\n\x03\x04\x97\x01\x12\x06\
    \x83\x06\0\x85\x06\x01\n\x0c\n\x04\x04\x97\x01\x01\x12\x04\x83\x06\x08$\
    \n\r\n\x05\x04\x97\x01\x02\0\x12\x04\x84\x06\x02\x1a\n\x0e\n\x06\x04\x97\
    \x01\x02\0\x04\x12\x04\x84\x06\x02\n\n\x0e\n\x06\x04\x97\x01\x02\0\x05\
    \x12\x04\x84\x06\x0b\x10\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\x84\
    \x06\x11\x15\n\x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\x84\x06\x18\x19\n\
    \r\n\x03\x04\x98\x01\x12\x06\x87\x06\0\x89\x06\x01\n\x0c\n\x04\x04\x98\
    \x01\x01\x12\x04\x87\x06\x08%\n\r\n\x05\x04\x98\x01\x02\0\x12\x04\x88\
    \x06\x02*\n\x0e\n\x06\x04\x98\x01\x02\0\x04\x12\x04\x88\x06\x02\n\n\x0e\
    \n\x06\x04\x98\x01\x02\0\x06\x12\x04\x88\x06\x0b\x1a\n\x0e\n\x06\x04\x98\
    \x01\x02\0\x01\x12\x04\x88\x06\x1b%\n\x0e\n\x06\x04\x98\x01\x02\0\x03\
    \x12\x04\x88\x06()\n\r\n\x03\x04\x99\x01\x12\x06\x8b\x06\0\x8d\x06\x01\n\
    \x0c\n\x04\x04\x99\x01\x01\x12\x04\x8b\x06\x08!\n\r\n\x05\x04\x99\x01\
    \x02\0\x12\x04\x8c\x06\x02\x18\n\x0e\n\x06\x04\x99\x01\x02\0\x04\x12\x04\
    \x8c\x06\x02\n\n\x0e\n\x06\x04\x99\x01\x02\0\x05\x12\x04\x8c\x06\x0b\x10\
    \n\x0e\n\x06\x04\x99\x01\x02\0\x01\x12\x04\x8c\x06\x11\x13\n\x0e\n\x06\
    \x04\x99\x01\x02\0\x03\x12\x04\x8c\x06\x16\x17\n\r\n\x03\x04\x9a\x01\x12\
    \x06\x8f\x06\0\x94\x06\x01\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\x8f\x06\
    \x08#\n\r\n\x05\x04\x9a\x01\x02\0\x12\x04\x90\x06\x02\x18\n\x0e\n\x06\
    \x04\x9a\x01\x02\0\x04\x12\x04\x90\x06\x02\n\n\x0e\n\x06\x04\x9a\x01\x02\
    \0\x05\x12\x04\x90\x06\x0b\x10\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\
    \x90\x06\x11\x13\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\x12\x04\x90\x06\x16\
    \x17\n\r\n\x05\x04\x9a\x01\x02\x01\x12\x04\x91\x06\x02\x1b\n\x0e\n\x06\
    \x04\x9a\x01\x02\x01\x04\x12\x04\x91\x06\x02\n\n\x0e\n\x06\x04\x9a\x01\
    \x02\x01\x05\x12\x04\x91\x06\x0b\x11\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\
    \x12\x04\x91\x06\x12\x16\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\x91\
    \x06\x19\x1a\n\r\n\x05\x04\x9a\x01\x02\x02\x12\x04\x92\x06\x02!\n\x0e\n\
    \x06\x04\x9a\x01\x02\x02\x04\x12\x04\x92\x06\x02\n\n\x0e\n\x06\x04\x9a\
    \x01\x02\x02\x05\x12\x04\x92\x06\x0b\x11\n\x0e\n\x06\x04\x9a\x01\x02\x02\
    \x01\x12\x04\x92\x06\x12\x1c\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\
    \x92\x06\x1f\x20\n\r\n\x05\x04\x9a\x01\x02\x03\x12\x04\x93\x06\x02$\n\
    \x0e\n\x06\x04\x9a\x01\x02\x03\x04\x12\x04\x93\x06\x02\n\n\x0e\n\x06\x04\
    \x9a\x01\x02\x03\x05\x12\x04\x93\x06\x0b\x11\n\x0e\n\x06\x04\x9a\x01\x02\
    \x03\x01\x12\x04\x93\x06\x12\x1f\n\x0e\n\x06\x04\x9a\x01\x02\x03\x03\x12\
    \x04\x93\x06\"#\n\r\n\x03\x04\x9b\x01\x12\x06\x96\x06\0\x99\x06\x01\n\
    \x0c\n\x04\x04\x9b\x01\x01\x12\x04\x96\x06\x08\"\n\r\n\x05\x04\x9b\x01\
    \x02\0\x12\x04\x97\x06\x023\n\x0e\n\x06\x04\x9b\x01\x02\0\x04\x12\x04\
    \x97\x06\x02\n\n\x0e\n\x06\x04\x9b\x01\x02\0\x06\x12\x04\x97\x06\x0b&\n\
    \x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\x97\x06'.\n\x0e\n\x06\x04\x9b\
    \x01\x02\0\x03\x12\x04\x97\x0612\n\r\n\x05\x04\x9b\x01\x02\x01\x12\x04\
    \x98\x06\x02\x1c\n\x0e\n\x06\x04\x9b\x01\x02\x01\x04\x12\x04\x98\x06\x02\
    \n\n\x0e\n\x06\x04\x9b\x01\x02\x01\x05\x12\x04\x98\x06\x0b\x0f\n\x0e\n\
    \x06\x04\x9b\x01\x02\x01\x01\x12\x04\x98\x06\x10\x17\n\x0e\n\x06\x04\x9b\
    \x01\x02\x01\x03\x12\x04\x98\x06\x1a\x1b\n\x0c\n\x02\x06\0\x12\x06\x9b\
    \x06\0\xcf\x07\x01\n\x0b\n\x03\x06\0\x01\x12\x04\x9b\x06\x08\x1e\n\x0e\n\
    \x04\x06\0\x02\0\x12\x06\x9c\x06\x02\x9d\x06.\n\r\n\x05\x06\0\x02\0\x01\
    \x12\x04\x9c\x06\x06\x17\n\r\n\x05\x06\0\x02\0\x02\x12\x04\x9c\x06\x185\
    \n\r\n\x05\x06\0\x02\0\x03\x12\x04\x9d\x06\x0e,\n\x0e\n\x04\x06\0\x02\
    \x01\x12\x06\x9e\x06\x02\x9f\x06.\n\r\n\x05\x06\0\x02\x01\x01\x12\x04\
    \x9e\x06\x06\x17\n\r\n\x05\x06\0\x02\x01\x02\x12\x04\x9e\x06\x185\n\r\n\
    \x05\x06\0\x02\x01\x03\x12\x04\x9f\x06\x0e,\n\x0c\n\x04\x06\0\x02\x02\
    \x12\x04\xa0\x06\x02=\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\xa0\x06\x06\
    \x0c\n\r\n\x05\x06\0\x02\x02\x02\x12\x04\xa0\x06\r\x1f\n\r\n\x05\x06\0\
    \x02\x02\x03\x12\x04\xa0\x06(;\n\x0c\n\x04\x06\0\x02\x03\x12\x04\xa1\x06\
    \x02>\n\r\n\x05\x06\0\x02\x03\x01\x12\x04\xa1\x06\x06\x0c\n\r\n\x05\x06\
    \0\x02\x03\x02\x12\x04\xa1\x06\r\x1f\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\
    \xa1\x06)<\n\x0e\n\x04\x06\0\x02\x04\x12\x06\xa2\x06\x02\xa3\x06+\n\r\n\
    \x05\x06\0\x02\x04\x01\x12\x04\xa2\x06\x06\x14\n\r\n\x05\x06\0\x02\x04\
    \x02\x12\x04\xa2\x06\x15/\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\xa3\x06\
    \x0e)\n\x0e\n\x04\x06\0\x02\x05\x12\x06\xa4\x06\x02\xa5\x06-\n\r\n\x05\
    \x06\0\x02\x05\x01\x12\x04\xa4\x06\x06\x16\n\r\n\x05\x06\0\x02\x05\x02\
    \x12\x04\xa4\x06\x173\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\xa5\x06\x0e+\n\
    \x0e\n\x04\x06\0\x02\x06\x12\x06\xa6\x06\x02\xa7\x06/\n\r\n\x05\x06\0\
    \x02\x06\x01\x12\x04\xa6\x06\x06\x18\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\
    \xa6\x06\x197\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\xa7\x06\x0e-\n\x0e\n\
    \x04\x06\0\x02\x07\x12\x06\xa8\x06\x02\xa9\x06-\n\r\n\x05\x06\0\x02\x07\
    \x01\x12\x04\xa8\x06\x06\x16\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\xa8\x06\
    \x173\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\xa9\x06\x0e+\n\x0e\n\x04\x06\0\
    \x02\x08\x12\x06\xaa\x06\x02\xab\x06/\n\r\n\x05\x06\0\x02\x08\x01\x12\
    \x04\xaa\x06\x06\x18\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\xaa\x06\x197\n\
    \r\n\x05\x06\0\x02\x08\x03\x12\x04\xab\x06\x0e-\n\x0e\n\x04\x06\0\x02\t\
    \x12\x06\xac\x06\x02\xad\x06*\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xac\x06\
    \x06\x13\n\r\n\x05\x06\0\x02\t\x02\x12\x04\xac\x06\x14-\n\r\n\x05\x06\0\
    \x02\t\x03\x12\x04\xad\x06\x0e(\n\x0c\n\x04\x06\0\x02\n\x12\x04\xae\x06\
    \x02D\n\r\n\x05\x06\0\x02\n\x01\x12\x04\xae\x06\x06\x0e\n\r\n\x05\x06\0\
    \x02\n\x02\x12\x04\xae\x06\x0f#\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xae\
    \x06-B\n\x0c\n\x04\x06\0\x02\x0b\x12\x04\xaf\x06\x02P\n\r\n\x05\x06\0\
    \x02\x0b\x01\x12\x04\xaf\x06\x06\x12\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\
    \xaf\x06\x13+\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xaf\x065N\n\x0c\n\x04\
    \x06\0\x02\x0c\x12\x04\xb0\x06\x02D\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\
    \xb0\x06\x06\x0e\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xb0\x06\x0f#\n\r\n\
    \x05\x06\0\x02\x0c\x03\x12\x04\xb0\x06-B\n\x0e\n\x04\x06\0\x02\r\x12\x06\
    \xb1\x06\x02\xb2\x062\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xb1\x06\x06\x1b\
    \n\r\n\x05\x06\0\x02\r\x02\x12\x04\xb1\x06\x1c=\n\r\n\x05\x06\0\x02\r\
    \x03\x12\x04\xb2\x06\x0e0\n\x0c\n\x04\x06\0\x02\x0e\x12\x04\xb3\x06\x02D\
    \n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\xb3\x06\x06\x0e\n\r\n\x05\x06\0\x02\
    \x0e\x02\x12\x04\xb3\x06\x0f#\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\xb3\
    \x06-B\n\x0e\n\x04\x06\0\x02\x0f\x12\x06\xb4\x06\x02\xb5\x06,\n\r\n\x05\
    \x06\0\x02\x0f\x01\x12\x04\xb4\x06\x06\x15\n\r\n\x05\x06\0\x02\x0f\x02\
    \x12\x04\xb4\x06\x161\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\xb5\x06\x0e*\n\
    \x0c\n\x04\x06\0\x02\x10\x12\x04\xb6\x06\x02>\n\r\n\x05\x06\0\x02\x10\
    \x01\x12\x04\xb6\x06\x06\x0c\n\r\n\x05\x06\0\x02\x10\x02\x12\x04\xb6\x06\
    \r\x1f\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xb6\x06)<\n\x0c\n\x04\x06\0\
    \x02\x11\x12\x04\xb7\x06\x02D\n\r\n\x05\x06\0\x02\x11\x01\x12\x04\xb7\
    \x06\x06\x0e\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\xb7\x06\x0f#\n\r\n\x05\
    \x06\0\x02\x11\x03\x12\x04\xb7\x06-B\n\x0c\n\x04\x06\0\x02\x12\x12\x04\
    \xb8\x06\x02>\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xb8\x06\x06\x0c\n\r\n\
    \x05\x06\0\x02\x12\x02\x12\x04\xb8\x06\r\x1f\n\r\n\x05\x06\0\x02\x12\x03\
    \x12\x04\xb8\x06)<\n\x0c\n\x04\x06\0\x02\x13\x12\x04\xb9\x06\x02A\n\r\n\
    \x05\x06\0\x02\x13\x01\x12\x04\xb9\x06\x06\r\n\r\n\x05\x06\0\x02\x13\x02\
    \x12\x04\xb9\x06\x0e!\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\xb9\x06+?\n\
    \x0c\n\x04\x06\0\x02\x14\x12\x04\xba\x06\x02>\n\r\n\x05\x06\0\x02\x14\
    \x01\x12\x04\xba\x06\x06\x0c\n\r\n\x05\x06\0\x02\x14\x02\x12\x04\xba\x06\
    \r\x1f\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xba\x06)<\n\x0c\n\x04\x06\0\
    \x02\x15\x12\x04\xbb\x06\x02>\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\xbb\
    \x06\x06\x0c\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\xbb\x06\r\x1f\n\r\n\x05\
    \x06\0\x02\x15\x03\x12\x04\xbb\x06)<\n\x0c\n\x04\x06\0\x02\x16\x12\x04\
    \xbc\x06\x02J\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\xbc\x06\x06\x10\n\r\n\
    \x05\x06\0\x02\x16\x02\x12\x04\xbc\x06\x11'\n\r\n\x05\x06\0\x02\x16\x03\
    \x12\x04\xbc\x061H\n\x0c\n\x04\x06\0\x02\x17\x12\x04\xbd\x06\x02J\n\r\n\
    \x05\x06\0\x02\x17\x01\x12\x04\xbd\x06\x06\x10\n\r\n\x05\x06\0\x02\x17\
    \x02\x12\x04\xbd\x06\x11'\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\xbd\x061H\
    \n\x0e\n\x04\x06\0\x02\x18\x12\x06\xbe\x06\x02\xbf\x06)\n\r\n\x05\x06\0\
    \x02\x18\x01\x12\x04\xbe\x06\x06\x12\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\
    \xbe\x06\x13+\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\xbf\x06\x0e'\n\x0c\n\
    \x04\x06\0\x02\x19\x12\x04\xc0\x06\x02K\n\r\n\x05\x06\0\x02\x19\x01\x12\
    \x04\xc0\x06\x06\x10\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xc0\x06\x11(\n\
    \r\n\x05\x06\0\x02\x19\x03\x12\x04\xc0\x062I\n\x0e\n\x04\x06\0\x02\x1a\
    \x12\x06\xc1\x06\x02\xc2\x067\n\r\n\x05\x06\0\x02\x1a\x01\x12\x04\xc1\
    \x06\x06\x1f\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xc1\x06\x20E\n\r\n\x05\
    \x06\0\x02\x1a\x03\x12\x04\xc2\x06\x0f5\n\x0e\n\x04\x06\0\x02\x1b\x12\
    \x06\xc3\x06\x02\xc4\x064\n\r\n\x05\x06\0\x02\x1b\x01\x12\x04\xc3\x06\
    \x06\x1c\n\r\n\x05\x06\0\x02\x1b\x02\x12\x04\xc3\x06\x1d?\n\r\n\x05\x06\
    \0\x02\x1b\x03\x12\x04\xc4\x06\x0f2\n\x0e\n\x04\x06\0\x02\x1c\x12\x06\
    \xc5\x06\x02\xc6\x06.\n\r\n\x05\x06\0\x02\x1c\x01\x12\x04\xc5\x06\x06\
    \x17\n\r\n\x05\x06\0\x02\x1c\x02\x12\x04\xc5\x06\x185\n\r\n\x05\x06\0\
    \x02\x1c\x03\x12\x04\xc6\x06\x0e,\n\x0e\n\x04\x06\0\x02\x1d\x12\x06\xc7\
    \x06\x02\xc8\x065\n\r\n\x05\x06\0\x02\x1d\x01\x12\x04\xc7\x06\x06\x1e\n\
    \r\n\x05\x06\0\x02\x1d\x02\x12\x04\xc7\x06\x1fC\n\r\n\x05\x06\0\x02\x1d\
    \x03\x12\x04\xc8\x06\x0e3\n\x0e\n\x04\x06\0\x02\x1e\x12\x06\xc9\x06\x02\
    \xca\x062\n\r\n\x05\x06\0\x02\x1e\x01\x12\x04\xc9\x06\x06\x1b\n\r\n\x05\
    \x06\0\x02\x1e\x02\x12\x04\xc9\x06\x1c=\n\r\n\x05\x06\0\x02\x1e\x03\x12\
    \x04\xca\x06\x0e0\n\x0e\n\x04\x06\0\x02\x1f\x12\x06\xcb\x06\x02\xcc\x06(\
    \n\r\n\x05\x06\0\x02\x1f\x01\x12\x04\xcb\x06\x06\x11\n\r\n\x05\x06\0\x02\
    \x1f\x02\x12\x04\xcb\x06\x12)\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\xcc\
    \x06\x0e&\n\x0e\n\x04\x06\0\x02\x20\x12\x06\xcd\x06\x02\xce\x06*\n\r\n\
    \x05\x06\0\x02\x20\x01\x12\x04\xcd\x06\x06\x13\n\r\n\x05\x06\0\x02\x20\
    \x02\x12\x04\xcd\x06\x14-\n\r\n\x05\x06\0\x02\x20\x03\x12\x04\xce\x06\
    \x0e(\n\x0e\n\x04\x06\0\x02!\x12\x06\xcf\x06\x02\xd0\x06&\n\r\n\x05\x06\
    \0\x02!\x01\x12\x04\xcf\x06\x06\x0f\n\r\n\x05\x06\0\x02!\x02\x12\x04\xcf\
    \x06\x10%\n\r\n\x05\x06\0\x02!\x03\x12\x04\xd0\x06\x0e$\n\x0e\n\x04\x06\
    \0\x02\"\x12\x06\xd1\x06\x02\xd2\x061\n\r\n\x05\x06\0\x02\"\x01\x12\x04\
    \xd1\x06\x06\x1a\n\r\n\x05\x06\0\x02\"\x02\x12\x04\xd1\x06\x1b;\n\r\n\
    \x05\x06\0\x02\"\x03\x12\x04\xd2\x06\x0e/\n\x0c\n\x04\x06\0\x02#\x12\x04\
    \xd3\x06\x02P\n\r\n\x05\x06\0\x02#\x01\x12\x04\xd3\x06\x06\x12\n\r\n\x05\
    \x06\0\x02#\x02\x12\x04\xd3\x06\x13+\n\r\n\x05\x06\0\x02#\x03\x12\x04\
    \xd3\x065N\n\x0e\n\x04\x06\0\x02$\x12\x06\xd4\x06\x02\xd5\x06,\n\r\n\x05\
    \x06\0\x02$\x01\x12\x04\xd4\x06\x06\x15\n\r\n\x05\x06\0\x02$\x02\x12\x04\
    \xd4\x06\x161\n\r\n\x05\x06\0\x02$\x03\x12\x04\xd5\x06\x0e*\n\x0e\n\x04\
    \x06\0\x02%\x12\x06\xd6\x06\x02\xd7\x06+\n\r\n\x05\x06\0\x02%\x01\x12\
    \x04\xd6\x06\x06\x14\n\r\n\x05\x06\0\x02%\x02\x12\x04\xd6\x06\x15/\n\r\n\
    \x05\x06\0\x02%\x03\x12\x04\xd7\x06\x0e)\n\x0e\n\x04\x06\0\x02&\x12\x06\
    \xd8\x06\x02\xd9\x062\n\r\n\x05\x06\0\x02&\x01\x12\x04\xd8\x06\x06\x1b\n\
    \r\n\x05\x06\0\x02&\x02\x12\x04\xd8\x06\x1c=\n\r\n\x05\x06\0\x02&\x03\
    \x12\x04\xd9\x06\x0e0\n\x0c\n\x04\x06\0\x02'\x12\x04\xda\x06\x02D\n\r\n\
    \x05\x06\0\x02'\x01\x12\x04\xda\x06\x06\x0e\n\r\n\x05\x06\0\x02'\x02\x12\
    \x04\xda\x06\x0f#\n\r\n\x05\x06\0\x02'\x03\x12\x04\xda\x06-B\n\x0c\n\x04\
    \x06\0\x02(\x12\x04\xdb\x06\x02M\n\r\n\x05\x06\0\x02(\x01\x12\x04\xdb\
    \x06\x06\x11\n\r\n\x05\x06\0\x02(\x02\x12\x04\xdb\x06\x12)\n\r\n\x05\x06\
    \0\x02(\x03\x12\x04\xdb\x063K\n\x0e\n\x04\x06\0\x02)\x12\x06\xdc\x06\x02\
    \xdd\x06/\n\r\n\x05\x06\0\x02)\x01\x12\x04\xdc\x06\x06\x17\n\r\n\x05\x06\
    \0\x02)\x02\x12\x04\xdc\x06\x185\n\r\n\x05\x06\0\x02)\x03\x12\x04\xdd\
    \x06\x0f-\n\x0e\n\x04\x06\0\x02*\x12\x06\xde\x06\x02\xdf\x062\n\r\n\x05\
    \x06\0\x02*\x01\x12\x04\xde\x06\x06\x1a\n\r\n\x05\x06\0\x02*\x02\x12\x04\
    \xde\x06\x1b;\n\r\n\x05\x06\0\x02*\x03\x12\x04\xdf\x06\x0f0\n\x0e\n\x04\
    \x06\0\x02+\x12\x06\xe0\x06\x02\xe1\x062\n\r\n\x05\x06\0\x02+\x01\x12\
    \x04\xe0\x06\x06\x1a\n\r\n\x05\x06\0\x02+\x02\x12\x04\xe0\x06\x1b;\n\r\n\
    \x05\x06\0\x02+\x03\x12\x04\xe1\x06\x0f0\n\x0e\n\x04\x06\0\x02,\x12\x06\
    \xe2\x06\x02\xe3\x061\n\r\n\x05\x06\0\x02,\x01\x12\x04\xe2\x06\x06\x19\n\
    \r\n\x05\x06\0\x02,\x02\x12\x04\xe2\x06\x1a9\n\r\n\x05\x06\0\x02,\x03\
    \x12\x04\xe3\x06\x0f/\n\x0e\n\x04\x06\0\x02-\x12\x06\xe4\x06\x02\xe5\x06\
    )\n\r\n\x05\x06\0\x02-\x01\x12\x04\xe4\x06\x06\x12\n\r\n\x05\x06\0\x02-\
    \x02\x12\x04\xe4\x06\x13+\n\r\n\x05\x06\0\x02-\x03\x12\x04\xe5\x06\x0e'\
    \n\x0e\n\x04\x06\0\x02.\x12\x06\xe6\x06\x02\xe7\x06,\n\r\n\x05\x06\0\x02\
    .\x01\x12\x04\xe6\x06\x06\x15\n\r\n\x05\x06\0\x02.\x02\x12\x04\xe6\x06\
    \x161\n\r\n\x05\x06\0\x02.\x03\x12\x04\xe7\x06\x0e*\n\x0e\n\x04\x06\0\
    \x02/\x12\x06\xe8\x06\x02\xe9\x06,\n\r\n\x05\x06\0\x02/\x01\x12\x04\xe8\
    \x06\x06\x15\n\r\n\x05\x06\0\x02/\x02\x12\x04\xe8\x06\x161\n\r\n\x05\x06\
    \0\x02/\x03\x12\x04\xe9\x06\x0e*\n\x0e\n\x04\x06\0\x020\x12\x06\xea\x06\
    \x02\xeb\x06+\n\r\n\x05\x06\0\x020\x01\x12\x04\xea\x06\x06\x14\n\r\n\x05\
    \x06\0\x020\x02\x12\x04\xea\x06\x15/\n\r\n\x05\x06\0\x020\x03\x12\x04\
    \xeb\x06\x0e)\n\x0e\n\x04\x06\0\x021\x12\x06\xec\x06\x02\xed\x06,\n\r\n\
    \x05\x06\0\x021\x01\x12\x04\xec\x06\x06\x15\n\r\n\x05\x06\0\x021\x02\x12\
    \x04\xec\x06\x161\n\r\n\x05\x06\0\x021\x03\x12\x04\xed\x06\x0e*\n\x0e\n\
    \x04\x06\0\x022\x12\x06\xee\x06\x02\xef\x06.\n\r\n\x05\x06\0\x022\x01\
    \x12\x04\xee\x06\x06\x17\n\r\n\x05\x06\0\x022\x02\x12\x04\xee\x06\x185\n\
    \r\n\x05\x06\0\x022\x03\x12\x04\xef\x06\x0e,\n\x0c\n\x04\x06\0\x023\x12\
    \x04\xf0\x06\x02D\n\r\n\x05\x06\0\x023\x01\x12\x04\xf0\x06\x06\x0e\n\r\n\
    \x05\x06\0\x023\x02\x12\x04\xf0\x06\x0f#\n\r\n\x05\x06\0\x023\x03\x12\
    \x04\xf0\x06-B\n\x0c\n\x04\x06\0\x024\x12\x04\xf1\x06\x02;\n\r\n\x05\x06\
    \0\x024\x01\x12\x04\xf1\x06\x06\x0b\n\r\n\x05\x06\0\x024\x02\x12\x04\xf1\
    \x06\x0c\x1d\n\r\n\x05\x06\0\x024\x03\x12\x04\xf1\x06'9\n\x0c\n\x04\x06\
    \0\x025\x12\x04\xf2\x06\x02D\n\r\n\x05\x06\0\x025\x01\x12\x04\xf2\x06\
    \x06\x0e\n\r\n\x05\x06\0\x025\x02\x12\x04\xf2\x06\x0f#\n\r\n\x05\x06\0\
    \x025\x03\x12\x04\xf2\x06-B\n\x0e\n\x04\x06\0\x026\x12\x06\xf3\x06\x02\
    \xf4\x06*\n\r\n\x05\x06\0\x026\x01\x12\x04\xf3\x06\x06\x13\n\r\n\x05\x06\
    \0\x026\x02\x12\x04\xf3\x06\x14-\n\r\n\x05\x06\0\x026\x03\x12\x04\xf4\
    \x06\x0e(\n\x0e\n\x04\x06\0\x027\x12\x06\xf5\x06\x02\xf6\x06*\n\r\n\x05\
    \x06\0\x027\x01\x12\x04\xf5\x06\x06\x13\n\r\n\x05\x06\0\x027\x02\x12\x04\
    \xf5\x06\x14-\n\r\n\x05\x06\0\x027\x03\x12\x04\xf6\x06\x0e(\n\x0e\n\x04\
    \x06\0\x028\x12\x06\xf7\x06\x02\xf8\x063\n\r\n\x05\x06\0\x028\x01\x12\
    \x04\xf7\x06\x06\x1c\n\r\n\x05\x06\0\x028\x02\x12\x04\xf7\x06\x1d?\n\r\n\
    \x05\x06\0\x028\x03\x12\x04\xf8\x06\x0e1\n\x0e\n\x04\x06\0\x029\x12\x06\
    \xf9\x06\x02\xfa\x06+\n\r\n\x05\x06\0\x029\x01\x12\x04\xf9\x06\x06\x14\n\
    \r\n\x05\x06\0\x029\x02\x12\x04\xf9\x06\x15/\n\r\n\x05\x06\0\x029\x03\
    \x12\x04\xfa\x06\x0e)\n\x0e\n\x04\x06\0\x02:\x12\x06\xfb\x06\x02\xfc\x06\
    =\n\r\n\x05\x06\0\x02:\x01\x12\x04\xfb\x06\x06\x18\n\r\n\x05\x06\0\x02:\
    \x02\x12\x04\xfb\x06\x19E\n\r\n\x05\x06\0\x02:\x03\x12\x04\xfc\x06\x0e;\
    \n\x0e\n\x04\x06\0\x02;\x12\x06\xfd\x06\x02\xfe\x06?\n\r\n\x05\x06\0\x02\
    ;\x01\x12\x04\xfd\x06\x06\x1a\n\r\n\x05\x06\0\x02;\x02\x12\x04\xfd\x06\
    \x1bI\n\r\n\x05\x06\0\x02;\x03\x12\x04\xfe\x06\x0e=\n\x0e\n\x04\x06\0\
    \x02<\x12\x06\xff\x06\x02\x80\x07@\n\r\n\x05\x06\0\x02<\x01\x12\x04\xff\
    \x06\x06\x1b\n\r\n\x05\x06\0\x02<\x02\x12\x04\xff\x06\x1cK\n\r\n\x05\x06\
    \0\x02<\x03\x12\x04\x80\x07\x0e>\n\x0e\n\x04\x06\0\x02=\x12\x06\x81\x07\
    \x02\x82\x071\n\r\n\x05\x06\0\x02=\x01\x12\x04\x81\x07\x06\x1a\n\r\n\x05\
    \x06\0\x02=\x02\x12\x04\x81\x07\x1b;\n\r\n\x05\x06\0\x02=\x03\x12\x04\
    \x82\x07\x0e/\n\x0e\n\x04\x06\0\x02>\x12\x06\x83\x07\x02\x84\x071\n\r\n\
    \x05\x06\0\x02>\x01\x12\x04\x83\x07\x06\x1a\n\r\n\x05\x06\0\x02>\x02\x12\
    \x04\x83\x07\x1b;\n\r\n\x05\x06\0\x02>\x03\x12\x04\x84\x07\x0e/\n\x0e\n\
    \x04\x06\0\x02?\x12\x06\x85\x07\x02\x86\x07+\n\r\n\x05\x06\0\x02?\x01\
    \x12\x04\x85\x07\x06\x14\n\r\n\x05\x06\0\x02?\x02\x12\x04\x85\x07\x15/\n\
    \r\n\x05\x06\0\x02?\x03\x12\x04\x86\x07\x0e)\n\x0e\n\x04\x06\0\x02@\x12\
    \x06\x87\x07\x02\x88\x07+\n\r\n\x05\x06\0\x02@\x01\x12\x04\x87\x07\x06\
    \x14\n\r\n\x05\x06\0\x02@\x02\x12\x04\x87\x07\x15/\n\r\n\x05\x06\0\x02@\
    \x03\x12\x04\x88\x07\x0e)\n\x0e\n\x04\x06\0\x02A\x12\x06\x89\x07\x02\x8a\
    \x07*\n\r\n\x05\x06\0\x02A\x01\x12\x04\x89\x07\x06\x13\n\r\n\x05\x06\0\
    \x02A\x02\x12\x04\x89\x07\x14-\n\r\n\x05\x06\0\x02A\x03\x12\x04\x8a\x07\
    \x0e(\n\x0e\n\x04\x06\0\x02B\x12\x06\x8b\x07\x02\x8c\x07-\n\r\n\x05\x06\
    \0\x02B\x01\x12\x04\x8b\x07\x06\x16\n\r\n\x05\x06\0\x02B\x02\x12\x04\x8b\
    \x07\x173\n\r\n\x05\x06\0\x02B\x03\x12\x04\x8c\x07\x0e+\n\x0e\n\x04\x06\
    \0\x02C\x12\x06\x8d\x07\x02\x8e\x077\n\r\n\x05\x06\0\x02C\x01\x12\x04\
    \x8d\x07\x06\x20\n\r\n\x05\x06\0\x02C\x02\x12\x04\x8d\x07!G\n\r\n\x05\
    \x06\0\x02C\x03\x12\x04\x8e\x07\x0e5\n\x0e\n\x04\x06\0\x02D\x12\x06\x8f\
    \x07\x02\x90\x07+\n\r\n\x05\x06\0\x02D\x01\x12\x04\x8f\x07\x06\x14\n\r\n\
    \x05\x06\0\x02D\x02\x12\x04\x8f\x07\x15/\n\r\n\x05\x06\0\x02D\x03\x12\
    \x04\x90\x07\x0e)\n\x0e\n\x04\x06\0\x02E\x12\x06\x91\x07\x02\x92\x072\n\
    \r\n\x05\x06\0\x02E\x01\x12\x04\x91\x07\x06\x1b\n\r\n\x05\x06\0\x02E\x02\
    \x12\x04\x91\x07\x1c=\n\r\n\x05\x06\0\x02E\x03\x12\x04\x92\x07\x0e0\n\
    \x0e\n\x04\x06\0\x02F\x12\x06\x93\x07\x02\x94\x07)\n\r\n\x05\x06\0\x02F\
    \x01\x12\x04\x93\x07\x06\x12\n\r\n\x05\x06\0\x02F\x02\x12\x04\x93\x07\
    \x13+\n\r\n\x05\x06\0\x02F\x03\x12\x04\x94\x07\x0e'\n\x0e\n\x04\x06\0\
    \x02G\x12\x06\x95\x07\x02\x96\x07-\n\r\n\x05\x06\0\x02G\x01\x12\x04\x95\
    \x07\x06\x16\n\r\n\x05\x06\0\x02G\x02\x12\x04\x95\x07\x173\n\r\n\x05\x06\
    \0\x02G\x03\x12\x04\x96\x07\x0e+\n\x0e\n\x04\x06\0\x02H\x12\x06\x97\x07\
    \x02\x98\x07-\n\r\n\x05\x06\0\x02H\x01\x12\x04\x97\x07\x06\x16\n\r\n\x05\
    \x06\0\x02H\x02\x12\x04\x97\x07\x173\n\r\n\x05\x06\0\x02H\x03\x12\x04\
    \x98\x07\x0e+\n\x0e\n\x04\x06\0\x02I\x12\x06\x99\x07\x02\x9a\x07-\n\r\n\
    \x05\x06\0\x02I\x01\x12\x04\x99\x07\x06\x16\n\r\n\x05\x06\0\x02I\x02\x12\
    \x04\x99\x07\x173\n\r\n\x05\x06\0\x02I\x03\x12\x04\x9a\x07\x0e+\n\x0e\n\
    \x04\x06\0\x02J\x12\x06\x9b\x07\x02\x9c\x07&\n\r\n\x05\x06\0\x02J\x01\
    \x12\x04\x9b\x07\x06\x0f\n\r\n\x05\x06\0\x02J\x02\x12\x04\x9b\x07\x10%\n\
    \r\n\x05\x06\0\x02J\x03\x12\x04\x9c\x07\x0e$\n\x0e\n\x04\x06\0\x02K\x12\
    \x06\x9d\x07\x02\x9e\x07#\n\r\n\x05\x06\0\x02K\x01\x12\x04\x9d\x07\x06\
    \x0c\n\r\n\x05\x06\0\x02K\x02\x12\x04\x9d\x07\r\x1f\n\r\n\x05\x06\0\x02K\
    \x03\x12\x04\x9e\x07\x0e!\n\x0e\n\x04\x06\0\x02L\x12\x06\x9f\x07\x02\xa0\
    \x07)\n\r\n\x05\x06\0\x02L\x01\x12\x04\x9f\x07\x06\x12\n\r\n\x05\x06\0\
    \x02L\x02\x12\x04\x9f\x07\x13+\n\r\n\x05\x06\0\x02L\x03\x12\x04\xa0\x07\
    \x0e'\n\x0e\n\x04\x06\0\x02M\x12\x06\xa1\x07\x02\xa2\x07%\n\r\n\x05\x06\
    \0\x02M\x01\x12\x04\xa1\x07\x06\x0e\n\r\n\x05\x06\0\x02M\x02\x12\x04\xa1\
    \x07\x0f#\n\r\n\x05\x06\0\x02M\x03\x12\x04\xa2\x07\x0e#\n\x0e\n\x04\x06\
    \0\x02N\x12\x06\xa3\x07\x02\xa4\x07&\n\r\n\x05\x06\0\x02N\x01\x12\x04\
    \xa3\x07\x06\x0f\n\r\n\x05\x06\0\x02N\x02\x12\x04\xa3\x07\x10%\n\r\n\x05\
    \x06\0\x02N\x03\x12\x04\xa4\x07\x0e$\n\x0e\n\x04\x06\0\x02O\x12\x06\xa5\
    \x07\x02\xa6\x07'\n\r\n\x05\x06\0\x02O\x01\x12\x04\xa5\x07\x06\x10\n\r\n\
    \x05\x06\0\x02O\x02\x12\x04\xa5\x07\x11'\n\r\n\x05\x06\0\x02O\x03\x12\
    \x04\xa6\x07\x0e%\n\x0e\n\x04\x06\0\x02P\x12\x06\xa7\x07\x02\xa8\x07(\n\
    \r\n\x05\x06\0\x02P\x01\x12\x04\xa7\x07\x06\x11\n\r\n\x05\x06\0\x02P\x02\
    \x12\x04\xa7\x07\x12)\n\r\n\x05\x06\0\x02P\x03\x12\x04\xa8\x07\x0e&\n\
    \x0e\n\x04\x06\0\x02Q\x12\x06\xa9\x07\x02\xaa\x07(\n\r\n\x05\x06\0\x02Q\
    \x01\x12\x04\xa9\x07\x06\x11\n\r\n\x05\x06\0\x02Q\x02\x12\x04\xa9\x07\
    \x12)\n\r\n\x05\x06\0\x02Q\x03\x12\x04\xaa\x07\x0e&\n\x0e\n\x04\x06\0\
    \x02R\x12\x06\xab\x07\x02\xac\x071\n\r\n\x05\x06\0\x02R\x01\x12\x04\xab\
    \x07\x06\x1a\n\r\n\x05\x06\0\x02R\x02\x12\x04\xab\x07\x1b;\n\r\n\x05\x06\
    \0\x02R\x03\x12\x04\xac\x07\x0e/\n\x0e\n\x04\x06\0\x02S\x12\x06\xad\x07\
    \x02\xae\x070\n\r\n\x05\x06\0\x02S\x01\x12\x04\xad\x07\x06\x19\n\r\n\x05\
    \x06\0\x02S\x02\x12\x04\xad\x07\x1a9\n\r\n\x05\x06\0\x02S\x03\x12\x04\
    \xae\x07\x0e.\n\x0e\n\x04\x06\0\x02T\x12\x06\xaf\x07\x02\xb0\x074\n\r\n\
    \x05\x06\0\x02T\x01\x12\x04\xaf\x07\x06\x1d\n\r\n\x05\x06\0\x02T\x02\x12\
    \x04\xaf\x07\x1eA\n\r\n\x05\x06\0\x02T\x03\x12\x04\xb0\x07\x0e2\n\x0e\n\
    \x04\x06\0\x02U\x12\x06\xb1\x07\x02\xb2\x073\n\r\n\x05\x06\0\x02U\x01\
    \x12\x04\xb1\x07\x06\x1c\n\r\n\x05\x06\0\x02U\x02\x12\x04\xb1\x07\x1d?\n\
    \r\n\x05\x06\0\x02U\x03\x12\x04\xb2\x07\x0e1\n\x0e\n\x04\x06\0\x02V\x12\
    \x06\xb3\x07\x02\xb4\x07)\n\r\n\x05\x06\0\x02V\x01\x12\x04\xb3\x07\x06\
    \x12\n\r\n\x05\x06\0\x02V\x02\x12\x04\xb3\x07\x13+\n\r\n\x05\x06\0\x02V\
    \x03\x12\x04\xb4\x07\x0e'\n\x0e\n\x04\x06\0\x02W\x12\x06\xb5\x07\x02\xb6\
    \x073\n\r\n\x05\x06\0\x02W\x01\x12\x04\xb5\x07\x06\x1c\n\r\n\x05\x06\0\
    \x02W\x02\x12\x04\xb5\x07\x1d?\n\r\n\x05\x06\0\x02W\x03\x12\x04\xb6\x07\
    \x0e1\n\x0e\n\x04\x06\0\x02X\x12\x06\xb7\x07\x02\xb8\x075\n\r\n\x05\x06\
    \0\x02X\x01\x12\x04\xb7\x07\x06\x1e\n\r\n\x05\x06\0\x02X\x02\x12\x04\xb7\
    \x07\x1fC\n\r\n\x05\x06\0\x02X\x03\x12\x04\xb8\x07\x0e3\n\x0e\n\x04\x06\
    \0\x02Y\x12\x06\xb9\x07\x02\xba\x072\n\r\n\x05\x06\0\x02Y\x01\x12\x04\
    \xb9\x07\x06\x1b\n\r\n\x05\x06\0\x02Y\x02\x12\x04\xb9\x07\x1c=\n\r\n\x05\
    \x06\0\x02Y\x03\x12\x04\xba\x07\x0e0\n\x0e\n\x04\x06\0\x02Z\x12\x06\xbb\
    \x07\x02\xbc\x07-\n\r\n\x05\x06\0\x02Z\x01\x12\x04\xbb\x07\x06\x16\n\r\n\
    \x05\x06\0\x02Z\x02\x12\x04\xbb\x07\x173\n\r\n\x05\x06\0\x02Z\x03\x12\
    \x04\xbc\x07\x0e+\n\x0e\n\x04\x06\0\x02[\x12\x06\xbd\x07\x02\xbe\x075\n\
    \r\n\x05\x06\0\x02[\x01\x12\x04\xbd\x07\x06\x1e\n\r\n\x05\x06\0\x02[\x02\
    \x12\x04\xbd\x07\x1fC\n\r\n\x05\x06\0\x02[\x03\x12\x04\xbe\x07\x0e3\n\
    \x0e\n\x04\x06\0\x02\\\x12\x06\xbf\x07\x02\xc0\x075\n\r\n\x05\x06\0\x02\
    \\\x01\x12\x04\xbf\x07\x06\x1e\n\r\n\x05\x06\0\x02\\\x02\x12\x04\xbf\x07\
    \x1fC\n\r\n\x05\x06\0\x02\\\x03\x12\x04\xc0\x07\x0e3\n\x0e\n\x04\x06\0\
    \x02]\x12\x06\xc1\x07\x02\xc2\x076\n\r\n\x05\x06\0\x02]\x01\x12\x04\xc1\
    \x07\x06\x1f\n\r\n\x05\x06\0\x02]\x02\x12\x04\xc1\x07\x20E\n\r\n\x05\x06\
    \0\x02]\x03\x12\x04\xc2\x07\x0e4\n\x0e\n\x04\x06\0\x02^\x12\x06\xc3\x07\
    \x02\xc4\x076\n\r\n\x05\x06\0\x02^\x01\x12\x04\xc3\x07\x06\x1f\n\r\n\x05\
    \x06\0\x02^\x02\x12\x04\xc3\x07\x20E\n\r\n\x05\x06\0\x02^\x03\x12\x04\
    \xc4\x07\x0e4\n\x0e\n\x04\x06\0\x02_\x12\x06\xc5\x07\x02\xc6\x077\n\r\n\
    \x05\x06\0\x02_\x01\x12\x04\xc5\x07\x06\x20\n\r\n\x05\x06\0\x02_\x02\x12\
    \x04\xc5\x07!G\n\r\n\x05\x06\0\x02_\x03\x12\x04\xc6\x07\x0e5\n\x0e\n\x04\
    \x06\0\x02`\x12\x06\xc7\x07\x02\xc8\x073\n\r\n\x05\x06\0\x02`\x01\x12\
    \x04\xc7\x07\x06\x1c\n\r\n\x05\x06\0\x02`\x02\x12\x04\xc7\x07\x1d?\n\r\n\
    \x05\x06\0\x02`\x03\x12\x04\xc8\x07\x0e1\n\x0e\n\x04\x06\0\x02a\x12\x06\
    \xc9\x07\x02\xca\x073\n\r\n\x05\x06\0\x02a\x01\x12\x04\xc9\x07\x06\x1c\n\
    \r\n\x05\x06\0\x02a\x02\x12\x04\xc9\x07\x1d?\n\r\n\x05\x06\0\x02a\x03\
    \x12\x04\xca\x07\x0e1\n\x0e\n\x04\x06\0\x02b\x12\x06\xcb\x07\x02\xcc\x07\
    *\n\r\n\x05\x06\0\x02b\x01\x12\x04\xcb\x07\x06\x13\n\r\n\x05\x06\0\x02b\
    \x02\x12\x04\xcb\x07\x14-\n\r\n\x05\x06\0\x02b\x03\x12\x04\xcc\x07\x0e(\
    \n\x0e\n\x04\x06\0\x02c\x12\x06\xcd\x07\x02\xce\x07*\n\r\n\x05\x06\0\x02\
    c\x01\x12\x04\xcd\x07\x06\x13\n\r\n\x05\x06\0\x02c\x02\x12\x04\xcd\x07\
    \x14-\n\r\n\x05\x06\0\x02c\x03\x12\x04\xce\x07\x0e(\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
